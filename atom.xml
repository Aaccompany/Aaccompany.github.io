<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://aaccompany.github.io/"/>
  <updated>2020-02-04T07:37:36.876Z</updated>
  <id>https://aaccompany.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java并发机制的底层实现原理（第二章）</title>
    <link href="https://aaccompany.github.io/2020/02/03/Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://aaccompany.github.io/2020/02/03/Java并发机制的底层实现原理/</id>
    <published>2020-02-02T16:00:00.000Z</published>
    <updated>2020-02-04T07:37:36.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java并发机制的底层实现原理"><a href="#Java并发机制的底层实现原理" class="headerlink" title="Java并发机制的底层实现原理"></a>Java并发机制的底层实现原理</h1><h2 id="1-Java运行过程"><a href="#1-Java运行过程" class="headerlink" title="1.  Java运行过程"></a>1.  Java运行过程</h2><p><img src="/2020/02/03/Java并发机制的底层实现原理/1.jpg" alt></p><p>Java中所使用的并发机制依赖于<code>JVM</code>的实现和CPU指令，所以需要研究的地方便为这两处</p><h2 id="2-多线程重要概念"><a href="#2-多线程重要概念" class="headerlink" title="2.多线程重要概念"></a>2.多线程重要概念</h2><h3 id="2-1-现代CPU模型"><a href="#2-1-现代CPU模型" class="headerlink" title="2.1.现代CPU模型"></a>2.1.现代CPU模型</h3><p>一个CPU中会存在多核心，每个核心都会有多个缓存，这么做解决了CPU和主存速度不匹配的问题</p><p>CPU在运算的时候会先从<code>高速缓存1</code>-&gt;<code>高速缓存2</code>-&gt;…-&gt;<code>主存</code>获取数据，如果有一处命中则不会继续向下获取数据</p><p><img src="/2020/02/03/Java并发机制的底层实现原理/2.jpg" alt></p><h3 id="2-2-多线程三大特性"><a href="#2-2-多线程三大特性" class="headerlink" title="2.2.多线程三大特性"></a>2.2.多线程三大特性</h3><p>多线程编程中如果这三个性质没有得到保证就容易出现安全问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可见性：一个线程中修改了某个值，在其他线程可以察觉最新值</span><br><span class="line">原子性：一个操作或者多个操作，要么一起执行要么都不执行，原子性就像数据库事务一样像一个团队共同生死</span><br><span class="line">有序性：程序执行的顺序于代码顺序一致</span><br></pre></td></tr></table></figure><h3 id="2-2-CPU术语的定义"><a href="#2-2-CPU术语的定义" class="headerlink" title="2.2. CPU术语的定义"></a>2.2. CPU术语的定义</h3><table><thead><tr><th align="center">术语</th><th align="center">英文单词</th><th align="left">术语描述</th></tr></thead><tbody><tr><td align="center">内存屏障</td><td align="center">memory barriers</td><td align="left">一组处理器指令，用于实现对内存操作的顺序限制（顺序性）</td></tr><tr><td align="center">缓冲行</td><td align="center">cache line</td><td align="left">CPU高速缓存中可以分配的最小存储单位。<br>处理器在填写缓存行时，会加载整个缓存行。<br>现代CPU需要执行几百次CPU指令</td></tr><tr><td align="center">原子操作</td><td align="center">atomic operations</td><td align="left">不可中断的一个或一系列操作</td></tr><tr><td align="center">缓冲行填充</td><td align="center">cache line fill</td><td align="left">当处理器识别到从内存中去读操作数是可缓存的<br>处理器读取整个高速缓存行到适应的缓存（<code>L1、L2、L3</code>到所有）</td></tr><tr><td align="center">缓存命中</td><td align="center">cache hit</td><td align="left">如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时<br>处理器从缓存中获取数据而不是从主存中获取数据</td></tr><tr><td align="center">写命中</td><td align="center">write hit</td><td align="left">当处理器将操作数写回到一个内存缓存区域时，它首先回检查这个缓存的内存地址<br>是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存<br>而不是写回到内存，这个操作被称为写命中</td></tr><tr><td align="center">写缺失</td><td align="center">write misses the cache</td><td align="left">一个有效的缓存行被写入到了不存在的内存区域</td></tr><tr><td align="center">比较并交换</td><td align="center">compare and swap</td><td align="left">CAS操作需要输入两个数值，一个是旧值（期望操作前的值）和一个新值<br>在操作期间先比较旧值有没有发生变化，如果没有发生变化则更新成功或者失败</td></tr><tr><td align="center">CPU流水线</td><td align="center">CPU pipeline</td><td align="left">指令的执行，需要取址、执行、IO等，这三个操作分别在不同CPU内部结构中执行<br>但是为了提高CPU的吞吐量，会将这些操作异步执行</td></tr><tr><td align="center">内存顺序冲突</td><td align="center">Memory order violation</td><td align="left">内存顺序冲突一般是由假共享起因的，假共享是指多个CPU同一时刻修改同一个缓存的不同部分<br>当出现了这个冲突的时候CPU必须清空CPU流水线</td></tr></tbody></table><h2 id="3-Volatile"><a href="#3-Volatile" class="headerlink" title="3. Volatile"></a>3. Volatile</h2><p>多线程编程中Volatile和Synchronized都是常见修饰符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">环境：</span><br><span class="line">存在两个线程A、B分别在不同的核心中运行</span><br><span class="line">存在一个共享变量var</span><br><span class="line">线程A线程B</span><br><span class="line">- 读取var-修改var</span><br><span class="line">- 进行操作</span><br><span class="line">- 读取var</span><br><span class="line"></span><br><span class="line">问题：</span><br><span class="line">线程A再第二次读取var的变量并不是最新的值，而是脏数据</span><br><span class="line">因为线程B再修改完数据之后只是将数据写入到了CPU的高速缓存中，并没有写到主存</span><br><span class="line">线程A再读取值的时候也只会读取到高速缓存的值</span><br><span class="line">导致线程A读取到的值是脏数据</span><br></pre></td></tr></table></figure><p>Volatile修饰符可以保证在<code>多处理器</code>环境下变量可见性</p><h3 id="3-1-volatile的定义与实现原理"><a href="#3-1-volatile的定义与实现原理" class="headerlink" title="3.1. volatile的定义与实现原理"></a>3.1. volatile的定义与实现原理</h3><p><code>Java编程语言允许线程访问共享变量，为了确保共享变量能够被准确和一直地更新，线程应该采用排他锁单独获取这个变量</code></p><p><code>是不是能够通过这个原理联想到在分布式环境下双缓冲的问题?</code></p><p>Java语言提供了volatile在一些情况下会比加锁效果好，如果一个字段被修饰为volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的</p><p>有volatile修饰的变量在进行写操作的时候，会在汇编指令中加入<code>lock</code>的标识，当<strong>多核处理器</strong>发现<code>lock</code>标识会做两件事情</p><ul><li>将当前处理器缓存行写入到主存中</li><li>上面的写入操作会使在其他处理器核心中缓存该内存地址的数据无效</li></ul><p>为了解决CPU与主存的速度不匹配造成的处理速度低下的问题，处理器将不直接与主存进行通信，而是通过高速缓存。</p><p>这就会在多核处理器中出现脏数据，因为每个核心都会有数据备份，当有一个核心修改了数据，其他核心数据并未读取最新的数据造成。</p><p>为了保证各个缓存数据一致性，会实现<strong>缓存一致性协议<code>MESI</code></strong>，每个处理器通过嗅探在总线上传播的数据来检查自己缓存是否已经过期，如果发现缓存过期，那么就会标识当前处理器的缓存为无效状态，当处理再次获取该缓存的时候会跳过缓存从主存获取最新值，并且修改缓存值。</p><h3 id="3-2-volatile的两条实现原则"><a href="#3-2-volatile的两条实现原则" class="headerlink" title="3.2. volatile的两条实现原则"></a>3.2. volatile的两条实现原则</h3><ul><li>Lock前缀指令会引起处理器将数据写回主存</li><li>一个处理器在将缓存写回主存，会导致其他处理器对应内存地址的缓存失效</li></ul><h3 id="3-3-volatile优化"><a href="#3-3-volatile优化" class="headerlink" title="3.3. volatile优化"></a>3.3. volatile优化</h3><p>从<code>3.2</code>中可以发现volatile 在写的过程中会导致其他处理器对应内存地址的缓存失效</p><p>所有多线程编程大师<code>Doug Lea</code>在<code>LinkedTransferQueue</code>类中，对头节点和尾节点进行字节填充</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列头节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">final</span> PaddedAtomicReference&lt;QNode&gt; head;</span><br><span class="line"><span class="comment">//队列尾节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">final</span> PaddedAtomicReference&lt;QNode&gt; tail;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddedAtomicReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AtomicReference</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用15个四节点的对象填充</span></span><br><span class="line">    Object p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pa,pb,pc,pd,pe;</span><br><span class="line">    PaddedAtomicReference(T r)&#123;</span><br><span class="line">        <span class="keyword">super</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么在对象中追加字节能够优化性能？</p><p>在<code>LinkedTransferQueue</code>中，内部类<code>PaddedAtomicReference</code>扩展到了(15+1)*4字节也就是64字节</p><p>现代CPU中高速缓存的缓存行是64字节宽，不支持部分填充缓存行，这意味着，如果队列的头节点和尾节点都不足64字节，处理器会将他们读取到同一个缓存行中，在多个处理器核心都会缓存这个head、tail。如果其中一个处理器核心修改head的话，根据缓存一致性协议，其他处理器核心的该缓存行将失效，导致无法在高速缓存中获取尾节点数据，需要从主存中获取大大的降低了操作速度。</p><p>在队列中，入列和出列操作都很频繁，这就导致在多线程环境下会存在很多高速缓存失效的情况，所以<code>Doug lea</code>使用追加头节点和尾节点到64字节方式来填充高速缓存，避免头节点和尾节点填充到同一个高速缓存行，使头、尾节点在修改时不会相互锁定，这将大大提高在多线程环境下入列出列操作速度。</p><h4 id="3-3-1-是不是什么时候都可以采用追加字节提高volatile效率？"><a href="#3-3-1-是不是什么时候都可以采用追加字节提高volatile效率？" class="headerlink" title="3.3.1.是不是什么时候都可以采用追加字节提高volatile效率？"></a>3.3.1.是不是什么时候都可以采用追加字节提高volatile效率？</h4><p>并不是在所有的场合都适用追加字节来提高volatile的效率，在一下两个场景时不能使用</p><ul><li><strong>缓存行为32字节宽的处理器：</strong>如<code>P6系列和奔腾处理器</code>，它们的高速缓存行为32字节宽</li><li><strong>共享变量并不会被频繁的写：</strong>使用追加字节的方式采用空间换时间，如果不经常写的变量一般是不会被锁住的，所以也没有必要进行字节追加</li></ul><p>在<code>JDK7</code>以上追加字节的方式会无效，因为<code>JVM</code>会智能淘汰或重新排列无用字段，所以需要使用其他方式来进行字段追加</p><h2 id="4-Synchronized"><a href="#4-Synchronized" class="headerlink" title="4.  Synchronized"></a>4.  Synchronized</h2><h3 id="4-1-什么是Synchronized？"><a href="#4-1-什么是Synchronized？" class="headerlink" title="4.1. 什么是Synchronized？"></a>4.1. 什么是Synchronized？</h3><p>synchronized在1.6之前被称为重量级锁，性能低下。</p><p>1.6之后synchronized涅槃重生，进行了大量优化。提高了锁在释放和获取的效率</p><ul><li>进行锁优化，例如<strong>自旋锁、适应自旋锁、锁消除、锁粗化</strong></li><li>例如引入<strong>无锁、偏向锁、轻量级锁 ，重量级锁</strong>。增加锁升级的机制</li></ul><h3 id="4-2-锁优化"><a href="#4-2-锁优化" class="headerlink" title="4.2.锁优化"></a>4.2.锁优化</h3><p>观察下面的锁优化其实可以很容易发现，主要目的减少线程上下文切换次数，提高系统运行速度</p><h4 id="4-2-1-自旋锁"><a href="#4-2-1-自旋锁" class="headerlink" title="4.2.1.自旋锁"></a>4.2.1.自旋锁</h4><p>线程在获取锁的过程中，并不会获取不到锁就直接将当前线程加入同步队列，而是会在获取锁处循环获取。</p><p>因为在一般的同步代码块中，任务量少，执行时间很快，没有必要将线程加入同步队列，而是在锁处循环获取锁，其他线程能够很快的将锁释放。（默认自旋次数为10次）</p><p>好处：因为同步代码块任务量少，执行时间短，能够很快释放锁，其他线程也不需要加入到同步队列，减少了线程上下文切换，加快了线程运行时间</p><p>坏处：循环获取锁的弊端很明显，就是需要占用CPU运算资源，做无用的循环获取锁，如果获取不到则一直循环，浪费运输资源。所以同步代码块任务量大时使用自旋锁将降低系统运行效率</p><h4 id="4-2-2-自适应自旋锁"><a href="#4-2-2-自适应自旋锁" class="headerlink" title="4.2.2.自适应自旋锁"></a>4.2.2.自适应自旋锁</h4><p>自适应自旋锁在自旋锁的基础上做了增强。</p><p>在Java 6 中加入了自适应自旋锁，该锁不同于自旋锁的地方为，该锁并非采用固定的自旋次数，而是会自动感知上次自旋时间以及锁的拥有者的状态来做。如果上次再很短的时间自旋获取锁，那么可以认为这次也能够在很短时间的获取到锁，那么就会允许它增加自旋次数。相反如果上次自旋没有获取到锁或者是很长时间才获取到锁，那么再下次获取锁的时候就会放弃自旋或者降低自旋次数</p><p>这样做的好处是避免因为自旋而浪费CPU的运算资源</p><h4 id="4-2-3-锁消除"><a href="#4-2-3-锁消除" class="headerlink" title="4.2.3.锁消除"></a>4.2.3.锁消除</h4><p>多线程编程中，JVM会感知是否存在锁竞争的现象，如果不存在锁竞争的现象，那么将会撤销锁</p><p>锁消除的依据是逃逸分析的数据支持。如果不存在竞争，那么为什么还需要加锁，所以锁消除能够去掉没有必要请求锁和释放锁的时间。</p><p>但是多线程编程不是程序员编写的么？那为什么会出现不存在锁竞争但是还加锁的操作呢？是程序员有问题么？</p><p>系统开发的过程中，不是说我们这样写就不会出现这个现象，它可能会因为我们不小心调用了<code>JDK</code>内置类或者第三方类库的时候出现的加锁操作</p><p>例如String Buffer、Vector、Hash Table等等，他们在一些方法上都会存在加锁操作，但是如果在单线程，或者变量未逸出的时候，这些加锁操作是否有必要？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">vectorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">            vector.add(i + <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(vector);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>观察一下上方代码可以发现，vector变量一直在方法内，并没有逸出操作。所以它是不会出现安全问题，但是<code>vector.add()</code>会出现加锁操作，JVM检查到没有变量逸出，这时候就会锁消除</p><h4 id="4-2-4-锁粗化"><a href="#4-2-4-锁粗化" class="headerlink" title="4.2.4.锁粗化"></a>4.2.4.锁粗化</h4><p>多线程编程中，加锁操作一般都是在涉及到共享变量的时候才存在，而且在编程的过程中也会刻意的将同步代码块范围弄的小点，但是如果在代码中连续获取同一把锁，那么JVM会将锁的范围扩大，避免刚释放锁没有过多久又要申请锁的问题。</p><h3 id="4-3-Synchronized以什么做为锁？"><a href="#4-3-Synchronized以什么做为锁？" class="headerlink" title="4.3. Synchronized以什么做为锁？"></a>4.3. Synchronized以什么做为锁？</h3><p>在Java中所有对象都可以作为锁对象，具体表现为3类</p><ul><li>对于普通同步方法，锁对象为当前实例对象</li><li>对于静态同步方法，锁对象为当前实例的类对象</li><li>对于同步方法块，<code>synchronized(lockObject)</code>锁对象为配置的对象</li></ul><h3 id="4-4-Synchronized在JVM如何体现？"><a href="#4-4-Synchronized在JVM如何体现？" class="headerlink" title="4.4. Synchronized在JVM如何体现？"></a>4.4. Synchronized在JVM如何体现？</h3><p>JVM基于进入和退出 <strong>Monitor</strong>对象来实现<strong>方法同步</strong>和<strong>代码块同步</strong>，但是两者具体实现不一样。代码块的同步实现是通过<code>monitorenter</code>和<code>monitorexit</code>来实现。方法同步时使用另外一种方式实现，但是JVM规范中没有详细说明。但是同步方法也可以使用两个指令来实现同步。</p><p><code>monitorenter</code>：在代码编译后由JVM插入到同步方法前</p><p><code>monitorexit</code>：在同步方法结束处和在异常结束处添加该指令。在异常处添加指令是为了避免无法释放锁，所以查看生成字节码文件会发现存在两个<code>monitorexit</code>指令</p><h3 id="4-5-Synchronized同步过程"><a href="#4-5-Synchronized同步过程" class="headerlink" title="4.5. Synchronized同步过程"></a>4.5. Synchronized同步过程</h3><p>每个对象在对象头都会有<code>monitor</code>的标识，当执行到同步方法的时候，当前线程会尝试获取对应对象的<code>monitor</code>，当获取到了则执行同步代码，否则将进入同步队列</p><h4 id="4-5-1-对象头"><a href="#4-5-1-对象头" class="headerlink" title="4.5.1.对象头"></a>4.5.1.对象头</h4><p>synchronized使用的锁是存在Java对象头的。如果Java对象为数组则虚拟机用3个字宽（Word）存储对象头，如果Java对象为非数组则用2个字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32 bit</p><p>Java对象对数据结构</p><table><thead><tr><th align="center">长度</th><th align="center">内容</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">32/64 bit</td><td align="center">Mark Word</td><td align="center">存储对象的HashCode和锁信息等</td></tr><tr><td align="center">32/64 bit</td><td align="center">Class Metadata Address</td><td align="center">存储对象的类对象指针</td></tr><tr><td align="center">32/64 bit</td><td align="center">Array Length</td><td align="center">数组的长度（对象为数组时）</td></tr></tbody></table><p>Java对象头Mark Word存储结构以及变化过程</p><table><thead><tr><th align="center">锁状态</th><th align="center">25 bit</th><th align="center">4 bit</th><th align="center">1 bit 是否为偏向锁</th><th align="center">2 bit 锁标志</th></tr></thead><tbody><tr><td align="center">无锁状态</td><td align="center">对象的HashCode</td><td align="center">对象的分代年龄（最大15岁）</td><td align="center">0</td><td align="center">01</td></tr><tr><td align="center">偏向锁</td><td align="center">线程ID( 占两部分Epoch</td><td align="center">Epoch)对象分代年龄</td><td align="center">1</td><td align="center">01</td></tr><tr><td align="center">轻量级锁</td><td align="center">指向栈中锁记录指针</td><td align="center">指向栈中锁记录指针</td><td align="center">指向栈中锁记录指针</td><td align="center">00</td></tr><tr><td align="center">重量级锁</td><td align="center">执行互斥量的指针</td><td align="center">执行互斥量的指针</td><td align="center">执行互斥量的指针</td><td align="center">10</td></tr><tr><td align="center">GC标记</td><td align="center">空</td><td align="center">空</td><td align="center">空</td><td align="center">11</td></tr></tbody></table><p>这个时候观察表格可以发现，为什么需要1 bit来描述是否为偏向锁，因为对象头的状态有5种，但是锁标记位只有2 bit导致不够描述，所以添加多一个bit作为说明</p><h3 id="4-6-锁的升级与对比"><a href="#4-6-锁的升级与对比" class="headerlink" title="4.6.锁的升级与对比"></a>4.6.锁的升级与对比</h3><p>锁会锁着锁的竞争激烈程度进行升级，但是不能降级，这样做的目的是为了提高获取锁和释放锁的效率</p><h4 id="4-6-1-偏向锁"><a href="#4-6-1-偏向锁" class="headerlink" title="4.6.1.偏向锁"></a>4.6.1.偏向锁</h4><p>偏向锁顾名思义，偏向锁会偏向一个线程。</p><p>在大多数情况下，锁不仅不存在多线程竞争，而且总是同一个线程进入同步代码块，如果不断的进行获取锁释放锁效率将降低很多</p><p>所以偏向锁会记录第一次获取锁的线程ID，并且在这个线程再次进入的时候，直接放行，加快了进入同步代码块的速度</p><h5 id="4-6-1-1-偏向锁的获取"><a href="#4-6-1-1-偏向锁的获取" class="headerlink" title="4.6.1.1.偏向锁的获取"></a>4.6.1.1.偏向锁的获取</h5><p><img src="/2020/02/03/Java并发机制的底层实现原理/4.jpg" alt></p><h5 id="4-6-1-2-偏向锁的释放"><a href="#4-6-1-2-偏向锁的释放" class="headerlink" title="4.6.1.2.偏向锁的释放"></a>4.6.1.2.偏向锁的释放</h5><p>偏向锁采用了一种等到出现多线程竞争的情况才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</p><p>偏向锁的撤销，需要等待全局安全点（也就是GC点）。</p><p>偏向锁的过程</p><ul><li>暂停拥有偏向锁的线程</li><li>检查拥有偏向锁的线程是否存活，如果该线程不处于活动状态，则将该对象头设置成无锁状态</li><li>如果线程处于活动状态，拥有偏向锁的线程栈会被执行，遍历变相对象的锁记录，栈中的锁记录和对象头的Mark Word 要么重新偏向其他线程，要么恢复到无锁状态或标记对象不适合作为偏向锁，最后唤醒暂停的线程</li></ul><h5 id="4-6-1-3-偏向锁流程图"><a href="#4-6-1-3-偏向锁流程图" class="headerlink" title="4.6.1.3.偏向锁流程图"></a>4.6.1.3.偏向锁流程图</h5><p><img src="/2020/02/03/Java并发机制的底层实现原理/3.jpg" alt></p><h5 id="4-6-1-4-关闭偏向锁"><a href="#4-6-1-4-关闭偏向锁" class="headerlink" title="4.6.1.4.关闭偏向锁"></a>4.6.1.4.关闭偏向锁</h5><p>如果系统存在很明显的锁竞争关系，那么可以关闭偏向锁，提高系统的允许速度。减少锁升级的过程</p><p>Java 6后默认开启偏向锁，但是它是存在启动延迟，也就是说在系统启动后X秒才开启偏向锁，如果又必要的话可以调整延迟时间，<code>-XX:BiasedLockingStartupDelay=0</code>。</p><p>如果系统对锁都存在竞争关系，那么可以关闭偏向锁<code>-XX:-UseBiasedLocking=flase</code>，那么系统将直接进入轻量级锁状态</p><h4 id="4-6-2-轻量级锁"><a href="#4-6-2-轻量级锁" class="headerlink" title="4.6.2.轻量级锁"></a>4.6.2.轻量级锁</h4><p>会使用锁优化中的自适应锁自旋</p><h5 id="4-6-2-1-轻量级锁的获取"><a href="#4-6-2-1-轻量级锁的获取" class="headerlink" title="4.6.2.1.轻量级锁的获取"></a>4.6.2.1.轻量级锁的获取</h5><ul><li>线程栈中创建存储锁记录空间</li><li>将对象头中的Mark Word复制到锁记录空间（这个过程官方称之为Displaced Mark Word)</li><li>使用<code>CAS</code>替换对象头中Mark Word指向线程栈中锁记录，成功则获取锁，失败则<strong>自旋</strong></li></ul><h5 id="4-6-2-2-轻量级锁的释放"><a href="#4-6-2-2-轻量级锁的释放" class="headerlink" title="4.6.2.2.轻量级锁的释放"></a>4.6.2.2.轻量级锁的释放</h5><ul><li>使用<code>CAS</code>将锁记录中的Displaced Mark Word复制回对象头中Mark Word</li><li>如果成功则说明释放锁成功</li><li>失败则说明发生锁竞争，升级为重量级锁</li></ul><h5 id="4-6-2-3-轻量级锁膨胀流程图"><a href="#4-6-2-3-轻量级锁膨胀流程图" class="headerlink" title="4.6.2.3.轻量级锁膨胀流程图"></a>4.6.2.3.轻量级锁膨胀流程图</h5><p>因为自旋会消耗CPU的运算资源，为了避免无用的自旋，一旦升级为重量级锁，则不会降级了。当锁处于这个重量级锁的状态，其他线程试图获取锁时都会阻塞，当持有锁的线程释放锁之后会唤醒所有被阻塞的线程，接下来则会进行锁竞争的过程。</p><p><img src="/2020/02/03/Java并发机制的底层实现原理/5.jpg" alt></p><h4 id="4-6-3-不同锁的对比"><a href="#4-6-3-不同锁的对比" class="headerlink" title="4.6.3.不同锁的对比"></a>4.6.3.不同锁的对比</h4><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗<br>和非同步方法仅仅存在纳秒级的差距</td><td>如果线程间存在锁竞争<br>会带来额外的锁撤销消耗</td><td>适用于只有一个线程访问同步代码块<br>没有过多的锁竞争</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞<br>提高了程序响应速度</td><td>始终得不到锁的线程将不断地自旋浪费CPU运算</td><td>追求响应时间<br>同步代码块执行时间很快<br>适用于存在少量锁竞争场景</td></tr><tr><td>重量级锁</td><td>线程不会自旋，减少CPU的浪费</td><td>不断的进行请求锁和释放锁<br>存在大量的线程上下文切换的消耗</td><td>执行速度最慢，因为相比于轻量级锁<br>多了很多线程上下文切换的时间<br>适用于锁竞争激烈的场景</td></tr></tbody></table><h2 id="5-原子操作的实现原理"><a href="#5-原子操作的实现原理" class="headerlink" title="5.原子操作的实现原理"></a>5.原子操作的实现原理</h2><p>原子（atomic）本意是“不可进一步分割的最小粒子”，而原子操作（atomic operation)意为“不可以被中断的一个或一系列的操作”</p><h3 id="5-1-处理器如何实现原子操作"><a href="#5-1-处理器如何实现原子操作" class="headerlink" title="5.1.处理器如何实现原子操作"></a>5.1.处理器如何实现原子操作</h3><ul><li>解决方案有两种：<ul><li>总线加锁：对总线加锁，在写的过程中，其他CPU都无法访问主存</li><li>缓存加锁：对缓存行加锁，在写的过程中会锁住该缓存行，在其他CPU中该缓存行失效，重新从主存获取</li></ul></li><li>处理器会自动保证基本的内存操作的原子性</li><li><strong>两种情况下处理器不会适用缓存行锁定</strong><ul><li>数据跨多个缓存行，CPU会采用锁总线操作；数据不能被加载进高速缓存</li><li>处理器不支持锁缓存行</li></ul></li></ul><h3 id="5-2-Java如何实现原子操作"><a href="#5-2-Java如何实现原子操作" class="headerlink" title="5.2.Java如何实现原子操作"></a>5.2.Java如何实现原子操作</h3><p>Java中很多操作都非原子操作，例如最常见的<code>i++</code>就是一个非原子的操作</p><p>Java中可以采用<code>CAS</code>和加锁操作来完成原子操作</p><h4 id="5-2-1-使用循环CAS实现原子操作"><a href="#5-2-1-使用循环CAS实现原子操作" class="headerlink" title="5.2.1.使用循环CAS实现原子操作"></a>5.2.1.使用循环CAS实现原子操作</h4><p>JVM中的CAS操作是底层使用了处理器提供的CMPXCHG指令实现。</p><p>自旋CAS实现的基本思路循环CAS操作直到完成为止</p><blockquote><p>从JDK1.5开始，Java提供的并发包提供了一些类来支撑某些原子操作，如AtomicBoolean(用原子方式更新Boolean)，AtomicInteger（用原子操作更新int值）等等</p></blockquote><p>下面操作即为实现CAS线程安全的计数器方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicI = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Counter counter = <span class="keyword">new</span> Counter();</span><br><span class="line">        List&lt;Thread&gt; threadList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//创建100个线程 每个线程任务为计数自增1000次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; <span class="number">1000</span>; i1++) &#123;</span><br><span class="line">                        counter.safeCount();</span><br><span class="line">                        counter.count();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threadList.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开启100个线程</span></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//main线程等待100个线程执行完毕</span></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程安全计数器:"</span>+counter.atomicI.get());</span><br><span class="line">        System.out.println(<span class="string">"非线程安全计数器:"</span>+counter.i);</span><br><span class="line">        System.out.println(<span class="string">"执行耗时:"</span>+(System.currentTimeMillis()-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用CAS的线程安全计数器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">safeCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//自旋CAS操作，减少线程上下文切换</span></span><br><span class="line">        <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">            <span class="comment">//获取最新值</span></span><br><span class="line">            <span class="keyword">int</span> i = atomicI.get();</span><br><span class="line">            <span class="comment">//使用CAS替换值，如果生成则退出</span></span><br><span class="line">            <span class="keyword">boolean</span> suc = atomicI.compareAndSet(i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (suc)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非线程安全计数器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-使用CAS实现原子操作的三大问题"><a href="#5-2-2-使用CAS实现原子操作的三大问题" class="headerlink" title="5.2.2.使用CAS实现原子操作的三大问题"></a>5.2.2.使用CAS实现原子操作的三大问题</h4><ul><li>ABA问题<ul><li>在CAS的原理上，是检查旧值和内存中的值是否一样，如果一样就替换为新值。这就会出现一个BUG，如果在更新的过程中有人修改了值，最后又变成了旧值，那么它在检查的时候CAS会发现值未发现改变，然后替换。</li><li>这个概念可能会很抽象，并且不好理解有啥危害。个人理解，简单的说就是狸猫换太子</li><li>举个例子：<ul><li>小A有一个满的水，小A离开了房间</li><li>小B看到房间有杯水，喝完了然后倒回去</li><li>小A回来看到水还是水，然后继续喝了</li></ul></li><li>解决方案：<ul><li>每次修改都添加版本号，就像1A-&gt;2B-&gt;3A，这样就能够避免出现ABA的问题</li><li>在Java中提供了AtomicStampedReference类来实现</li></ul></li></ul></li><li>循环时间长开销大<ul><li>通过<code>5.2.1</code>的代码可以发现有个<code>for(;;)</code>操作，不断的循环，做无用的运算</li></ul></li><li>只能保证一个变量进行原子操作<ul><li>如果有多个变量需要进行CAS原子操作，可以将多个变量合成一个Java对象，Java提供了AtomicReference来实现对象的原子操作</li></ul></li></ul><h3 id="5-3-Java使用锁机制来完成原子操作"><a href="#5-3-Java使用锁机制来完成原子操作" class="headerlink" title="5.3.Java使用锁机制来完成原子操作"></a>5.3.Java使用锁机制来完成原子操作</h3><p>锁机制保证了只有获取锁的线程才能进入同步代码块。JVM内部实现了很多锁机制，有偏向锁、轻量级锁、重量级锁（互斥锁），JVM中锁机制都是通过CAS来完成获取锁和释放锁</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java并发机制的底层实现原理&quot;&gt;&lt;a href=&quot;#Java并发机制的底层实现原理&quot; class=&quot;headerlink&quot; title=&quot;Java并发机制的底层实现原理&quot;&gt;&lt;/a&gt;Java并发机制的底层实现原理&lt;/h1&gt;&lt;h2 id=&quot;1-Java运行过程&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="多线程编程系列" scheme="https://aaccompany.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="多线程编程" scheme="https://aaccompany.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程的挑战（第一章）</title>
    <link href="https://aaccompany.github.io/2020/01/31/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98/"/>
    <id>https://aaccompany.github.io/2020/01/31/并发编程的挑战/</id>
    <published>2020-01-30T16:00:00.000Z</published>
    <updated>2020-02-03T06:02:20.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程的挑战"><a href="#并发编程的挑战" class="headerlink" title="并发编程的挑战"></a>并发编程的挑战</h1><h2 id="1-什么是多线程？"><a href="#1-什么是多线程？" class="headerlink" title="1.什么是多线程？"></a>1.什么是多线程？</h2><h3 id="1-1-为什么要使用多线程？"><a href="#1-1-为什么要使用多线程？" class="headerlink" title="1.1.为什么要使用多线程？"></a>1.1.为什么要使用多线程？</h3><p><strong>并发编程的好处是为了提高系统运行速度</strong></p><p>并不是启动越多的线程系统的运行速度就能越快，因为在多线程编程中会存在各种坑。例如：死锁、线程的上下文切换、硬件、软件。</p><p>如果没有理解好这些各种各样的坑的话，那么写出来的多线程程序并不能提高系统运行速度，反而会降低系统的运行速度</p><h3 id="1-2-什么是线程的上下文切换"><a href="#1-2-什么是线程的上下文切换" class="headerlink" title="1.2.什么是线程的上下文切换"></a>1.2.什么是线程的上下文切换</h3><p>CPU（单核）在某个时刻只能有一个线程执行，那系统中存在那么多的线程该如何执行呢？</p><p>CPU通过给每个线程分配时间片来实现多线程的执行。（时间片：CPU将时间划分为一个个小的时间段，每个时间段处理一个线程）在一个时间片之后如果该线程没有执行完毕，那么就会保存该线程当前状态，并且加入下个待执行线程的状态，执行</p><p>CPU保存当前线程状态–&gt;加载下一个线程状态  ：这个过程为线程的上下文切换</p><p><strong>CPU线程的上下文切换会导致系统的运行速度低下</strong></p><h3 id="1-3-如何查看上下文切换次数和时长"><a href="#1-3-如何查看上下文切换次数和时长" class="headerlink" title="1.3.如何查看上下文切换次数和时长"></a>1.3.如何查看上下文切换次数和时长</h3><ul><li><code>Lmbench3</code>可以测量上下文切换的时长</li><li>Linux命令<code>vmstat</code>可以测量上下文切换次数</li></ul><h3 id="1-4-如何减少线程上下文切换"><a href="#1-4-如何减少线程上下文切换" class="headerlink" title="1.4.如何减少线程上下文切换"></a>1.4.如何减少线程上下文切换</h3><p>减少上下文切换的方法有无锁编程、<code>CAS</code>算法、使用最少线程和使用协程</p><ul><li>无锁并发编程：多线程竞争锁的时候，会引发频繁的上下文切换，所以在多线程处理数据的时，可以采用一些方法避免使用锁，例如将数据的ID进行Hash算法取模分段，不同的线程处理不同数据段</li><li><code>CAS</code>算法：Java的<code>Atomic</code>包下有许多类可以保证对单个变量的修改具有原子性，同时不会存在线程上下文切换，因为使用了自旋的模式来完成修改</li><li>使用最少线程：避免创建不需要的线程，比如系统任务量很少，但是线程数很多，导致会出现无用的线程上下文切换，所以在使用线程池的时候，并不是说将线程数设置越大越好，而是需要按需设置</li><li>协程：进程-&gt;线程-&gt;协程（上下级关系都为一对多），协程目前的多线程模型的最小单位，协程不由操作系统系统，而是由程序控制，减少了线程的上下文切换，因为根本不存在多线程。</li></ul><h2 id="2-锁"><a href="#2-锁" class="headerlink" title="2.锁"></a>2.锁</h2><h3 id="2-1-什么是锁？"><a href="#2-1-什么是锁？" class="headerlink" title="2.1.什么是锁？"></a>2.1.什么是锁？</h3><p>旅游的时候会出现一个现象，许许多多的人在厕所门口排队上厕所，而上厕所的步骤就是等待上个人<strong>开门</strong>出来-&gt;下个人进入<strong>锁门</strong></p><p>每个不同的人可以理解为不同的线程</p><p>厕所坑可以理解为临界资源</p><p>厕所坑一次只能有一个人蹲，所以人在上厕所的可以将门锁起来，让别人不能进来一起蹲</p><p>所以锁的作用可以理解为让满足条件的线程对临界资源访问</p><p>但是并不是说锁只能由一个线程持有，在读写锁<code>ReentrantReadWriteLock</code>，读锁和写锁互斥，读锁和读锁是共享。也就是说读锁和写锁在一个时刻中只用有一个持有锁，但是读锁和读锁能够同时持有锁</p><h3 id="2-2-死锁"><a href="#2-2-死锁" class="headerlink" title="2.2.死锁"></a>2.2.死锁</h3><ul><li><p>一个线程一直持有锁并且不释放锁，导致后面的线程无法执行</p></li><li><p>多个线程对多个资源获取顺序不一致导致相互等待对方释放资源，陷入死锁。例如 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程： t1 t2</span><br><span class="line">资源： AB</span><br><span class="line">资源： B   A</span><br><span class="line">这就会出现</span><br><span class="line">t1在等待B资源，但是B资源被t2持有</span><br><span class="line">t2在等待A资源，但是A资源被t1持有</span><br><span class="line">t1 t2 陷入相互等待的状态，这种状态也就是死锁</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-1-如何避免死锁"><a href="#2-2-1-如何避免死锁" class="headerlink" title="2.2.1.如何避免死锁"></a>2.2.1.如何避免死锁</h4><ul><li>避免一个线程持有多个锁</li><li>一定要在<code>finally</code>代码块中释放锁</li><li>避免在一段代码中使用多个锁，尽量做到一个代码块占用一个锁</li><li>尝试使用定时锁，避免重复等待锁资源<code>lock.tryLock(timeout)</code></li><li>对于数据库锁，加锁和解锁必须在同一个<code>Connection</code>中，否则会失效、并且会因为无法释放锁导致出现死锁</li></ul><h2 id="3-多线程编程与资源限制"><a href="#3-多线程编程与资源限制" class="headerlink" title="3.多线程编程与资源限制"></a>3.多线程编程与资源限制</h2><h3 id="3-1-什么是资源限制"><a href="#3-1-什么是资源限制" class="headerlink" title="3.1.什么是资源限制"></a>3.1.什么是资源限制</h3><p>多线程程序的运行速度并不是线程数多变快，而会受制于计算机的<strong>硬件资源和软件资源</strong></p><p>例如：服务器下载速度<code>2M/S</code>，客户端单线程下载某资源的速度是<code>1M/S</code>，这时候并不会因为开启10个线程而让客户端的下载速度达到<code>10M/S</code>（因为服务器最大下载速度是<code>2M/S</code>，所以客户端最大只能开启两个线程让下载速度到达<code>2M/S</code>)</p><p>所以在多线程编程中需要考虑资源限制这个问题。</p><ul><li>硬件资源：网络带宽、硬盘读写速度、CPU的处理速度</li><li>软件资源：数据库的最大连接数、socket的连接数</li></ul><h3 id="3-2-资源限制引发的问题"><a href="#3-2-资源限制引发的问题" class="headerlink" title="3.2.资源限制引发的问题"></a>3.2.资源限制引发的问题</h3><p>客户端如果是单核CPU，强行将代码由串行修改为并行，那么会因为客户端的单核CPU导致预计中的并行执行仍然在串行执行，这样会造成多余的线程上下文切换时间消耗。</p><p>所以多线程编程中需要考虑资源限制引发的问题（并未提高效率，反倒于效率下降）</p><h3 id="3-3-如何解决资源限制的问题"><a href="#3-3-如何解决资源限制的问题" class="headerlink" title="3.3.如何解决资源限制的问题"></a>3.3.如何解决资源限制的问题</h3><p>解决资源限制的方法，就要从为什么会出现资源限制中解决。</p><p>发生资源限制是因为 <strong>硬件限制、软件限制</strong> 那么解决这两个限制，就可从根本上解决问题</p><ul><li>解决硬件限制：单机处理速度跟不上，可以追加服务器数量，让运算在多机器上并发的执行</li><li>解决软件限制：合理提高连接池数量、socket连接数量、代码质量</li></ul><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ul><li>方腾飞：《Java并发编程的艺术》 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发编程的挑战&quot;&gt;&lt;a href=&quot;#并发编程的挑战&quot; class=&quot;headerlink&quot; title=&quot;并发编程的挑战&quot;&gt;&lt;/a&gt;并发编程的挑战&lt;/h1&gt;&lt;h2 id=&quot;1-什么是多线程？&quot;&gt;&lt;a href=&quot;#1-什么是多线程？&quot; class=&quot;header
      
    
    </summary>
    
      <category term="多线程编程系列" scheme="https://aaccompany.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="多线程编程" scheme="https://aaccompany.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>重走框架系列说明</title>
    <link href="https://aaccompany.github.io/2019/07/14/%E9%87%8D%E8%B5%B0%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97%E8%AF%B4%E6%98%8E/"/>
    <id>https://aaccompany.github.io/2019/07/14/重走框架系列说明/</id>
    <published>2019-07-14T11:47:47.000Z</published>
    <updated>2019-07-14T12:02:48.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重走框架系列说明"><a href="#重走框架系列说明" class="headerlink" title="重走框架系列说明"></a>重走框架系列说明</h1><h2 id="自我反思"><a href="#自我反思" class="headerlink" title="自我反思"></a>自我反思</h2><p>由于思想觉悟出现了问题，总想着快点学习，却没有想到丢了芝麻也丢了西瓜。</p><p>自己的基础严重的不牢固，导致前进的十分缓慢。又看了许多大神的教学视频，感觉自己依旧十分的弟弟，所以觉得自己有点揠苗助长，故有了重走框架系列，希望自己能够在这次重新学习后端框架的时候能够不断发现自己的知识盲区，找到自己的不足。</p><p>在重走框架的道路上，希望能够借助自己做的项目中，仔细思考在项目中引入新的后端框架会对系统增加严重的BUG，以及对这些BUG如何去做到预防以及解决。</p><p>借用《劝学》</p><p>故不积跬步，无以至千里，不积小流，无以成江海。</p><p>望自己能够一直记住。</p><p><img src="/2019/07/14/重走框架系列说明/1.gif" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重走框架系列说明&quot;&gt;&lt;a href=&quot;#重走框架系列说明&quot; class=&quot;headerlink&quot; title=&quot;重走框架系列说明&quot;&gt;&lt;/a&gt;重走框架系列说明&lt;/h1&gt;&lt;h2 id=&quot;自我反思&quot;&gt;&lt;a href=&quot;#自我反思&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="杂谈" scheme="https://aaccompany.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="https://aaccompany.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>重走spring框架 AOP部分</title>
    <link href="https://aaccompany.github.io/2019/07/14/%E9%87%8D%E8%B5%B0Spring%E6%A1%86%E6%9E%B6(AOP%E9%83%A8%E5%88%86)/"/>
    <id>https://aaccompany.github.io/2019/07/14/重走Spring框架(AOP部分)/</id>
    <published>2019-07-14T11:40:50.000Z</published>
    <updated>2020-02-01T11:11:32.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重走Spring框架（AOP部分）"><a href="#重走Spring框架（AOP部分）" class="headerlink" title="重走Spring框架（AOP部分）"></a>重走Spring框架（AOP部分）</h1><h2 id="1-分析银行转账流程"><a href="#1-分析银行转账流程" class="headerlink" title="1.分析银行转账流程"></a>1.分析银行转账流程</h2><h3 id="1-1-银行转账出现的问题"><a href="#1-1-银行转账出现的问题" class="headerlink" title="1.1.银行转账出现的问题"></a>1.1.银行转账出现的问题</h3><ul><li>从代码的角度上分析<ul><li>本次代码架构为：<code>spring + dbutils + c3p0</code></li><li>从下图代码可以分析出，如果某个流程出现了异常，那么就会出现数据不匹配的现象，即可能出现转账没有进入目标账户。</li><li>发生原因：<ul><li><code>queryRunner</code>对象在系统中采用的是多例模式，并且<code>queryRunner</code>在每次创建的时候会<code>DataSource.getConnection</code>意味着每次都是获取了新的连接对象，并且<code>QeuryRunner</code>对象在执行完语句后就会让内置的<code>connection</code>自动提交，将<code>QeuryRunner</code>对象中内置的<code>Connection</code>对象提取到<code>service</code>层便能在该层进行事务控制了。</li></ul></li><li>解决方案：<ul><li>将事务控制从<code>dao</code>层迁移到<code>service</code>层，让<code>service</code>具有<code>commit  rallback</code>的权利</li></ul></li><li><strong><code>ThreadLoad</code>数据和线程绑定？</strong><ul><li><code>ThreadLocal</code>是什么？<ul><li>这是一个与单个线程绑定的类，这个类会开在内存中开辟一个空间，专门存储这个线程专属数据，做到线程隔离。</li></ul></li><li><code>ThreadLocal</code>如何实现的？<ul><li>每个线程都会去维护一个<code>ThreadLocalMap</code>，在这个特殊的Map中，key指的是线程本身，而value是存储的值，所以能够实现一个独属单个线程的数据存储，做到线程隔离。</li></ul></li><li><code>ThreadLocal</code>存储的数据会一直存在吗？<ul><li>在<code>ThreadLocal</code>的值不会一直存在，当线程死亡的时候，存储的值的空间也会被归还，但是需要用到<code>JVM</code>的垃圾处理机制，但是如果我们能够确定什么时候使用完毕，那么我们可以自行删除数据，调用<code>ThreadLocal.remove()</code>便可以做到数据与线程解绑，加快垃圾回收。</li></ul></li></ul></li></ul></li></ul><p><img src="/2019/07/14/重走Spring框架(AOP部分)/8.jpg" alt></p><h4 id="1-1-1-第一次改良"><a href="#1-1-1-第一次改良" class="headerlink" title="1.1.1.第一次改良"></a>1.1.1.第一次改良</h4><ul><li><p>找到问题所在，将<code>Connection</code>与<code>ThreadLocal</code>线程绑定，保证在执行一次业务操作的时候使用的是同一个<code>Connection</code>同时在这个<code>Connection</code>中开启事务</p></li><li><p>流程图</p><p><img src="/2019/07/14/重走Spring框架(AOP部分)/9.jpg" alt></p></li><li><p><strong>第一步，创建<code>ConnectionUtils</code>：</strong>将原本注入到<code>QueryRunner</code>中的线程池取出来，改为由自己从<code>DataSource</code>获取<code>Connection</code>，将获取到的<code>Connection</code>与<code>ThreadLocal</code>进行线程绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Accompany</span></span><br><span class="line"><span class="comment"> * 获取当前线程的Connection</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Connection&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个连接对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Connection对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getThreadLocalConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection connection = threadLocal.get();</span><br><span class="line">            <span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//表示当前线程没有连接对象</span></span><br><span class="line">                connection = dataSource.getConnection();</span><br><span class="line">                threadLocal.set(connection);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> connection;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"出现未知异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解除线程与Connection的绑定关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>第二步，在<code>Service</code>层中开启事务：</strong>将<code>ConnectionUtils</code>注入到<code>Service</code>层中，获取到当前线程的<code>Connection</code>，然后开启线程并且传递到<code>dao</code>层中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String resourceId, String targetId, <span class="keyword">float</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取到当前线程的Connection对象</span></span><br><span class="line">        Connection connection = connectionUtils.getThreadLocalConnection();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.开启事务管理</span></span><br><span class="line">            connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//3.获取账户信息</span></span><br><span class="line">            Optional&lt;Account&gt; resourceOptional = accountDao.findById(resourceId);</span><br><span class="line">            Optional&lt;Account&gt; targetOptional = accountDao.findById(targetId);</span><br><span class="line">            <span class="keyword">if</span> (!resourceOptional.isPresent() || !targetOptional.isPresent())&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"用户不存在"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Account resourceAccount = resourceOptional.get();</span><br><span class="line">            Account targetAccount = targetOptional.get();</span><br><span class="line">            <span class="comment">//3.修改余额</span></span><br><span class="line">            <span class="keyword">float</span> resourceMoney = resourceAccount.getMoney() - money;</span><br><span class="line">            <span class="keyword">if</span> (resourceMoney&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"转账失败:余额不足"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            resourceAccount.setMoney(resourceMoney);</span><br><span class="line">            targetAccount.setMoney(targetAccount.getMoney() + money);</span><br><span class="line">            <span class="comment">//4.执行更新</span></span><br><span class="line">            accountDao.update(resourceAccount);</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">            accountDao.update(targetAccount);</span><br><span class="line">            <span class="comment">//5.提交更新</span></span><br><span class="line">            connection.commit();</span><br><span class="line">            <span class="comment">//6.将连接放回资源池</span></span><br><span class="line">            connection.close();</span><br><span class="line">            <span class="comment">//7.解除线程与Connection的绑定关系</span></span><br><span class="line">            connectionUtils.removeConnection();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">//8.发生异常回滚</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.rollback();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>第三步：</strong>在<code>Dao</code>层获取当前线程的<code>Connection</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Accompany</span></span><br><span class="line"><span class="comment"> * 账户Dao层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> QueryRunner runner;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRunner</span><span class="params">(QueryRunner runner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.runner = runner;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ConnectionUtils connectionUtils;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnectionUtils</span><span class="params">(ConnectionUtils connectionUtils)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connectionUtils = connectionUtils;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String sql = <span class="string">"insert into account values(?,?)"</span>;</span><br><span class="line">            runner.update(connectionUtils.getThreadLocalConnection(),sql,account.getId(),account.getMoney());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;Account&gt; <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String sql = <span class="string">"select * from account where id = ?"</span>;</span><br><span class="line">            account = runner.query(connectionUtils.getThreadLocalConnection(),sql,<span class="keyword">new</span> BeanHandler&lt;&gt;(Account.class),id);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String sql = <span class="string">"update account set money = ? where id = ?"</span>;</span><br><span class="line">            runner.update(connectionUtils.getThreadLocalConnection(),sql,account.getMoney(),account.getId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-1-2-第二次改良"><a href="#1-1-2-第二次改良" class="headerlink" title="1.1.2.第二次改良"></a>1.1.2.第二次改良</h4><ul><li><p>从第一次改良中可以发现，在service层中出现了<code>try-catch</code>已经其嵌套，同时也导致了代码量变长了，可以适当的封装，让其客观性更好。</p></li><li><p>流程图：</p><p><img src="/2019/07/14/重走Spring框架(AOP部分)/10.jpg" alt></p></li><li><p><strong>第一步，新增事务控制器：</strong>由于事务操作在需要的业务操作中都会存在，可以适当进行抽取，以达到代码重用性高，客观性强的目的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Accompany</span></span><br><span class="line"><span class="comment"> * 事务管理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConnectionUtils connectionUtils;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnectionUtils</span><span class="params">(ConnectionUtils connectionUtils)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connectionUtils = connectionUtils;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionUtils.getThreadLocalConnection().setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionUtils.getThreadLocalConnection().commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回滚</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionUtils.getThreadLocalConnection().rollback();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将Connection放回连接池</span></span><br><span class="line">            connectionUtils.getThreadLocalConnection().close();</span><br><span class="line">            <span class="comment">//将Connection与线程解绑</span></span><br><span class="line">            connectionUtils.removeConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>第二步，修改<code>Service</code>：</strong>因为新增了事务管理器<code>TransactionManager</code>所以就不需要在<code>Service</code>中引用<code>Connection</code>来控制事务，而是将事务管理权交给了事务管理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Accompany</span></span><br><span class="line"><span class="comment"> * 账户业务层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(AccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> TransactionManager transactionManager;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransactionManager</span><span class="params">(TransactionManager transactionManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.transactionManager = transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String resourceId, String targetId, <span class="keyword">float</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.开启事务管理</span></span><br><span class="line">            transactionManager.beginTransaction();</span><br><span class="line">            <span class="comment">//3.获取账户信息</span></span><br><span class="line">            Optional&lt;Account&gt; resourceOptional = accountDao.findById(resourceId);</span><br><span class="line">            Optional&lt;Account&gt; targetOptional = accountDao.findById(targetId);</span><br><span class="line">            <span class="keyword">if</span> (!resourceOptional.isPresent() || !targetOptional.isPresent()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"用户不存在"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Account resourceAccount = resourceOptional.get();</span><br><span class="line">            Account targetAccount = targetOptional.get();</span><br><span class="line">            <span class="comment">//3.修改余额</span></span><br><span class="line">            <span class="keyword">float</span> resourceMoney = resourceAccount.getMoney() - money;</span><br><span class="line">            <span class="keyword">if</span> (resourceMoney &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"转账失败:余额不足"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            resourceAccount.setMoney(resourceMoney);</span><br><span class="line">            targetAccount.setMoney(targetAccount.getMoney() + money);</span><br><span class="line">            <span class="comment">//4.执行更新</span></span><br><span class="line">            accountDao.update(resourceAccount);</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            accountDao.update(targetAccount);</span><br><span class="line">            <span class="comment">//5.提交更新</span></span><br><span class="line">            transactionManager.commit();</span><br><span class="line">            <span class="comment">//6.释放资源</span></span><br><span class="line">            transactionManager.release();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            transactionManager.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-1-3-第三次改良"><a href="#1-1-3-第三次改良" class="headerlink" title="1.1.3.第三次改良"></a>1.1.3.第三次改良</h4><ul><li>从第二次改良中可以发现，针对一个业务如果需要进行事务控制增加了不少的代码，但是如果是针对很多个业务的话就会出现代码重复，并且也不能让程序员更加专注的处理业务需求（因为需要关注事务管理）。所以可以加入动态代理，去增强原本的<code>Servicec</code>层。</li><li>什么是动态代理？<ul><li>动态代理是在，</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重走Spring框架（AOP部分）&quot;&gt;&lt;a href=&quot;#重走Spring框架（AOP部分）&quot; class=&quot;headerlink&quot; title=&quot;重走Spring框架（AOP部分）&quot;&gt;&lt;/a&gt;重走Spring框架（AOP部分）&lt;/h1&gt;&lt;h2 id=&quot;1-分析银
      
    
    </summary>
    
      <category term="后端框架" scheme="https://aaccompany.github.io/categories/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="spring" scheme="https://aaccompany.github.io/tags/spring/"/>
    
      <category term="重走系列" scheme="https://aaccompany.github.io/tags/%E9%87%8D%E8%B5%B0%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>重走spring框架 IOC部分</title>
    <link href="https://aaccompany.github.io/2019/07/14/%E9%87%8D%E8%B5%B0spring%E6%A1%86%E6%9E%B6(IOC%E9%83%A8%E5%88%86)/"/>
    <id>https://aaccompany.github.io/2019/07/14/重走spring框架(IOC部分)/</id>
    <published>2019-07-14T11:40:50.000Z</published>
    <updated>2019-09-20T16:15:22.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h1><p>学习过程中的问题：</p><ul><li>为什么在使用JDBC使用的是<code>Class.forName(&quot;DriverName&quot;)</code> 而不是 <code>DriverManager.register(new Driver)</code>？</li><li>工厂模式的好处是什么？</li><li>工厂模式下创建的Bean对象应该为多例还是单例？</li><li>什么时候用多例什么时候用单例？</li><li>Spring是如何做到立即加载的？</li><li>Spring核心容器下两个顶级接口的区别是什么？（<code>BeanFactory/ApplicationContext</code>）</li><li>为什么使用XML配置Bean需要给属性设置set/get方法才能注入，而使用注解配置Bean不需要设置set/get方法就能注入？</li><li>配置注解类就取代掉配置文件，那么配置文件还有存在的意义吗？</li></ul><h2 id="1-Spring到底是个什么妖魔鬼怪？"><a href="#1-Spring到底是个什么妖魔鬼怪？" class="headerlink" title="1.Spring到底是个什么妖魔鬼怪？"></a>1.Spring到底是个什么妖魔鬼怪？</h2><h3 id="1-1-Spring的自我介绍？"><a href="#1-1-Spring的自我介绍？" class="headerlink" title="1.1.Spring的自我介绍？"></a>1.1.Spring的自我介绍？</h3><p>1）Spring是分层的 Java SE/EE应用 <strong>full-stack</strong> （提供了全栈式的解决方案）轻量级开源框架</p><p>2）以 <strong>IoC</strong>（Inverse Of Control： 反转控制）和 <strong>AOP</strong>（Aspect Oriented Programming：面向切面编程）为<strong>内核</strong></p><p>3）提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多 著名的第三方框架和类库</p><p>4）Java后端开发的标准 </p><h3 id="1-2-Spring的发展历程"><a href="#1-2-Spring的发展历程" class="headerlink" title="1.2. Spring的发展历程"></a>1.2. Spring的发展历程</h3><p>1997 年 IBM提出了EJB 的思想   </p><p>1998 年，SUN制定开发标准规范 EJB1.0   </p><p>1999 年，EJB1.1 发布   </p><p>2001 年，EJB2.0 发布   </p><p>2003 年，EJB2.1 发布   </p><p>2006 年，EJB3.0 发布   </p><p><strong>Rod Johnson（spring之父）</strong>   </p><p> Expert One-to-One J2EE Design and Development(2002)    阐述了 J2EE 使用EJB 开发设计的优点及解决方案   </p><p> Expert One-to-One J2EE Development without EJB(2004)    阐述了 J2EE 开发不使用 EJB的解决方式（Spring 雏形）      </p><p>2017 年 9 月份发布了 spring 的最新版本 spring 5.0 通用版（GA） </p><h3 id="1-3-为什么要使用Spring？"><a href="#1-3-为什么要使用Spring？" class="headerlink" title="1.3.为什么要使用Spring？"></a>1.3.为什么要使用Spring？</h3><p>1）方便解耦，简化开发</p><p>通过Spring提供的IOC（控制反转）容器，让Bean对象放入到Spring容器中，这样对象之间的依赖关系就可以由Spring去处理，避免硬编码造成程序耦合。也不需要注重Bean是设计成单例还是设计成多例的代码。可以花更多时间去注重上层代码</p><p>2）AOP支持(面向切面)</p><p>通过Spring提供的AOP支持，可以做到传统的OOP很难完成事情。</p><p>3）声明式事务的支持</p><p>可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理， 提高开发效率和质量。 </p><p>4）方便程序的测试 </p><p> 可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可 做的事情</p><p>5）方便集合各种优秀的框架</p><p>可以很快的整合Mybatis、Spring MVC 、Struts等框架。</p><p>6）降低了Java EE的API使用难度</p><p>在Spring中，对Java EE（如 JDBC、JavaMail、远程调用等）进行了一层封装，能够通过更少的代码去使用这些技术。</p><p>7）代码编写的榜样</p><p>Spring采用的代码编写的技巧，设计都十分巧妙，结构清晰，注释完整。是十分值得学习的榜样。</p><h3 id="1-4-Spring的体系结构"><a href="#1-4-Spring的体系结构" class="headerlink" title="1.4.Spring的体系结构"></a>1.4.Spring的体系结构</h3><p>在Spring的体系结构中也可以看出Spring是个<strong>full-stack</strong>型框架，提供了各层的解决方案。</p><p>其中重要的是Core Container中的部分，这是使用Spring必备部分，不可缺失。</p><p><img src="/2019/07/14/重走spring框架(IOC部分)/spring-overview.png" alt></p><h2 id="2-如何做到程序解耦？（IOC部分）"><a href="#2-如何做到程序解耦？（IOC部分）" class="headerlink" title="2.如何做到程序解耦？（IOC部分）"></a>2.如何做到程序解耦？（IOC部分）</h2><h3 id="2-1-程序的耦合和解耦"><a href="#2-1-程序的耦合和解耦" class="headerlink" title="2.1.程序的耦合和解耦"></a>2.1.程序的耦合和解耦</h3><p>在说明IOC先知道什么是程序的耦合和耦合</p><h4 id="2-1-1-程序的耦合？"><a href="#2-1-1-程序的耦合？" class="headerlink" title="2.1.1.程序的耦合？"></a>2.1.1.程序的耦合？</h4><p>在软件工程中，耦合指的就是就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。划分模块的一个 准则就是高内聚低耦合。</p><p> 它有如下分类： </p><p>模块耦合分为<strong>数据耦合、特征耦合、控制耦合、公共环境耦合、内容耦合</strong>。耦合程度由低到高。</p><p><strong>1）数据耦合：</strong></p><p>两个模块彼此间通过参数交换信息，而且交换的信息仅仅是数据（指的是单一的原子的数据片段），那么这种耦合称为数据耦合。<strong>数据耦合是低耦合。系统中至少必须存在这种耦合。这是不可避免的。</strong></p><p><strong>2）特征耦合</strong></p><p>当把整个<strong>数据结构</strong>作为参数、局部变量或者返回值，而被调用的模块只需要使用其中一部分数据元素时，就出现了特征耦合。（意思为传递了一个数据结构，但是调用方没有将该数据结构中全部数据使用便为特征耦合）</p><p>比如判断一个人是否成年，只需要传递该人的出生日期即可，不必要把人传进去。</p><p>因此这种耦合，通常是可以通过修改参数、局部变量或者返回值，只使用必要的数据元素来避免。</p><p><strong>3）控制耦合</strong></p><p>传递的信息中有控制信息(尽管有时这种控制信息以数据的形式出现)，则这种耦合称为控制耦合。控制耦合是中等程度的耦合。</p><p>比如，传递的参数中包含一个枚举类型的参数，在方法的具体逻辑中判断该参数实现不同的功能。<br>那么，完全可以通过将一个方法修改为多个方法改进这种耦合。</p><p><strong>4）公共环境耦合</strong></p><p>当两个或多个模块通过一个公共数据环境相互作用时，它们之间的耦合称为公共环境耦合。<br>公共环境可以是全程变量、共享的通信区、内存的公共覆盖区、任何存储介质上的文件、物理设备等。<br>公共环境耦合的复杂程度随耦合的模块个数而变化，当耦合的模块个数增加时复杂程度显著增加。</p><p>只有两个模块有公共环境，耦合有下面两种可能。</p><ol><li>一个模块往公共环境送数据，另一个模块从公共环境取数据。这是数据耦合的一种形式，是比较松散的耦合。</li><li>两个模块都既往公共环境送数据又从里面取数据，这种耦合比较紧密，介于数据耦合和控制耦合之间。</li></ol><p>限制范围，比如如果是依赖的是汇率，提供一个统一获汇率配置的方法，限制耦合范围。</p><p><strong>5）内容耦合</strong></p><p>最高程度的耦合是内容耦合。如果出现下列情况之一，两个模块间就发生了内容耦合。</p><ol><li>一个模块访问另一个模块的内部数据。</li><li>一个模块不通过正常入口而转到另一个模块的内部。</li><li>两个模块有一部分程序代码重叠(只可能出现在汇编程序中)。</li><li>一个模块有多个入口(这意味着一个模块有几种功能)。</li></ol><p>应该坚决避免使用内容耦合，重构吧。</p><h4 id="2-1-4-解决jdbc代码耦合"><a href="#2-1-4-解决jdbc代码耦合" class="headerlink" title="2.1.4.解决jdbc代码耦合"></a>2.1.4.解决jdbc代码耦合</h4><p><strong>思考1：</strong>为什么在使用JDBC使用的是<code>Class.forName(&quot;DriverName&quot;)</code> 而不是 <code>DriverManager.register(new Driver)</code>？</p><ul><li><p><strong>第一：</strong>使用<code>DriverManager.register</code> 会出现强依赖的现象</p><p>第一步出现了依赖现象，如果在Maven中没有导入jdbc的包则会在编译期出现错误。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.注册驱动 在这一步因为需要new 一个Driver对象，出现了强依赖</span></span><br><span class="line">      DriverManager.registerDriver(<span class="keyword">new</span> com.mysql.jdbc.Driver());</span><br><span class="line">      <span class="comment">//2.创建连接</span></span><br><span class="line">      Connection con = DriverManager.getConnection(<span class="string">"url"</span>,<span class="string">"username"</span>,<span class="string">"password"</span>);</span><br><span class="line">      <span class="comment">//3.使用连接，创建sql预处理对象</span></span><br><span class="line">      String sql = <span class="string">"select * from department"</span>;</span><br><span class="line">      PreparedStatement ps = con.prepareStatement(sql);</span><br><span class="line">      <span class="comment">//4.执行查询对象</span></span><br><span class="line">      ResultSet resultSet = ps.executeQuery();</span><br><span class="line">      <span class="comment">//5.遍历数据</span></span><br><span class="line">      <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">          System.out.print(resultSet.getString(<span class="string">"id"</span>));</span><br><span class="line">          System.out.print(resultSet.getString(<span class="string">"name"</span>));</span><br><span class="line">          System.out.println();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//6.释放资源</span></span><br><span class="line">      resultSet.close();</span><br><span class="line">      ps.close();</span><br><span class="line">      con.close();</span><br></pre></td></tr></table></figure><ul><li><p><strong>第二：</strong>如果使用的是<code>DriverManager.register</code>的方式去注册，那么驱动会被注册两次</p><p>第一次：从翻看源码中可以发现一旦  <code>com.mysql.Driver</code>  被加载，则会调用静态构造函数从而执行<code>java.sql.DriverManager.registerDriver(new Driver());</code>完成驱动注册</p><p>第二次：为自己在代码中手动注册了注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该mysql连接包的版本为5.1.46  在6.0+的版本中，就不使用com.mysql.Driver的类了</span></span><br><span class="line"><span class="comment">//而是使用com.mysql.cj.jdbc.Driver去完成注册操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Register ourselves with the DriverManager</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct a new driver and register it with DriverManager</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     *             if a database error occurs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>Class.forName(String driverName)</code>的好处</p><p>使用了这种方式传递的是字符串，所以并不会在编译期出现错误。从而减少了耦合度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.注册驱动 在这一步因为需要new 一个Driver对象，出现了强依赖</span></span><br><span class="line">      <span class="comment">//DriverManager.registerDriver(new com.mysql.jdbc.Driver());</span></span><br><span class="line">      <span class="comment">//在5.0的驱动版本中使用的是</span></span><br><span class="line">      <span class="comment">//Class.forName("com.mysql.jdbc.Driver()");</span></span><br><span class="line">      <span class="comment">// 在6.0+的驱动版本中使用的是</span></span><br><span class="line">      Class.forName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">      <span class="comment">//2.创建连接</span></span><br><span class="line">      Connection con = DriverManager.getConnection(<span class="string">"jdbc:mysql://120.76.56.183:33306/qingzhai_base"</span>,<span class="string">"root"</span>,<span class="string">"root"</span>);</span><br><span class="line">      <span class="comment">//3.使用连接，创建sql预处理对象</span></span><br><span class="line">      String sql = <span class="string">"select * from department"</span>;</span><br><span class="line">      PreparedStatement ps = con.prepareStatement(sql);</span><br><span class="line">      <span class="comment">//4.执行查询对象</span></span><br><span class="line">      ResultSet resultSet = ps.executeQuery();</span><br><span class="line">      <span class="comment">//5.遍历数据</span></span><br><span class="line">      <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">          System.out.print(resultSet.getString(<span class="string">"id"</span>));</span><br><span class="line">          System.out.print(resultSet.getString(<span class="string">"name"</span>));</span><br><span class="line">          System.out.println();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//6.释放资源</span></span><br><span class="line">      resultSet.close();</span><br><span class="line">      ps.close();</span><br><span class="line">      con.close();</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-1-3耦合总结"><a href="#2-1-3耦合总结" class="headerlink" title="2.1.3耦合总结"></a>2.1.3耦合总结</h4><p>总之，耦合是影响软件复杂程度的一个重要因素。<br>应该采取下述设计原则：<br><strong>尽量使用数据耦合，少用控制耦合和特征耦合，限制公共环境耦合的范围，完全不用内容耦合。</strong></p><p>ps: 编译器不依赖，运行期才依赖</p><h3 id="2-2-如何更加通用的方式解决程序耦合问题？"><a href="#2-2-如何更加通用的方式解决程序耦合问题？" class="headerlink" title="2.2.如何更加通用的方式解决程序耦合问题？"></a>2.2.如何更加通用的方式解决程序耦合问题？</h3><p>通过在2.1.4.中发现了可以使用字符串的方式减少了 new 关键字的出现，便减少程序的耦合度。由此可以进一步挖掘，是否在之后的new  对象的过程省略，而是使用字符串去完成对象的创建，这样便进一步的解决了系统的耦合度。</p><p>这时候就可以想到使用Java的反射，创建一个配置文件，在配置文件中，设置类的关键字映射到对应类的全路径上，通过反射完成对象的创建。</p><h4 id="2-2-1-使用工厂模式解耦"><a href="#2-2-1-使用工厂模式解耦" class="headerlink" title="2.2.1.使用工厂模式解耦"></a>2.2.1.使用工厂模式解耦</h4><h5 id="2-2-1-1-什么是工厂模式"><a href="#2-2-1-1-什么是工厂模式" class="headerlink" title="2.2.1.1.什么是工厂模式"></a>2.2.1.1.什么是工厂模式</h5><p><strong>个人理解：</strong>将创建的类的过程交由工厂去解决，工厂负责封装具体创建类的过程，只对外提供对应的方法，客户端只需要调用对应的接口便可以获取到对应的类。</p><p><strong>好处：</strong>通过工厂模式可以进一步解除系统耦合。</p><p><strong>图解：</strong></p><p>在未使用工厂模式下客户端直接获取资源(也就是new 对象)，这就造成了高耦合度，不易于扩展</p><p><img src="/2019/07/14/重走spring框架(IOC部分)/%E9%87%8D%E8%B5%B0spring%E6%A1%86%E6%9E%B6%5C1.jpg" alt></p><p>当使用了工厂模式情况下，客户端需要通过工厂去获取对象，而具体的实现过程被工厂隐藏，工厂读取配置文件，通过反射实例化对象，系统便具有了高扩展性。</p><p><img src="/2019/07/14/重走spring框架(IOC部分)/%E9%87%8D%E8%B5%B0spring%E6%A1%86%E6%9E%B6%5C2.jpg" alt></p><h5 id="2-2-1-2-简单使用工厂模式创建类"><a href="#2-2-1-2-简单使用工厂模式创建类" class="headerlink" title="2.2.1.2.简单使用工厂模式创建类"></a>2.2.1.2.简单使用工厂模式创建类</h5><p>简单使用：通过<code>BeanName</code>创建对象，减少耦合程度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : Accompany</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> :  2019/09/10</span></span><br><span class="line"><span class="comment"> * 实现类对象的创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties properties;</span><br><span class="line">    <span class="comment">//加载配置文件信息</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过类加载器读取配置文件</span></span><br><span class="line">            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(<span class="string">"application.properties"</span>);</span><br><span class="line">            properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            properties.load(in);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Object <span class="title">getBean</span><span class="params">(String beanName)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取到类路径</span></span><br><span class="line">        String beanPath = properties.getProperty(beanName);</span><br><span class="line">        <span class="comment">//创建类对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Class.forName(beanPath).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-1-3-完善工厂模式"><a href="#2-2-1-3-完善工厂模式" class="headerlink" title="2.2.1.3.完善工厂模式"></a>2.2.1.3.完善工厂模式</h5><p><strong>问题1：</strong>单例和多例的区别是什么？好处是什么？</p><p><strong>区别：</strong></p><ul><li>单例：多次通过工厂模式创建同一个对象只会在内存中存在一个实例。<ul><li>使用场景：在类中有共享数据或没有成员变量（例如 dao层 service层 ）</li><li>好处：因为只创建了一个实例，节省内存和JVM垃圾回收造成的性能浪费、可以存放共享数据（但是会存在线程安全问题）、效率会比多例模式快</li><li>坏处：因为是单例的所以会出现线程安全问题</li></ul></li><li>多例：每次通过工厂模式去创建同一个对象都会在内存中创建一个新的实例<ul><li>使用场景：当一个类只需要临时使用、每次都需要读最新的配置文件的时候可以使用。</li><li>好处：防止并发错误，如果在多线程的情况下，使用的是单例，假如修改了状态值，那么整个请求就会发生异常。</li><li>坏处：因为是不断的创建对象，就会占用大量的内存，同时也会导致<code>GC</code>的活动频繁导致性能下降。</li></ul></li></ul><p><strong>问题2：</strong>创建Bean应该为多例还是单例？</p><ul><li>具体问题需要具体分析<ul><li>像dao层和service层，没有了成员变量，在线程安全问题上就降低很多，可以使用单例模式</li><li>像controller层，在struts2中使用的是多例，但是在spring mvc中使用的是单例。</li></ul></li><li>当对象含有可改变状态时（更精确的说，在实际的应用中该状态会发生改变），使用多例，否则单例</li></ul><p><strong>修改代码：</strong>同时这也是spring的设计思想，当bean为单例的时候，会将对象在容器初始化的时候创建并且存进Map集合中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; objectMap;</span><br><span class="line">    <span class="comment">//加载配置文件信息</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过类加载器读取配置文件</span></span><br><span class="line">            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(<span class="string">"application.properties"</span>);</span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            objectMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">            properties.load(in);</span><br><span class="line">            <span class="comment">//将配置文件中全部的对象映射地址创建成对象封装到map集合中</span></span><br><span class="line">            Enumeration&lt;Object&gt; keys = properties.keys();</span><br><span class="line">            <span class="keyword">while</span> (keys.hasMoreElements())&#123;</span><br><span class="line">                <span class="comment">//读取某个对象路径地址</span></span><br><span class="line">                String objKey = (String) keys.nextElement();</span><br><span class="line">                String objPath = properties.getProperty(objKey);</span><br><span class="line">                Object object = Class.forName(objPath).newInstance();</span><br><span class="line">                objectMap.put(objKey,object);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Object <span class="title">getBean</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        未修改前</span></span><br><span class="line"><span class="comment">        //获取到类路径</span></span><br><span class="line"><span class="comment">        String beanPath = properties.getProperty(beanName);</span></span><br><span class="line"><span class="comment">        //创建类对象</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            return Class.forName(beanPath).newInstance();</span></span><br><span class="line"><span class="comment">        &#125; catch (InstantiationException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125; catch (IllegalAccessException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125; catch (ClassNotFoundException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return null;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (!objectMap.containsKey(beanName))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">"类不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objectMap.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-IOC是个啥玩意？"><a href="#2-3-IOC是个啥玩意？" class="headerlink" title="2.3. IOC是个啥玩意？"></a>2.3. IOC是个啥玩意？</h3><p>IOC ：inversion of control （控制反转），这是一种思想理念，并不是只有Spring独有的，在Spring中使用DI去实现了这种思想。</p><p>在Spring中的解释为将Bean的创建权、管理权转交由Spring去管理，这样程序员就不必过多的关注Bean的生命周期的问题了，可以更加关注于业务处理。</p><h4 id="2-3-1-Spring中IOC"><a href="#2-3-1-Spring中IOC" class="headerlink" title="2.3.1. Spring中IOC"></a>2.3.1. Spring中IOC</h4><ul><li><p>1）在工程的POM文件中导入Spring-Context的基本坐标,便具备了Spring IOC功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当导入文件会发现会多了很多依赖，对应1.4中Spring的体系结构，可以看出点端倪</p><ul><li><p>自动加入了<code>spring-apo</code>包，说明了Spring的基础功能需要依赖<code>spring-aop</code></p></li><li><p>spring中对apache.logging日志处理系统进行封装（<code>spring-jcl</code>包）这就需要注意，如果导入其他框架，该框架也有日志系统的话，那么就会出现冲突问题，这时候就需要解决了。</p></li></ul></li></ul><p><img src="/2019/07/14/重走spring框架(IOC部分)/%E9%87%8D%E8%B5%B0spring%E6%A1%86%E6%9E%B6%5C3.jpg" alt></p><ul><li><p>2）在resources目录下创建配置文件（<code>*.xml</code>）文件，该文件的作用为，阐述类的信息和类之间依赖关系</p><ul><li><p>配置文件信息</p><p>根据前面的如何自定义手动解耦的思想，那么可以知道，在配置文件中最起码需要具备 </p><p>一个标识符、标识符指向的类的全路径</p><p>所以在Spring的配置文件中便会出现Beans的大标签下有Bean的小标签代表着一个个的bean对象。</p><p>id便是标识符、class便是指向类的全路径</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.service.impl.studentServiceImpl"</span> <span class="attr">id</span>=<span class="string">"studentService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>3）在简单使用</p><ul><li><p>在ui中读取配置文件，并且将存储在spring IOC容器的对象取出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//读取配置文件</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"application.xml"</span>);</span><br><span class="line">        <span class="comment">//将对象从IOC容器中取出</span></span><br><span class="line">        studentService studentService = (studentService) context.getBean(<span class="string">"studentService"</span>);</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        studentService.findAll();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-3-2-Spring-的-BeanFactory-是什么？"><a href="#2-3-2-Spring-的-BeanFactory-是什么？" class="headerlink" title="2.3.2. Spring 的 BeanFactory 是什么？"></a>2.3.2. Spring 的 BeanFactory 是什么？</h4><p>BeanFactory是spring的工厂模式的顶级接口。同时可以从图中看出该接口具体很多实现类，到那时具体使用的只有三个。</p><ul><li><code>AnnotationConfigApplicationContext</code>：是有关于注解配置</li><li><code>ClassPathXMLApplicationContext</code>：读取src目录下的配置文件，也就是存放在resources下的配置文件</li><li><code>FileSystemXmlApplicationContext</code>：读取系统中绝对路径下XML文件文件（不推荐使用）</li></ul><p><img src="/2019/07/14/重走spring框架(IOC部分)/%E9%87%8D%E8%B5%B0spring%E6%A1%86%E6%9E%B6%5C4.jpg" alt></p><h4 id="2-3-3-BeanFacotry与ApplicationContext的区别"><a href="#2-3-3-BeanFacotry与ApplicationContext的区别" class="headerlink" title="2.3.3. BeanFacotry与ApplicationContext的区别"></a>2.3.3. BeanFacotry与ApplicationContext的区别</h4><p>BeanFacotry是一个顶级接口，而ApplicationContext是继承了BeanFactory下的HierarchicalBeanFactory也就是说，间接的继承了BeanFactory。</p><p><code>BeanFacotry</code>与<code>ApplicaitonContext</code>区别</p><ul><li><p>他们在创建Bean对象的时间点不同，</p><p><code>BeanFacotry</code>（实现类<code>XMLBeanFactory</code>已经弃用的对象）采用的策略是懒加载策略：</p><ul><li>懒加载：在Bean对象被使用的时候才被加载，容器初始化的时候不会被加载</li></ul><p><code>ApplicaitonContext</code>采用的策略是立即加载</p><ul><li>立即加载：在容器初始化的时候就被加载放进了Map集合</li></ul></li></ul><p>思考：什么时候使用懒加载什么时候使用立即加载呢？</p><p>单例模式使用立即加载</p><p>多例模式使用懒加载（因为多例模式最好是在需要的时候在去创建是最节省空间的）</p><h4 id="2-3-4-IOC中Bean标签和管理对象细节"><a href="#2-3-4-IOC中Bean标签和管理对象细节" class="headerlink" title="2.3.4. IOC中Bean标签和管理对象细节"></a>2.3.4. IOC中Bean标签和管理对象细节</h4><h5 id="2-3-4-1-Bean标签"><a href="#2-3-4-1-Bean标签" class="headerlink" title="2.3.4.1. Bean标签"></a>2.3.4.1. Bean标签</h5><p>bean标签存在的位置：在spring的配置文件中出现</p><p>作用：将对象的管理权交由spring管理</p><p>属性：</p><ul><li>id：指向全路径类的标识符（通常写成类名/接口名）</li><li>class：类的全路径信息</li><li>scope：指定类对象的作用范围<ul><li>singleton：默认值 单例</li><li><code>prototyoe</code>：多例</li><li><code>request</code>：WEB项目中，将该对象创建放进request域中</li><li><code>session</code>：WEB项目中，将该对象创建放进session域中</li><li><code>global session</code>：WEB项目中，应用在分布式环境下，将对象创建放进全局session中，如果不是分布式环境下，那么该配置相当于session</li></ul></li></ul><h5 id="2-3-4-2实例化Bean的三种方式"><a href="#2-3-4-2实例化Bean的三种方式" class="headerlink" title="2.3.4.2实例化Bean的三种方式"></a>2.3.4.2实例化Bean的三种方式</h5><ul><li><p><strong>第一种：通过构造函数去实例化Bean</strong></p><ul><li>在无参构造函数下实例化</li><li>参数说明：<ul><li><code>bean</code>：声明一个交由Spring IOC管理的Bean对象</li><li><code>id</code>：指向全路径类的标识符（通常写成类名/接口名）</li><li><code>class</code>：类的全路径信息</li></ul></li></ul><p>这种方式创建的对象是针对无参构造函数的，当存在有参构造函数的时候会出现错误</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentService"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.service.impl.studentServiceImpl"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在有参构造函数下实例化</li><li>参数说明<ul><li><code>constructor-arg</code>：阐述构造函数参数的信息<ul><li><code>name</code>：表示参数的名称</li><li><code>value</code>：插入基本数据类型和String类型</li><li><code>ref</code>：插入对象类型数据（该对象类型数据必须交由Spring管理才能注入）</li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"Student"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.bean.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"15"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"date"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"date"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>第二种：通过静态工厂模式实例化</strong></p><ul><li><p>该模式是当存在一个工厂，该工厂具有一个静态方法可以获取到一个对象，那么可以通过该方法获取到返回的对象直接放入spring容器中，无须将工厂注入也可以完成。<strong>（这种适用于框架整合，同时该方法必须为静态方法）</strong></p><p>工厂对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFacotry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">createStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        student.setName(<span class="string">"梨花"</span>);</span><br><span class="line">        student.setAge(<span class="number">11</span>);</span><br><span class="line">        student.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件：</p><ul><li>需要注意 class 写的是工厂类的全路径，factory-method 写的是从工厂获取到类的方法</li><li>不需要提供需要实例化的对象的全路径</li><li>如果方法中需要传值，那么就需要在实例化的对象中加入构造传值</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"StaticStudent"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.Factory.StaticFacotry"</span> <span class="attr">factory-method</span>=<span class="string">"createStudent"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>第三种：通过非静态工厂实例化</strong></p><ul><li><p>该模式是当存在一个工厂，该工厂具有一个非方法可以获取到一个对象，需要将工厂注入到Spring容器，再通过具体需要实例化的类去调用注入的工厂的方法完成实例化<strong>（这种适用于框架整合，这个工厂方法为非静态方法）</strong></p><p>工厂对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">createStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        student.setName(<span class="string">"张三丰"</span>);</span><br><span class="line">        student.setAge(<span class="number">100</span>);</span><br><span class="line">        student.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><ul><li>需要注意：在使用非静态工厂方法的时候<ul><li>1.先将工厂对象交由spring管理</li><li>2.在需要实例化的对象中加入 <code>factory-bean</code>：指向spring中工厂类</li><li>3.<code>factory-method</code>：为工厂类中提供对象的方法</li><li>4.在需要实例化的对象中不需要添加实例化对象的全路径</li><li>5.如果方法中需要传值，那么就需要在实例化的对象中加入构造传值</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"factory"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.Factory.Factory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">factory-bean</span>=<span class="string">"factory"</span> <span class="attr">factory-method</span>=<span class="string">"createStudent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"string"</span> <span class="attr">value</span>=<span class="string">"yyx"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2-3-4-3-Bean对象的生命周期"><a href="#2-3-4-3-Bean对象的生命周期" class="headerlink" title="2.3.4.3. Bean对象的生命周期"></a>2.3.4.3. Bean对象的生命周期</h5><p>不同的Bean对象作用范围，生命周期不同。</p><p>生命周期方法：在bean标签中</p><p><code>init-method</code>：Bean被初始化时调用</p><p><code>destory-method</code>：Bean被销毁时调用</p><ul><li><strong>scope=”singleton”：单例对象</strong> <ul><li>在整个应用中只会存在一个对象</li><li>生命周期<ul><li>对象初始化：当Spring 容器加载的时候，对象就开始初始化（前提是该对象为立即加载）</li><li>对象存活：只要容器在，那么对象就会存活</li><li>对象死亡：当容器死亡那么对象就死亡</li></ul></li></ul></li><li><strong>scope=”prototype”：多例对象</strong><ul><li>每次get都会创建新的对象</li><li>生命周期<ul><li>对象初始化：当调用了<code>getBean</code>的方法的时候开始完成对象的初始化</li><li>对象存活：只要对象任然在使用中，那么对象就一直存活</li><li>对象死亡：当对象没有被使用，等待<code>GC</code>回收，然后释放所占用的内存（需要注意，由于Spring不知道对象什么时候死亡，所以destroy-method 的方法是无法执行的）</li></ul></li></ul></li></ul><h4 id="2-3-5-DI（依赖注入）是个什么玩意？"><a href="#2-3-5-DI（依赖注入）是个什么玩意？" class="headerlink" title="2.3.5. DI（依赖注入）是个什么玩意？"></a>2.3.5. DI（依赖注入）是个什么玩意？</h4><h5 id="2-3-5-1-DI自述"><a href="#2-3-5-1-DI自述" class="headerlink" title="2.3.5.1. DI自述"></a>2.3.5.1. DI自述</h5><p>DI ：Dependency injection  也称为依赖注入，它是Spring框架IOC的具体实现</p><p>DI在Spring中的作用是，当容器运行时，能够将对象依赖的数据注入到对象中，比如通过构造方法注入属性，SET方法注入属性。</p><h5 id="2-3-5-2-为什么叫依赖注入呢？"><a href="#2-3-5-2-为什么叫依赖注入呢？" class="headerlink" title="2.3.5.2.为什么叫依赖注入呢？"></a>2.3.5.2.为什么叫依赖注入呢？</h5><p>例子：就像是 service层 需要依赖dao层  ，在交给Spring容器管理的时候， 就需要在service层中说明依赖了那个dao层接口，这样service层就可以使用dao层方法了。</p><p><strong>好处：</strong>通过将对象注入到对象，维护了类之间依赖关系。这种方式相比于传统模式下更加好，因为减少了硬编码，不需要在代码中写出具体的实现类是什么，而是通过在Bean工厂中获取到对应的实现类，这种方式减少耦合度，增加了系统的可扩展性。</p><p><strong>传统模式下的实现方式</strong></p><p><img src="/2019/07/14/重走spring框架(IOC部分)/5.jpg" alt></p><p><strong>DI方式下的实现方式</strong></p><p><img src="/2019/07/14/重走spring框架(IOC部分)/6.jpg" alt></p><h5 id="2-3-5-3-构造函数注入"><a href="#2-3-5-3-构造函数注入" class="headerlink" title="2.3.5.3. 构造函数注入"></a>2.3.5.3. 构造函数注入</h5><p>解释：在实例化Bean对象的时候，容器读取配置文件，通过构造函数去实例化对象。</p><p>好处：强制要求Bean对象在初始化一定要传递什么值。</p><p>坏处：不够灵活，如果有些值不必要传递那么就需要强硬的传值。</p><ul><li>参数说明<ul><li><code>constructor-arg</code>：阐述构造函数参数的信息<ul><li><code>name</code>：表示参数的名称</li><li><code>value</code>：插入基本数据类型和String类型</li><li><code>ref</code>：插入对象类型数据（该对象类型数据必须交由Spring管理才能注入）</li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"Student"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.bean.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"15"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"date"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"date"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-3-5-4-Set-方法注入"><a href="#2-3-5-4-Set-方法注入" class="headerlink" title="2.3.5.4. Set 方法注入"></a>2.3.5.4. Set 方法注入</h5><p>解释：通过给属性设置set方法，容器底层调用set方法将配置文件中对应属性的值注入到对象中。<strong>（属性值必须具有Set方法才能使用）</strong></p><p>好处：能够很灵活的给Bean对象注入属性值</p><p>坏处：有些属性必须赋值缺做不到，所以需要通过构造函数注入加上Set注入完成最佳化</p><p>参数说明</p><ul><li><code>property</code>：阐述构造函数参数的信息<ul><li><code>name</code>：set方法名，去掉set， 第一个字母小写</li><li><code>value</code>：插入基本数据类型和String类型</li><li><code>ref</code>：插入对象类型数据（该对象类型数据必须交由Spring管理才能注入）</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student1"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.bean.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"200"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"请勿打扰"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"date"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-3-5-5-p标签注入"><a href="#2-3-5-5-p标签注入" class="headerlink" title="2.3.5.5. p标签注入"></a>2.3.5.5. p标签注入</h5><p>解释：这种方式底层还是使用set方法注入，<strong>需要在引入约束头中加入p空间约束才能使用</strong></p><p>好处：更加简单使用set方法注入属性</p><p>坏处：需要在约束头中加入p空间约束才能使用</p><p>步骤：</p><ul><li>1.现在约束中加入p空间约束<strong>(在第二行)</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span>      </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>   </span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>2.在bean标签中使用P空间<ul><li>格式： <ul><li>调用set方法名：<code>set方法名，去掉set， 第一个字母小写</code> </li><li>基础数据类型/String数据类型：p: <code>调用set方法名</code>= “属性值”</li><li>对象数据类型：p: <code>调用set方法名</code>-ref = “属性值”</li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student2"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.bean.Student"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:age</span>=<span class="string">"250"</span> <span class="attr">p:name</span>=<span class="string">"我真帅"</span> <span class="attr">p:birthday-ref</span>=<span class="string">"date"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-3-5-6-注入集合属性数据"><a href="#2-3-5-6-注入集合属性数据" class="headerlink" title="2.3.5.6.注入集合属性数据"></a>2.3.5.6.注入集合属性数据</h5><p>Spring的DI可以给对象注入 数组，List，Set, Map, Properties的数据,同时也存在着一定的规律</p><ul><li><p>规律：</p><ul><li>数组,List,Set是同类型的数据结构，在声明数据结构的时候可以混用</li><li>Map,properties是同类型的数据结构，在声明数据结构的时候可以混用</li></ul></li><li><p>给对象注入数组类型（array | list | set）推荐使用 <code>&lt;list&gt; &lt;value&gt;20&lt;/value&gt; &lt;/list&gt;</code></p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student3"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.bean.Student"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"arr"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>5<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>10<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>15<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>20<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>25<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>30<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"set"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>300<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>键值对类型 （map | properties） 推荐使用<code>&lt;map&gt; &lt;entry key=&quot;aa&quot; value=&quot;AA&quot;/&gt; &lt;/map&gt;</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"aa"</span> <span class="attr">value</span>=<span class="string">"AA"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"bb"</span> <span class="attr">value</span>=<span class="string">"BB"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"cc"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"qq"</span> &gt;</span>QQ<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"ww"</span> &gt;</span>WW<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-IOC注解部分"><a href="#2-4-IOC注解部分" class="headerlink" title="2.4. IOC注解部分"></a>2.4. IOC注解部分</h3><h4 id="2-4-1-在Spring如何开启注解？"><a href="#2-4-1-在Spring如何开启注解？" class="headerlink" title="2.4.1. 在Spring如何开启注解？"></a>2.4.1. 在Spring如何开启注解？</h4><p>i.在Spring中，由于注解都是在类上的，又没有告知spring，所以可以知道，要开启注解需要告知spring 在哪里扫描类上的注解。</p><p>ii.在告知spring的时候 需要在命名空间加上有关于context 的约束</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启注解扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.accompany.spring.demo1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-4-2-IOC注解在Spring中的分类"><a href="#2-4-2-IOC注解在Spring中的分类" class="headerlink" title="2.4.2. IOC注解在Spring中的分类"></a>2.4.2. IOC注解在Spring中的分类</h4><h5 id="2-4-2-1-用于创建对象"><a href="#2-4-2-1-用于创建对象" class="headerlink" title="2.4.2.1.用于创建对象"></a>2.4.2.1.用于创建对象</h5><ul><li><p>这类型标签相当于在XML文件中加入了<code>&lt;bean&gt;</code>标签</p></li><li><p>注解：作用在具体的的实现类上</p><ul><li>@Component：声明将该类交由spring管理</li><li>@Service：声明该类为服务层对象，同时交由spring管理</li><li>@Repository：声明该类为数据持久层对象，同时交由spring管理</li><li>@Controller：声明该类为控制层对象，同时交由spring管理</li></ul></li><li><p>从源码的角度上分析，对于上面四种注解，@Service、@Repository、@Controller 都是由@Component衍生出来的。无论是@Service、@Repository、@Controller，在注解类上都会存在@Component注解，同时在属性上，也指向了Component的value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Repository &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment"> * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = Component.class)</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-4-2-2-用于数据注入"><a href="#2-4-2-2-用于数据注入" class="headerlink" title="2.4.2.2.用于数据注入"></a>2.4.2.2.用于数据注入</h5><ul><li><p>相当于在XML配置文件的<code>&lt;bean&gt;</code>标签中的<code>&lt;property&gt;</code>标签一致。</p></li><li><p><strong>缺点：</strong>无法给对象注入数组/集合类型数据</p></li><li><p>问题？：为什么使用XML配置Bean需要给属性设置set/get方法才能注入，而使用注解配置Bean不需要设置set/get方法就能注入？</p><ul><li><p>分析原因：是否走了set方法？</p><ul><li>给属性加入set方法进行标记，然后通过注解注入，最后发现并没有走自定义的set方法，说明了并不是使用set方法对属性值进行注入</li></ul></li><li><p>网上查询：读取类文件，通过反射暴力访问私有属性并且对其赋值，大致方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取class对象 （有三种方法）</span></span><br><span class="line">      <span class="comment">//i.通过类名称获取  类名.class;</span></span><br><span class="line">      <span class="comment">//ii.通过对象获取    对象名.getClass()</span></span><br><span class="line">      <span class="comment">//iii.通过类的全路径获取    Class.forName("classPath")</span></span><br><span class="line">      Class&lt;StudentServiceImpl2&gt; c = StudentServiceImpl2.class;</span><br><span class="line">      <span class="comment">//2.通过反射实例化对象</span></span><br><span class="line">      StudentServiceImpl2 rs = c.newInstance();</span><br><span class="line">      <span class="comment">//3.类的属性字段</span></span><br><span class="line">      Field field = c.getDeclaredField(<span class="string">"s1"</span>);</span><br><span class="line">      <span class="comment">//4.设置属性字段允许暴力访问</span></span><br><span class="line">      field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">//5.设置字段值</span></span><br><span class="line">      field.set(rs,<span class="string">"yyx你真帅"</span>);</span><br><span class="line">      rs.print();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>注解：作用在属性上</p><ul><li><p>注入对象数据类型</p><ul><li><p><code>@Autowired</code>：从IOC容器中找到类型<strong>唯一且一致</strong>的对象注入。需要注意，当IOC存在多个类型一致的对象，那么在注入的时候，会先找到一批类型一致的对象，在找到属性名称与存储在IOC容器属性名称一致的对象注入。</p><ul><li>图解</li></ul><p><img src="/2019/07/14/重走spring框架(IOC部分)/7.jpg" alt></p><ul><li>@Qualifier：与<code>@Autowired</code>配合使用，通过@Qualifier(value=”bean Name”)指定在IOC容器中对应Bean的KEY值，解决了找不到唯一对象注入的问题</li></ul></li><li><p>@Resource(name=”bean Name”)：在IOC容器中找到同数据类型相同且名称等于bean Name的对象注入</p></li></ul></li></ul></li></ul><ul><li><p>注入基础数据类型/String数据类型</p><ul><li>@Value(value=”xx “)：将xx的值直接注入到属性上</li></ul></li></ul><h5 id="2-4-2-3-用于改变作用范围"><a href="#2-4-2-3-用于改变作用范围" class="headerlink" title="2.4.2.3.用于改变作用范围"></a>2.4.2.3.用于改变作用范围</h5><ul><li>相当于在XML配置文件的<code>&lt;bean&gt;</code>标签中加入了<code>Scope=&quot;singleton/prototype...&quot;</code></li><li>注解：作用在类上<ul><li>@Scope(“singleton/prototype…”)</li></ul></li></ul><h5 id="2-4-2-4-和生命周期相关"><a href="#2-4-2-4-和生命周期相关" class="headerlink" title="2.4.2.4.和生命周期相关"></a>2.4.2.4.和生命周期相关</h5><ul><li>相当于在XML配置文件的<code>&lt;bean&gt;</code>标签中加入了<code>init-method=&quot;&quot; destroy-method=&quot;&quot;</code></li><li>注解：作用在方法上<ul><li><code>@PostConstruct</code>：类加载时运行（单例模式执行一次，多例模式获取一次执行一次）</li><li><code>@PreDestroy</code>：类销毁时运行（单例：容器关闭执行，多例不执行）</li></ul></li></ul><h4 id="2-4-3-配置信息类注解"><a href="#2-4-3-配置信息类注解" class="headerlink" title="2.4.3. 配置信息类注解"></a>2.4.3. 配置信息类注解</h4><h5 id="2-4-3-1-配置信息类有什么用？"><a href="#2-4-3-1-配置信息类有什么用？" class="headerlink" title="2.4.3.1.配置信息类有什么用？"></a>2.4.3.1.配置信息类有什么用？</h5><h5 id="2-4-3-2-用于声明该类为配置类"><a href="#2-4-3-2-用于声明该类为配置类" class="headerlink" title="2.4.3.2.用于声明该类为配置类"></a>2.4.3.2.用于声明该类为配置类</h5><ul><li>相当于XML配置文件本身</li><li>使用说明：跟XML配置差不多，在启动的时候使用<code>ApplicationContext context = new AnnotationConfigApplicationContext(xxx.class...)</code>需要告知主配置类的位置。当使用new 然后传递配置类的时候，可以不用在类上标记注解。同时也可以认为这个类是主配置类。</li><li>注解：作用在类上<ul><li><code>@Configuration</code>：在某些情况下可以不加此注解<ul><li><code>@Import(xxx.class...)</code>在配置类上导入其他配置类，一般放在主配置类上，导入其他配置类（被导入的配置类可以不用加入<code>@Configuration</code>注解）</li></ul></li></ul></li></ul><h5 id="2-4-3-3-包扫描"><a href="#2-4-3-3-包扫描" class="headerlink" title="2.4.3.3.包扫描"></a>2.4.3.3.包扫描</h5><ul><li><p>相当于在XML配置文件中加入了<code>&lt;context:component-scan base-package=&quot;xx&quot; /&gt;</code></p></li><li><p>注解：</p><ul><li><code>@ComponentScan(&quot;pakeage Path&quot;)</code>：配置单个扫描包</li><li><code>@ComponentScan({&quot;xx&quot;,&quot;yy&quot;})</code>：配置多个扫描包</li></ul></li><li><p>注解源码：可以看出 value 和 basePackages 相互指向，所以在传参时，用那个都行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Alias for &#123;<span class="doctag">@link</span> #basePackages&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Allows for more concise annotation declarations if no other attributes</span></span><br><span class="line"><span class="comment"> * are needed &amp;mdash; for example, &#123;<span class="doctag">@code</span> <span class="doctag">@ComponentScan</span>("org.my.pkg")&#125;</span></span><br><span class="line"><span class="comment"> * instead of &#123;<span class="doctag">@code</span> <span class="doctag">@ComponentScan</span>(basePackages = "org.my.pkg")&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"basePackages"</span>)</span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base packages to scan for annotated components.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&#123;<span class="doctag">@link</span> #value&#125; is an alias for (and mutually exclusive with) this</span></span><br><span class="line"><span class="comment"> * attribute.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Use &#123;<span class="doctag">@link</span> #basePackageClasses&#125; for a type-safe alternative to</span></span><br><span class="line"><span class="comment"> * String-based package names.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-4-3-4-用于将方法返回的对象放进容器"><a href="#2-4-3-4-用于将方法返回的对象放进容器" class="headerlink" title="2.4.3.4.用于将方法返回的对象放进容器"></a>2.4.3.4.用于将方法返回的对象放进容器</h5><ul><li>相当于在XML加入了<code>&lt;bean&gt;</code>标签，不过和<code>@Component</code>不同的是，<code>@Bean</code>作用在方法上而<code>@Component</code>作用在类上</li><li>问题：<ul><li>1.如果返回值不是对象，而是基本数据类型，那么是会报错还是会发生什么？<ul><li>根据测试得知，是不会报错，而是会将基本数据类型存进容器，id为方法名（觉得自己很蠢，万物皆对象啊！！！！）</li></ul></li><li>2.如果方法中有参数，如何给参数传递值？<ul><li>当Spring读取到被<code>@Bean</code>控制方法时，参数注入形式是与<code>@Autowired</code>一致，所以根据这个可知，可以与<code>@Qualifier</code>一同使用达到根据id获取到具体Bean对象。</li></ul></li></ul></li><li>注解：可以与<code>@Scope</code>注解配合使用，控制作用范围<ul><li><code>@Bean(name=&quot;id&quot;)</code>：name=”id” 属性值 可加可不加，当不加入的时候，id为方法名。</li></ul></li></ul><h5 id="2-4-3-5-用于读取配置文件"><a href="#2-4-3-5-用于读取配置文件" class="headerlink" title="2.4.3.5.用于读取配置文件"></a>2.4.3.5.用于读取配置文件</h5><ul><li>相当于再XML加入了<code>&lt;context:property-placeholder location=``&quot;classpath:conf/*.properties&quot;</code> `file-encoding=<code>&quot;UTF-8&quot;</code>/&gt;</li><li>注意：无法读取<code>yml</code>文件</li><li>注解：<code>classpath</code>是定义在注解里面特殊字符，表示在类路径找文件，默认采用的是<code>UTF-8</code>解码<ul><li><code>@PropertyScource(&quot;classpath:xxx&quot;)</code></li></ul></li></ul><h4 id="3-4-4-问题"><a href="#3-4-4-问题" class="headerlink" title="3.4.4.问题"></a>3.4.4.问题</h4><ul><li>配置注解类就取代掉配置文件，那么配置文件还有存在的意义吗？<ul><li>全注解开发：<ul><li>好处：不用写XML配置文件，更简单的配置Bean对象，完成注入等一系列问题。</li><li>坏处：由于注解都是写在类上，当类的数量多了起来，那么在后期维护的时候找起来也是一个问题。</li></ul></li><li>纯XML配置开发：<ul><li>好处：在XML配置文件中配置可以很广泛的知道在系统中配置了多个Bean，以及注入信息是什么，作用范围是什么。</li><li>坏处：XML配置是繁琐的，厚重的。</li></ul></li><li>半注解半配置开发：<ul><li>好处：在一定程度上结合了全注解开发以及纯XML配置开发的好处。</li><li>什么时候用？：当开发自定义类的时候可以使用注解开发，当配置其他框架的类的时候可以使用XML配置模式开发。</li></ul></li></ul></li></ul><h2 id="3-有关于整合-Junit"><a href="#3-有关于整合-Junit" class="headerlink" title="3.有关于整合 Junit"></a>3.有关于整合 Junit</h2><h3 id="3-1-分析问题"><a href="#3-1-分析问题" class="headerlink" title="3.1.分析问题"></a>3.1.分析问题</h3><p>在测试类中，如果是spring项目测试，就永远离不开IOC容器，但是Junit是不知道是否使用spring，以及配置文件在何处（或主配置类）在何处。</p><p>所以也就离不开两句话，同时也不支持注入到测试类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取XML配置或去读配置类</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationConfig.class);</span><br><span class="line"><span class="comment">//获取对应的对象</span></span><br><span class="line">Object a = context.getBean(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure><h3 id="3-2-解决问题思路"><a href="#3-2-解决问题思路" class="headerlink" title="3.2.解决问题思路"></a>3.2.解决问题思路</h3><p>需要让Junit在启动的时候就运行Spring，这样就可以完成在测试中加入注入属性，而不是通过context去获取，但是如何去做？就需要做到替换Junit的启动器<code>Runner</code>成spring自定义的启动器。</p><h3 id="3-3-代码实现"><a href="#3-3-代码实现" class="headerlink" title="3.3.代码实现"></a>3.3.代码实现</h3><ul><li><p>1.导入有关于测试对应的坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring与junit整合包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--junit --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>2.在测试类上加入注解</p><ul><li><code>@Runwith(SpringJUnit4ClassRunner.class)</code>：表示使用<code>Spring-Test</code>提供的<code>Runner</code>启动器</li><li><code>@ContextConfiguration()</code>：表示配置文件位置或者配置类的位置<ul><li>属性值：<ul><li><code>value=&quot;classpath: &quot;</code>：表示使用XML配置文件，同时在类路径下查找文件</li><li><code>classes=&quot;xxx.class...&quot;</code>：表示使用注解类</li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = ApplicationConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a:"</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring框架&quot;&gt;&lt;a href=&quot;#Spring框架&quot; class=&quot;headerlink&quot; title=&quot;Spring框架&quot;&gt;&lt;/a&gt;Spring框架&lt;/h1&gt;&lt;p&gt;学习过程中的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么在使用JDBC使用的是&lt;code&gt;Cla
      
    
    </summary>
    
      <category term="后端框架" scheme="https://aaccompany.github.io/categories/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="spring" scheme="https://aaccompany.github.io/tags/spring/"/>
    
      <category term="重走系列" scheme="https://aaccompany.github.io/tags/%E9%87%8D%E8%B5%B0%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Active消息中间件</title>
    <link href="https://aaccompany.github.io/2019/07/02/Active%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://aaccompany.github.io/2019/07/02/Active消息中间件/</id>
    <published>2019-07-02T02:13:52.000Z</published>
    <updated>2019-07-10T05:08:29.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h1><p>当没有采用消息中间件的系统模块图,当运营商后台去调用搜索服务和页面生成服务的时候，不需要知道他们返回的结果，所以在这里为了提高效率、降低系统耦合度可以采用消息中间件的解决方案。</p><p><img src="/2019/07/02/Active消息中间件/01.png" alt="01"></p><p>当采用了消息中间件之后的系统模块图，中间去除了dubbo和减少了对搜索服务和页面生成服务的依赖，降低了系统耦合度</p><p><img src="/2019/07/02/Active消息中间件/02.png" alt></p><h2 id="1-什么是消息中间件"><a href="#1-什么是消息中间件" class="headerlink" title="1.什么是消息中间件"></a>1.什么是消息中间件</h2><p>消息中间件利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在<strong><em>分布式环境</em></strong>下扩展进程间的通信。对于消息中间件，常见的角色大致也就有Producer（生产者）、Consumer（消费者）</p><p>1.1常见的消息中间件产品</p><p>JMS:JAVA MESSAGE SERVICE</p><p>（1）ActiveMQ</p><p>ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。</p><p>（2）RabbitMQ</p><p>AMQP协议的领导实现，支持多种场景。淘宝的MySQL集群内部有使用它进行通讯，OpenStack开源云平台的通信组件，最先在金融行业得到运用。</p><p>（3）ZeroMQ</p><p>史上最快的消息队列系统</p><p>（4）Kafka</p><p>Apache下的一个子项目 。特点：高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统。适合处理海量数据。</p><h3 id="1-1-什么是JMS"><a href="#1-1-什么是JMS" class="headerlink" title="1.1.什么是JMS"></a>1.1.什么是JMS</h3><p>JMS（<a href="http://lib.csdn.net/base/java" target="_blank" rel="noopener"><strong>Java</strong> </a>Messaging Service）是Java平台上有关面向消息中间件的技术规范，它便于消息系统中的Java应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发。</p><p>​       JMS本身只定义了一系列的接口规范，是一种与厂商无关的 API，用来访问消息收发系统。它类似于 JDBC(<a href="http://lib.csdn.net/base/java" target="_blank" rel="noopener"><strong>java</strong> </a>Database Connectivity)：这里，JDBC 是可以用来访问许多不同关系<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="noopener"><strong>数据库</strong></a>的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。许多厂商目前都支持 JMS，包括 IBM 的 MQSeries、BEA的 Weblogic JMS service和 Progress 的 SonicMQ，这只是几个例子。 JMS 使您能够通过消息收发服务（有时称为消息中介程序或路由器）从一个 JMS 客户机向另一个 JML 客户机发送消息。消息是 JMS 中的一种类型对象，由两部分组成：报头和消息主体。报头由路由信息以及有关该消息的元数据组成。消息主体则携带着应用程序的数据或有效负载。</p><p>JMS 定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一</p><p>些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p><p>· TextMessage–一个字符串对象</p><p>· MapMessage–一套名称-值对</p><p>· ObjectMessage–一个序列化的 Java 对象</p><p>· BytesMessage–一个字节的数据流</p><p>· StreamMessage – Java 原始值的数据流</p><h3 id="1-2-JMS消息传递"><a href="#1-2-JMS消息传递" class="headerlink" title="1.2.JMS消息传递"></a>1.2.JMS消息传递</h3><p>在消息传递存在两种类型：</p><h4 id="1-2-1-点对点"><a href="#1-2-1-点对点" class="headerlink" title="1.2.1.点对点"></a>1.2.1.点对点</h4><p>一个生产者会对应一个消费者，一个生成者发布的消息会存放在队列中，然后消费者不一定需要及时将队列的数据取出，而是可以不定时的去获取数据。当数据被取出的时候队列中的消息就会减少一条。</p><p>当存在多个消费者监听的队列是同一个的时候，谁先监听消息队列谁就先获取到数据。</p><p><img src="/2019/07/02/Active消息中间件/03.png" alt></p><h4 id="1-2-2-发布-订阅"><a href="#1-2-2-发布-订阅" class="headerlink" title="1.2.2.发布/订阅"></a>1.2.2.发布/订阅</h4><p>一个生产者会对应多个消费者，当一个生产者发布了一条信息，会将数据存放在topic中，然后即时发生给每个在线的消费者，类似与广播的特性。</p><p>当有一个消费者没有上线的时候，会接受不到广播。</p><p><img src="/2019/07/02/Active消息中间件/04.png" alt></p><h2 id="2-ActiveMQ安装（Linux）"><a href="#2-ActiveMQ安装（Linux）" class="headerlink" title="2.ActiveMQ安装（Linux）"></a>2.ActiveMQ安装（Linux）</h2><p>（1）将apache-activemq-5.12.0-bin.tar.gz 上传至服务器</p><p>（2）解压此文件</p><p>   tar  zxvf    apache-activemq-5.12.0-bin.tar.gz   </p><p>（3）为apache-activemq-5.12.0目录赋权</p><p> <code>chmod 777 apache-activemq-5.12.0</code></p><p>（4）进入apache-activemq-5.12.0\bin目录</p><p>（5）赋与执行权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   chmod <span class="number">755</span> activemq    </span><br><span class="line">--------------------------  **知识点小贴士**------------------------   </span><br><span class="line">linux 命令chmod <span class="number">755</span>的意思   </span><br><span class="line">chmod是 Linux 下设置文件权限的命令，后面的数字表示不同用户或用户组的权限。   </span><br><span class="line">一般是三个数字：    </span><br><span class="line">第一个数字表示文件所有者的权限    </span><br><span class="line">第二个数字表示与文件所有者同属一个用户组的其他用户的权限    </span><br><span class="line">第三个数字表示其它用户组的权限。         </span><br><span class="line">权限分为三种：读（r=<span class="number">4</span>），写（w=<span class="number">2</span>），执行（x=<span class="number">1</span>） 。 </span><br><span class="line">综合起来还有可读可执行（rx=<span class="number">5</span>=<span class="number">4</span>+<span class="number">1</span>）、</span><br><span class="line">可读可写（rw=<span class="number">6</span>=<span class="number">4</span>+<span class="number">2</span>）、</span><br><span class="line">可读可写可执行(rwx=<span class="number">7</span>=<span class="number">4</span>+<span class="number">2</span>+<span class="number">1</span>)。         </span><br><span class="line">所以，chmod <span class="number">755</span> 设置用户的权限为：    </span><br><span class="line"><span class="number">1</span>.文件所有者可读可写可执行       --<span class="number">7</span>   </span><br><span class="line"><span class="number">2</span>.与文件所有者同属一个用户组的其他用户可读可执行 --<span class="number">5</span>     </span><br><span class="line"><span class="number">3</span>.其它用户组可读可执行                                            --<span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="1-3-3启动"><a href="#1-3-3启动" class="headerlink" title="1.3.3启动"></a>1.3.3启动</h3><p>​    ./activemq start   </p><p>出现下列提示表示成功！</p><p><img src="/2019/07/02/Active消息中间件/05.png" alt></p><p>假设服务器地址为192.168.25.135 ，打开浏览器输入地址</p><p><a href="http://192.168.25.129:8161/" target="_blank" rel="noopener">http://192.168.25.135:8161/</a> 即可进入ActiveMQ管理页面</p><p><img src="/2019/07/02/Active消息中间件/06.png" alt></p><p>点击进入管理页面</p><p><img src="/2019/07/02/Active消息中间件/07.png" alt></p><p>输入用户名和密码  均为 admin </p><p><img src="/2019/07/02/Active消息中间件/08.png" alt></p><p>进入主界面</p><p><img src="/2019/07/02/Active消息中间件/09.png" alt></p><p>点对点消息列表：</p><p><img src="/2019/07/02/Active消息中间件/10.png" alt></p><p>列表各列信息含义如下：</p><p><strong>Number Of Pending Messages</strong>  <strong>：</strong>等待消费的消息 这个是当前未出队列的数量。</p><p><strong>Number Of Consumers</strong>  <strong>：</strong>消费者 这个是消费者端的消费者数量</p><p><strong>Messages Enqueued</strong>  <strong>：</strong>进入队列的消息  进入队列的总数量,包括出队列的。</p><p><strong>Messages Dequeued</strong>  <strong>：</strong>出了队列的消息  可以理解为是消费这消费掉的数量。</p><h2 id="3-JMS入门小Demo"><a href="#3-JMS入门小Demo" class="headerlink" title="3.JMS入门小Demo"></a>3.JMS入门小Demo</h2><h3 id="3-1点对点Demo"><a href="#3-1点对点Demo" class="headerlink" title="3.1点对点Demo"></a>3.1点对点Demo</h3><p>点对点的模式主要建立在一个队列上面，当连接一个列队的时候，发送端不需要知道接收端是否正在接收，可以直接向ActiveMQ发送消息，发送的消息，将会先进入队列中，如果有接收端在监听，则会发向接收端，如果没有接收端接收，则会保存在ActiveMQ服务器，直到接收端接收消息，点对点的消息模式可以有多个发送端，多个接收端，但是一条消息，只会被一个接收端给接收到，哪个接收端先连上ActiveMQ，则会先接收到，而后来的接收端则接收不到那条消息。</p><h4 id="3-1-1添加依赖"><a href="#3-1-1添加依赖" class="headerlink" title="3.1.1添加依赖"></a>3.1.1添加依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.13.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-1-2生产者代码"><a href="#3-1-2生产者代码" class="headerlink" title="3.1.2生产者代码"></a>3.1.2生产者代码</h4><p>注意：</p><p>1)在地址中传输协议为tcp</p><p>2）在第四步骤中的参数说明</p><p>第一个参数：是否开启事务</p><p>第二个参数消息的确定模式</p><ul><li>AUTO_ACKNOWLEDGE = 1    自动确认</li><li>CLIENT_ACKNOWLEDGE = 2    客户端手动确认   </li><li>DUPS_OK_ACKNOWLEDGE = 3    自动批量确认</li><li>SESSION_TRANSACTED = 0    事务提交并确认</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//1.创建连接工厂</span></span><br><span class="line"><span class="comment">//说明：使用想对应的是厂商的连接工厂</span></span><br><span class="line">ConnectionFactory  connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://120.76.56.183:61616"</span>);</span><br><span class="line"><span class="comment">//2.创建连接</span></span><br><span class="line">Connection connection = connectionFactory.createConnection();</span><br><span class="line"><span class="comment">//3.启动连接</span></span><br><span class="line">connection.start();</span><br><span class="line"><span class="comment">//4.获取session</span></span><br><span class="line"><span class="comment">//参数说明：1.是否启用事务2.消息确认模式</span></span><br><span class="line">Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"><span class="comment">//5.创建消息队列 </span></span><br><span class="line"><span class="comment">//参数说明：队列的名称</span></span><br><span class="line">Queue queue = session.createQueue(<span class="string">"test-queue"</span>);</span><br><span class="line"><span class="comment">//6.创建生产者  参数说明：生产者使用那个消息对象</span></span><br><span class="line">MessageProducer producer = session.createProducer(queue);</span><br><span class="line"><span class="comment">//7.创建消息</span></span><br><span class="line">TextMessage message = session.createTextMessage(<span class="string">"你真是个大傻吊"</span>);</span><br><span class="line"><span class="comment">//8.发生消息</span></span><br><span class="line">producer.send(message);</span><br><span class="line"><span class="comment">//9.关闭资源</span></span><br><span class="line">producer.close();</span><br><span class="line">session.close();</span><br><span class="line">connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-3消费者代码"><a href="#3-1-3消费者代码" class="headerlink" title="3.1.3消费者代码"></a>3.1.3消费者代码</h4><p>注意：需要创建匿名内部类 Message Listener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//1.创建连接工厂</span></span><br><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://120.76.56.183:61616"</span>);</span><br><span class="line"><span class="comment">//2.创建连接</span></span><br><span class="line">Connection connection = connectionFactory.createConnection();</span><br><span class="line"><span class="comment">//3.启动连接</span></span><br><span class="line">connection.start();</span><br><span class="line"><span class="comment">//4.获取session</span></span><br><span class="line">Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"><span class="comment">//5.监听对应的消息队列</span></span><br><span class="line">Queue queue = session.createQueue(<span class="string">"test-queue"</span>);</span><br><span class="line"><span class="comment">//6.由会话，创建消息消费者</span></span><br><span class="line">MessageConsumer consumer = session.createConsumer(queue);</span><br><span class="line"><span class="comment">//7.监听消息</span></span><br><span class="line">consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">TextMessage textMessage = (TextMessage)message;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"监听到的消息"</span>+textMessage.getText());</span><br><span class="line">&#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//8.持续监听</span></span><br><span class="line">System.in.read();</span><br><span class="line"><span class="comment">//9.释放资源</span></span><br><span class="line">consumer.close();</span><br><span class="line">session.close();</span><br><span class="line">connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2发布-订阅Demo"><a href="#3-2发布-订阅Demo" class="headerlink" title="3.2发布/订阅Demo"></a>3.2发布/订阅Demo</h3><h4 id="3-2-1添加依赖"><a href="#3-2-1添加依赖" class="headerlink" title="3.2.1添加依赖"></a>3.2.1添加依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.13.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-2生产者代码"><a href="#3-2-2生产者代码" class="headerlink" title="3.2.2生产者代码"></a>3.2.2生产者代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//1.创建连接工厂</span></span><br><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://120.76.56.183:61616"</span>);</span><br><span class="line"><span class="comment">//2.获取连接</span></span><br><span class="line">Connection connection = connectionFactory.createConnection();</span><br><span class="line"><span class="comment">//3.开启连接</span></span><br><span class="line">connection.start();</span><br><span class="line"><span class="comment">//4.获取session</span></span><br><span class="line">Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"><span class="comment">//5.创建topic</span></span><br><span class="line">Topic topic = session.createTopic(<span class="string">"test-topic"</span>);</span><br><span class="line"><span class="comment">//6.创建消息生产者</span></span><br><span class="line">MessageProducer producer = session.createProducer(topic);</span><br><span class="line"><span class="comment">//7.创建消息 由session去创建消息</span></span><br><span class="line">TextMessage message = session.createTextMessage(<span class="string">"啊啊啊啊，你可以简单点么"</span>);</span><br><span class="line"><span class="comment">//8.发送消息</span></span><br><span class="line">producer.send(message);</span><br><span class="line"><span class="comment">//9.释放资源</span></span><br><span class="line">producer.close();</span><br><span class="line">session.close();</span><br><span class="line">connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-3消费者代码"><a href="#3-2-3消费者代码" class="headerlink" title="3.2.3消费者代码"></a>3.2.3消费者代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//1.创建工厂</span></span><br><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://120.76.56.183:61616"</span>);</span><br><span class="line"><span class="comment">//2.创建连接</span></span><br><span class="line">Connection connection = connectionFactory.createConnection();</span><br><span class="line"><span class="comment">//3.启动连接</span></span><br><span class="line">connection.start();</span><br><span class="line"><span class="comment">//4.获取session</span></span><br><span class="line">Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"><span class="comment">//5.获取Topic</span></span><br><span class="line">Topic topic = session.createTopic(<span class="string">"test-topic"</span>);</span><br><span class="line"><span class="comment">//6.获取topic消费者</span></span><br><span class="line">MessageConsumer consumer = session.createConsumer(topic);</span><br><span class="line"><span class="comment">//7.设置监听</span></span><br><span class="line">consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">TextMessage textMessage = (TextMessage) message;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"topic监听到了"</span>+textMessage.getText());</span><br><span class="line">&#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//8.持久监听</span></span><br><span class="line">System.in.read();</span><br><span class="line"><span class="comment">//9.关闭资源</span></span><br><span class="line">consumer.close();</span><br><span class="line">session.close();</span><br><span class="line">connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Spring整合ActiveMQ"><a href="#4-Spring整合ActiveMQ" class="headerlink" title="4.Spring整合ActiveMQ"></a>4.Spring整合ActiveMQ</h2><h3 id="4-1点对点Demo"><a href="#4-1点对点Demo" class="headerlink" title="4.1点对点Demo"></a>4.1点对点Demo</h3><h4 id="4-1-1生产者代码"><a href="#4-1-1生产者代码" class="headerlink" title="4.1.1生产者代码"></a>4.1.1生产者代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JMS模板 负责发送消息 接受消息</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JmsTemplate jmsTemplate ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//消息的目的地</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Destination queueTextDestination;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成者发生信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTextMessage</span><span class="params">(<span class="keyword">final</span> String text)</span> </span>&#123;</span><br><span class="line">jmsTemplate.send(queueTextDestination, <span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> session.createTextMessage(text);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2配置文件"><a href="#4-1-2配置文件" class="headerlink" title="4.1.2配置文件"></a>4.1.2配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:amq</span>=<span class="string">"http://activemq.apache.org/schema/core"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:jms</span>=<span class="string">"http://www.springframework.org/schema/jms"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans   </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context   </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.yuanxiong.producer"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span>     </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.ActiveMQConnectionFactory"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brokerURL"</span> <span class="attr">value</span>=<span class="string">"tcp://120.76.56.183:61616"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.connection.SingleConnectionFactory"</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">ref</span>=<span class="string">"targetConnectionFactory"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>      </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--这个是队列目的地，点对点的  文本信息--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"queueTextDestination"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 消息队列的值 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"queue_text"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--这个是订阅模式  文本信息 </span></span><br><span class="line"><span class="comment">&lt;bean id="topicTextDestination" class="org.apache.activemq.command.ActiveMQTopic"&gt;  </span></span><br><span class="line"><span class="comment">    &lt;constructor-arg value="topic_text"/&gt;  </span></span><br><span class="line"><span class="comment">&lt;/bean&gt;  </span></span><br><span class="line"><span class="comment">--&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-1-3消费者代码"><a href="#4-1-3消费者代码" class="headerlink" title="4.1.3消费者代码"></a>4.1.3消费者代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuanxiong.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.MessageListener;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">TextMessage textMessage = (TextMessage) message;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"queue监听到了"</span>+textMessage.getText());</span><br><span class="line">&#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-4配置文件"><a href="#4-1-4配置文件" class="headerlink" title="4.1.4配置文件"></a>4.1.4配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:amq</span>=<span class="string">"http://activemq.apache.org/schema/core"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:jms</span>=<span class="string">"http://www.springframework.org/schema/jms"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans   </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context   </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.ActiveMQConnectionFactory"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brokerURL"</span> <span class="attr">value</span>=<span class="string">"tcp://120.76.56.183:61616"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.connection.SingleConnectionFactory"</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">ref</span>=<span class="string">"targetConnectionFactory"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--这个是队列目的地，点对点的  文本信息--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"queueTextDestination"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"queue_text"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 我的监听类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.yuanxiong.consumer"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 消息监听容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destination"</span> <span class="attr">ref</span>=<span class="string">"queueTextDestination"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 我的监听类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageListener"</span> <span class="attr">ref</span>=<span class="string">"myMessageListener"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-2发布订阅Demo"><a href="#4-2发布订阅Demo" class="headerlink" title="4.2发布订阅Demo"></a>4.2发布订阅Demo</h3><h4 id="4-2-1生产者代码"><a href="#4-2-1生产者代码" class="headerlink" title="4.2.1生产者代码"></a>4.2.1生产者代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuanxiong.producer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Session;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.MessageCreator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Destination topicTextDestination;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTextMessage</span><span class="params">(<span class="keyword">final</span> String string)</span> </span>&#123;</span><br><span class="line">jmsTemplate.send(topicTextDestination, <span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> session.createTextMessage(string);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2配置文件"><a href="#4-2-2配置文件" class="headerlink" title="4.2.2配置文件"></a>4.2.2配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:amq</span>=<span class="string">"http://activemq.apache.org/schema/core"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:jms</span>=<span class="string">"http://www.springframework.org/schema/jms"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans   </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context   </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.yuanxiong.producer"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span>     </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.ActiveMQConnectionFactory"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brokerURL"</span> <span class="attr">value</span>=<span class="string">"tcp://120.76.56.183:61616"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.connection.SingleConnectionFactory"</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">ref</span>=<span class="string">"targetConnectionFactory"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>        </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--这个是订阅模式  文本信息 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"topicTextDestination"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQTopic"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"topic_text"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3消费者代码"><a href="#4-2-3消费者代码" class="headerlink" title="4.2.3消费者代码"></a>4.2.3消费者代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuanxiong.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.MessageListener;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myTopicMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">TextMessage textMessage = (TextMessage)message;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"topic"</span>+textMessage.getText());</span><br><span class="line">&#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.2.4配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:amq</span>=<span class="string">"http://activemq.apache.org/schema/core"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:jms</span>=<span class="string">"http://www.springframework.org/schema/jms"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans   </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context   </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.ActiveMQConnectionFactory"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brokerURL"</span> <span class="attr">value</span>=<span class="string">"tcp://120.76.56.183:61616"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.connection.SingleConnectionFactory"</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">ref</span>=<span class="string">"targetConnectionFactory"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--这个是topic目的地，点对点的  文本信息--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"topicTextDestination"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQTopic"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"topic_text"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 消息监听容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destination"</span> <span class="attr">ref</span>=<span class="string">"topicTextDestination"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageListener"</span> <span class="attr">ref</span>=<span class="string">"myTopicMessageListener"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;消息中间件&quot;&gt;&lt;a href=&quot;#消息中间件&quot; class=&quot;headerlink&quot; title=&quot;消息中间件&quot;&gt;&lt;/a&gt;消息中间件&lt;/h1&gt;&lt;p&gt;当没有采用消息中间件的系统模块图,当运营商后台去调用搜索服务和页面生成服务的时候，不需要知道他们返回的结果，所以在这
      
    
    </summary>
    
      <category term="MQ" scheme="https://aaccompany.github.io/categories/MQ/"/>
    
    
      <category term="消息中间件" scheme="https://aaccompany.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>MQ知其然而不知其所然</title>
    <link href="https://aaccompany.github.io/2019/07/02/MQ%E7%9F%A5%E5%85%B6%E7%84%B6%E8%80%8C%E4%B8%8D%E7%9F%A5%E5%85%B6%E6%89%80%E7%84%B6/"/>
    <id>https://aaccompany.github.io/2019/07/02/MQ知其然而不知其所然/</id>
    <published>2019-07-02T02:13:52.000Z</published>
    <updated>2019-07-10T05:10:42.935Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MQ知其然而不知其所然"><a href="#MQ知其然而不知其所然" class="headerlink" title="MQ知其然而不知其所然"></a>MQ知其然而不知其所然</h1><h2 id="1-什么是MQ？"><a href="#1-什么是MQ？" class="headerlink" title="1.什么是MQ？"></a>1.什么是MQ？</h2><p>MQ：通俗的理解为消息队列。在分布式系统中，一个系统可以将一份数据存放在一个中间件上，然后其他系统需要这份数据的话，就可以从中间件上将这份数据取出。</p><p><strong>那么问题来了，为什么需要使用MQ？</strong></p><p>可以使用MQ做到系统的解耦、异步、削峰。</p><h2 id="2-MQ的优点"><a href="#2-MQ的优点" class="headerlink" title="2.MQ的优点"></a>2.MQ的优点</h2><h3 id="2-1-解耦"><a href="#2-1-解耦" class="headerlink" title="2.1.解耦"></a>2.1.解耦</h3><p><strong>业务：</strong>A系统需要发送数据到BCD系统中，在BCD系统中进行操作</p><h4 id="2-1-1-在不使用MQ下的系统耦合"><a href="#2-1-1-在不使用MQ下的系统耦合" class="headerlink" title="2.1.1.在不使用MQ下的系统耦合"></a>2.1.1.在不使用MQ下的系统耦合</h4><p><img src="/2019/07/02/MQ知其然而不知其所然/22.png" alt></p><p>坏处：</p><p>1.从图中可以知道，当A系统需要完成一个操作，需要BCD协同完成。当整个工程新增系统或者有系统不需要A传递的数据的话，那么就需要修改两方的数据。</p><p>2.因为A系统需要完成一个操作，需要依赖于BCD系统，那么如果其中一个出现了问题，那么整个系统就会出现异常。</p><p>3.如果A系统所依赖的系统访问超时该如何处理。</p><p>所以在这种模式容易出现许多问题，如何解决这些问题呢？</p><h4 id="2-1-2-系统使用MQ解耦"><a href="#2-1-2-系统使用MQ解耦" class="headerlink" title="2.1.2.系统使用MQ解耦"></a>2.1.2.系统使用MQ解耦</h4><p><img src="/2019/07/02/MQ知其然而不知其所然/23.png" alt></p><p>在使用了MQ情况下，A系统可以将需要传递数据发送到MQ中，这时候，A所依赖的系统（BCD）就可以从MQ中获取数据完成操作。这样的话就不需要考虑上面所提及的坏处。</p><h3 id="2-2-异步"><a href="#2-2-异步" class="headerlink" title="2.2.异步"></a>2.2.异步</h3><h4 id="2-2-1-在不使用MQ下系统是保持同步状态"><a href="#2-2-1-在不使用MQ下系统是保持同步状态" class="headerlink" title="2.2.1.在不使用MQ下系统是保持同步状态"></a>2.2.1.在不使用MQ下系统是保持同步状态</h4><p>如果系统采用是的同步设计，那么会给系统造成高延迟的现象</p><p><img src="/2019/07/02/MQ知其然而不知其所然/24.png" alt></p><p>由图中可以得到如果需要完成一个功能总共耗时为200 ms</p><h4 id="2-2-2-在使用MQ下系统可以修改为异步状态"><a href="#2-2-2-在使用MQ下系统可以修改为异步状态" class="headerlink" title="2.2.2.在使用MQ下系统可以修改为异步状态"></a>2.2.2.在使用MQ下系统可以修改为异步状态</h4><p>如果将系统修改为异步状态，那么系统就可以大大减少系统延迟现象。</p><p><img src="/2019/07/02/MQ知其然而不知其所然/25.png" alt></p><p>在使用了MQ的情况下，完成一个功能返回给用户的时间差只存在 50 ms + 5 ms = 55 ms。这样从同步系统到异步系统的时间比值为 40：11 接近省去了4倍的时间（在假设的情况下）。</p><blockquote><p>在互联网企业上一个请求的响应时间应该在200 ms之内，这样用户就很难感知。</p></blockquote><h3 id="2-3-削峰"><a href="#2-3-削峰" class="headerlink" title="2.3.削峰"></a>2.3.削峰</h3><h4 id="2-3-1-没有削峰的系统"><a href="#2-3-1-没有削峰的系统" class="headerlink" title="2.3.1.没有削峰的系统"></a>2.3.1.没有削峰的系统</h4><p><img src="/2019/07/02/MQ知其然而不知其所然/26.png" alt></p><h4 id="2-3-2-使用了MQ对系统进行削峰"><a href="#2-3-2-使用了MQ对系统进行削峰" class="headerlink" title="2.3.2.使用了MQ对系统进行削峰"></a>2.3.2.使用了MQ对系统进行削峰</h4><p><img src="/2019/07/02/MQ知其然而不知其所然/27.png" alt></p><h2 id="3-引入MQ出现的问题？"><a href="#3-引入MQ出现的问题？" class="headerlink" title="3.引入MQ出现的问题？"></a>3.引入MQ出现的问题？</h2><p><img src="/2019/07/02/MQ知其然而不知其所然/29.png" alt></p><p>虽然系统中引入了MQ组件，做到了系统的异步、削峰、解耦，但是因为系统中加入了MQ导致了系统出现了下面几种问题。</p><h3 id="3-1-系统的可用性降低"><a href="#3-1-系统的可用性降低" class="headerlink" title="3.1.系统的可用性降低"></a>3.1.系统的可用性降低</h3><p>引入了MQ，系统的消息转递需要依赖于MQ，但是当MQ宕机的话那么整个系统也会随之宕机。</p><h3 id="3-2-系统的复杂度提高"><a href="#3-2-系统的复杂度提高" class="headerlink" title="3.2.系统的复杂度提高"></a>3.2.系统的复杂度提高</h3><p>引入了MQ会导致系统的架构变得复杂。同时也需要考虑会出现的问题。</p><p>1）是否会往MQ中重复发送消息？</p><p>2）发送给MQ的消息是否会丢失？</p><p>3）发送给MQ的消息如果具有顺序，如何保证消息的顺序？</p><h3 id="3-3-系统一致性问题"><a href="#3-3-系统一致性问题" class="headerlink" title="3.3.系统一致性问题"></a>3.3.系统一致性问题</h3><p>当系统A发送消息给BCD的话，ABC都执行完并且无异常，但是D出现异常。那么A会告知用户执行完毕，这种情况该如何解决。</p><h2 id="如果做MQ的选型？"><a href="#如果做MQ的选型？" class="headerlink" title="如果做MQ的选型？"></a>如果做MQ的选型？</h2><p>1.社区活跃度</p><p>2.单机吞吐量</p><p>3.时效性</p><p>一般在中小型公司采用RabbitMQ（消息处理能力万级，但是语言采用的是erlang专门处理分布式的语言设计所有处理速度快），中大型公司有专门技术人员可以采用RockerMQ（消息处理能力十万级）。大数据采用kafka（消息处理能力十万级）。</p><p>一般现在不采用ActiveMQ（消息处理能力万级）作为MQ，因为社区活跃度开始下降。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MQ知其然而不知其所然&quot;&gt;&lt;a href=&quot;#MQ知其然而不知其所然&quot; class=&quot;headerlink&quot; title=&quot;MQ知其然而不知其所然&quot;&gt;&lt;/a&gt;MQ知其然而不知其所然&lt;/h1&gt;&lt;h2 id=&quot;1-什么是MQ？&quot;&gt;&lt;a href=&quot;#1-什么是MQ？&quot;
      
    
    </summary>
    
      <category term="MQ" scheme="https://aaccompany.github.io/categories/MQ/"/>
    
    
      <category term="消息中间件" scheme="https://aaccompany.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ消息中间件</title>
    <link href="https://aaccompany.github.io/2019/07/02/RabbitMQ%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://aaccompany.github.io/2019/07/02/RabbitMQ消息中间件/</id>
    <published>2019-07-02T02:13:52.000Z</published>
    <updated>2019-07-10T05:13:46.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ消息中间件"><a href="#RabbitMQ消息中间件" class="headerlink" title="RabbitMQ消息中间件"></a>RabbitMQ消息中间件</h1><h2 id="1-RabbitMQ简介"><a href="#1-RabbitMQ简介" class="headerlink" title="1.RabbitMQ简介"></a>1.RabbitMQ简介</h2><h3 id="1-1-消息队列简介"><a href="#1-1-消息队列简介" class="headerlink" title="1.1.消息队列简介"></a>1.1.消息队列简介</h3><p>消息中间件是分布式系统中的重要组件，主要解决了应用耦合，异步消息，流量削锋等问题，实现系统高性能，高可用，可伸缩性喝最终一致性【架构】使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka,MetaMQ,RocketMQ</p><h3 id="1-2-什么是RabbitMQ"><a href="#1-2-什么是RabbitMQ" class="headerlink" title="1.2.什么是RabbitMQ"></a>1.2.什么是RabbitMQ</h3><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。<br>AMQP ：Advanced Message Queue Protocol，高级消息队列协议。它是应用层协议的一个开放 标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，<strong>并不受产品、开发语言等条件的限制。</strong><br>RabbitMQ 初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：</p><p>1.可靠性（Reliability）<br>RabbitMQ 使用一些机制来保证可靠性，如持久化（当服务器挂掉的时候会不会丢失信息，而是会保存信息到硬盘）、传输确认、发布确认。</p><p>2.灵活的路由（Flexible Routing）<br>在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。</p><p>3.消息集群（Clustering）<br>多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</p><p> 4.高可用（Highly Available Queues）<br>队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</p><p>5.多种协议（Multi-protocol）<br>RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。</p><p>6.多语言客户端（Many Clients） RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。</p><p>7.管理界面（Management UI）<br>RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方 面。</p><p>8.跟踪机制（Tracing）<br>如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。</p><p> 9.插件机制（Plugin System）<br>RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。 </p><h3 id="1-3-架构图与主要概念"><a href="#1-3-架构图与主要概念" class="headerlink" title="1.3.架构图与主要概念"></a>1.3.架构图与主要概念</h3><h4 id="1-3-1-架构图"><a href="#1-3-1-架构图" class="headerlink" title="1.3.1.架构图"></a>1.3.1.架构图</h4><p><img src="/2019/07/02/RabbitMQ消息中间件/11.png" alt></p><h4 id="1-2-2-主要概念"><a href="#1-2-2-主要概念" class="headerlink" title="1.2.2.主要概念"></a>1.2.2.主要概念</h4><p>RabbitMQ Server： 也叫broker server，它是一种传输服务。 他的角色就是维护一条 从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。</p><p>Producer： 消息生产者，如图A、B、C，数据的发送方。消息生产者连接RabbitMQ服 务器然后将消息投递到Exchange。</p><p>Consumer：消息消费者，如图1、2、3，数据的接收方。消息消费者订阅队列， RabbitMQ将Queue中的消息发送到消息消费者。 Exchange：生产者将消息发送到Exchange（交换器），由Exchange将消息路由到一个 或多个Queue中（或者丢弃）。</p><p>Exchange并不存储消息。RabbitMQ中的Exchange有 direct、fanout、topic、headers四种类型，每种类型对应不同的路由规则。</p><p>Queue：（队列）是RabbitMQ的内部对象，用于存储消息。消息消费者就是通过订阅队列来获取消息的，RabbitMQ中的消息都只能存储在Queue中，生产者生产消息并终投递到Queue中，消费者可以从Queue中获取消息并消费。多个消费者可以订阅同一个 Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者 都收到所有的消息并处理。</p><p>RoutingKey：生产者在将消息发送给Exchange的时候，一般会指定一个routing key， 来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联 合使用才能终生效。在Exchange Type与binding key固定的情况下（在正常使用时一 般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过 指定routing key来决定消息流向哪里。RabbitMQ为routing key设定的长度限制为255 bytes。</p><p>Connection： （连接）：Producer和Consumer都是通过TCP连接到RabbitMQ Server 的。以后我们可以看到，程序的起始处就是建立这个TCP连接。</p><p>Channels： （信道）：它建立在上述的TCP连接中。数据流动都是在Channel中进行 的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。</p><p>VirtualHost：权限控制的基本单位，一个VirtualHost里面有若干Exchange和 MessageQueue，以及指定被哪些user使用 </p><h2 id="2-走进RabbitMQ"><a href="#2-走进RabbitMQ" class="headerlink" title="2.走进RabbitMQ"></a>2.走进RabbitMQ</h2><h3 id="2-1-RabbitMQ安装"><a href="#2-1-RabbitMQ安装" class="headerlink" title="2.1.RabbitMQ安装"></a>2.1.RabbitMQ安装</h3><p>（1）下载并安装 Eralng<br>配套软件中已提供otp_win64_20.2.exe   （以管理员身份运行安装） （2）下载并安装rabbitmq<br>配套软件中已提供rabbitmq-server-3.7.4.exe。双击安装，注意不要安装在包含中文和 空格的目录下！安装后window服务中就存在rabbitMQ了，并且是启动状态。</p><p>（3）安装管理界面（插件）<br>进入rabbitMQ安装目录的sbin目录，输入命令<br>rabbitmq‐plugins enable rabbitmq_management</p><p>（4）重新启动服务</p><p>（5）打开浏览器，地址栏输入<a href="http://127.0.0.1:15672" target="_blank" rel="noopener">http://127.0.0.1:15672</a>  ,即可看到管理界面的登陆页</p><p>输入用户名和密码，都为guest  进入主界面：</p><p>上侧的导航以此是：概览、连接、信道、交换器、队列、用户管理</p><h3 id="2-2-Docker环境下安装"><a href="#2-2-Docker环境下安装" class="headerlink" title="2.2.Docker环境下安装"></a>2.2.Docker环境下安装</h3><p><strong>1.下载镜像</strong></p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure><p><strong>2.创建RabbitMQ容器</strong></p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span> -di --name=tensqura_rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 15671:15671 -p 15672:15672 -p 25672:25672 rabbitmq:management</span><br></pre></td></tr></table></figure><p>15672 (if management plugin is enabled)</p><p>15671  management监听端口</p><p>5672, 5671 (AMQP 0-9-1 without and with TLS)</p><p> 4369 (epmd)   epmd  代表 Erlang 端口映射守护进程 </p><p>25672 (Erlang distribution)</p><p><strong>3.登入RabbitMQ管理界面</strong></p><p>访问地址：<a href="http://192.168.186.129:15672/" target="_blank" rel="noopener">http://192.168.186.129:15672</a></p><p>账号密码均为guest</p><h3 id="2-3-直接模式-Direct"><a href="#2-3-直接模式-Direct" class="headerlink" title="2.3.直接模式(Direct)"></a>2.3.直接模式(Direct)</h3><h4 id="2-3-1-什么是直接模式"><a href="#2-3-1-什么是直接模式" class="headerlink" title="2.3.1.什么是直接模式"></a>2.3.1.什么是直接模式</h4><p>将消息发给唯一一个节点时使用这种模式，这是简单的一种形式。</p><p><img src="/2019/07/02/RabbitMQ消息中间件/12.png" alt></p><p>任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue。<br>1.一般情况可以使用rabbitMQ自带的Exchange：””(该Exchange的名字为空字符串，下文称其为default Exchange)。</p><p>2.这种模式下不需要将Exchange进行任何绑定(binding)操作 3.消息传递时需要一个“RouteKey”，可以简单的理解为要发送到的队列名字。</p><p>4.如果vhost中不存在RouteKey中指定的队列名，则该消息会被<strong>抛弃</strong>。 </p><h4 id="2-3-2创建队列"><a href="#2-3-2创建队列" class="headerlink" title="2.3.2创建队列"></a>2.3.2创建队列</h4><p>Name:队列的名称</p><p>Durability:是否持久化</p><p>Auto Delete:是否自动删除</p><p><img src="/2019/07/02/RabbitMQ消息中间件/13.png" alt></p><h4 id="2-3-3-代码实现-消息生产者"><a href="#2-3-3-代码实现-消息生产者" class="headerlink" title="2.3.3.代码实现- 消息生产者"></a>2.3.3.代码实现- 消息生产者</h4><p><strong>1.引入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐boot‐starter‐parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>          </span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- rabbitMQ起步依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐boot‐starter‐amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐boot‐starter‐test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>              </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.配置文件信息</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>   </span><br><span class="line"><span class="attr">rabbitmq:</span>     </span><br><span class="line"><span class="attr">host:</span> <span class="number">192.168</span><span class="number">.192</span><span class="number">.129</span></span><br></pre></td></tr></table></figure><p><strong>3.编写启动类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span></span><br><span class="line"><span class="class"></span>&#123;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;         </span><br><span class="line">        SpringApplication.run(Application.class);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.编写测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class) </span><br><span class="line"><span class="meta">@SpringBootTest</span>(classes=Application.class) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSend</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"队列名称"</span>,<span class="string">"我要红包"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-4-代码实现-消息消费者"><a href="#2-3-4-代码实现-消息消费者" class="headerlink" title="2.3.4.代码实现-消息消费者"></a>2.3.4.代码实现-消息消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="meta">@RabbitListener</span>(queues=<span class="string">"itcast"</span> ) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span>     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">(String message)</span></span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"itcast接收到消息："</span>+message);     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-分裂模式（Fanout）"><a href="#2-4-分裂模式（Fanout）" class="headerlink" title="2.4.分裂模式（Fanout）"></a>2.4.分裂模式（Fanout）</h3><h4 id="2-4-1-什么是分裂模式（Fanout）"><a href="#2-4-1-什么是分裂模式（Fanout）" class="headerlink" title="2.4.1.什么是分裂模式（Fanout）"></a>2.4.1.什么是分裂模式（Fanout）</h4><p>消息传递个多个队列的时候就可以采用这种模式</p><p><img src="/2019/07/02/RabbitMQ消息中间件/14.png" alt></p><p>任何发送到Exchange的消息都会转发到绑定到该Exchange的队列中。</p><p>1.可以理解为路由表的模式</p><p>2.这种模式不需要RouteKey</p><p> 3.这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个 Queue，一个Queue可以同多个Exchange进行绑定。（多对多的关系）</p><p>4.如果接受到消息的Exchange没有与任何Queue绑定，则消息会被<strong>抛弃</strong>。 </p><h4 id="2-4-2-交换器绑定队列"><a href="#2-4-2-交换器绑定队列" class="headerlink" title="2.4.2.交换器绑定队列"></a>2.4.2.交换器绑定队列</h4><p><strong>1.创建交换器，类型选择为fanout</strong></p><p><img src="/2019/07/02/RabbitMQ消息中间件/15.png" alt></p><p><strong>2.创建队列</strong></p><p><img src="/2019/07/02/RabbitMQ消息中间件/16.png" alt></p><p><strong>3.交换器绑定队列</strong></p><p>选择对应的交换器，点击进去</p><p><img src="/2019/07/02/RabbitMQ消息中间件/17.png" alt></p><p>填写需要绑定的队列名称</p><p><img src="/2019/07/02/RabbitMQ消息中间件/18.png" alt></p><h4 id="2-4-3-代码实现-消息生产者"><a href="#2-4-3-代码实现-消息生产者" class="headerlink" title="2.4.3.代码实现-消息生产者"></a>2.4.3.代码实现-消息生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendFanout</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"chuanzhi"</span>,<span class="string">""</span>, <span class="string">"分列模式走起"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-4-代码实现-消息消费者"><a href="#2-4-4-代码实现-消息消费者" class="headerlink" title="2.4.4.代码实现-消息消费者"></a>2.4.4.代码实现-消息消费者</h4><p>创建一个类去监听对应的队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="meta">@RabbitListener</span>(queues=<span class="string">"需要监听的队列名称"</span> )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"itheima接收到消息："</span>+message);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-主题模式（Topic）"><a href="#2-5-主题模式（Topic）" class="headerlink" title="2.5.主题模式（Topic）"></a>2.5.主题模式（Topic）</h3><h4 id="2-5-1-什么是主题模式"><a href="#2-5-1-什么是主题模式" class="headerlink" title="2.5.1.什么是主题模式"></a>2.5.1.什么是主题模式</h4><p>任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue 上。可以说是分裂模式一种加强。</p><p><img src="/2019/07/02/RabbitMQ消息中间件/19.png" alt></p><p>在这个模式中出现了匹配规则</p><p>routing key：就是一个匹配队列的规则，可以给每个Exchange绑定的队列设置routing key ,当一个消息经过Exchange的时候，如果使用的是主题模式，会匹配routing key，然后分发到对象的队列中。</p><p>规则：</p><p><strong>.*</strong> 表示匹配一个点后面任意字符  </p><p><strong>.#</strong> 表示匹配一个点后面任意字符（但是这种允许后面有多个 .  例如 abc.ac.exc  能匹配 abc.#   但是不能匹配 abc.*）</p><p>这种模式与前面两种模式差不多，当经过Exchange和routing key的时候，没有可以转发的队列，那么就会丢弃这条消息。</p><h4 id="2-5-2-创建队列与绑定"><a href="#2-5-2-创建队列与绑定" class="headerlink" title="2.5.2.创建队列与绑定"></a>2.5.2.创建队列与绑定</h4><p><strong>1.创建队列，类型选择为topic</strong></p><p><img src="/2019/07/02/RabbitMQ消息中间件/20.png" alt></p><p><strong>2.创建队列</strong></p><p><img src="/2019/07/02/RabbitMQ消息中间件/16.png" alt></p><p><strong>3.绑定队列，并且设置routing key</strong></p><p><img src="/2019/07/02/RabbitMQ消息中间件/21.png" alt></p><h4 id="2-5-3-代码实现-消息生产者"><a href="#2-5-3-代码实现-消息生产者" class="headerlink" title="2.5.3.代码实现-消息生产者"></a>2.5.3.代码实现-消息生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>     </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendTopic1</span><span class="params">()</span></span>&#123;         rabbitTemplate.convertAndSend(<span class="string">"topictest"</span>,<span class="string">"goods.aaa"</span>,<span class="string">"主题模式"</span>);     &#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-4-代码实现-消息消费者"><a href="#2-5-4-代码实现-消息消费者" class="headerlink" title="2.5.4.代码实现-消息消费者"></a>2.5.4.代码实现-消息消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="meta">@RabbitListener</span>(queues=<span class="string">"需要监听的队列名称"</span> )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"itheima接收到消息："</span>+message);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RabbitMQ消息中间件&quot;&gt;&lt;a href=&quot;#RabbitMQ消息中间件&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ消息中间件&quot;&gt;&lt;/a&gt;RabbitMQ消息中间件&lt;/h1&gt;&lt;h2 id=&quot;1-RabbitMQ简介&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="MQ" scheme="https://aaccompany.github.io/categories/MQ/"/>
    
    
      <category term="消息中间件" scheme="https://aaccompany.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
</feed>
