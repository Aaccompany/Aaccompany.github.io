<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://aaccompany.github.io/"/>
  <updated>2020-02-21T05:23:14.288Z</updated>
  <id>https://aaccompany.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Executor框架（第十章）</title>
    <link href="https://aaccompany.github.io/2020/02/13/Executor%E6%A1%86%E6%9E%B6/"/>
    <id>https://aaccompany.github.io/2020/02/13/Executor框架/</id>
    <published>2020-02-12T16:00:00.000Z</published>
    <updated>2020-02-21T05:23:14.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h1><h2 id="1-Executor框架简介"><a href="#1-Executor框架简介" class="headerlink" title="1.Executor框架简介"></a>1.Executor框架简介</h2><h3 id="1-1-Executor框架的两级调度模型"><a href="#1-1-Executor框架的两级调度模型" class="headerlink" title="1.1.Executor框架的两级调度模型"></a>1.1.Executor框架的两级调度模型</h3><p>在<code>HotSpot VM</code>的线程模型中，Java线程（<code>java.lang.Thread</code>)被一对一映射为本地操作系统线程。Java线程启动时会创建一个本地操作系统线程；当该Java线程终止时，这个操作系统线程也会被回收。操作系统会调度所有线程并将他们分配给可用的CPU。</p><p>在上层，Java多线程程序通常将把应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。这两级调度模型为下图</p><p><img src="/2020/02/13/Executor框架/1.jpg" alt></p><p>由上图可以发现，应用程序通过Executor框架控制上层的调度；而下层的调用是由操作系统的内核控制，下层的调用不受应用程序控制</p><h3 id="1-2-Executor框架结构和成员"><a href="#1-2-Executor框架结构和成员" class="headerlink" title="1.2.Executor框架结构和成员"></a>1.2.Executor框架结构和成员</h3><h4 id="1-2-1-Executor框架的结构"><a href="#1-2-1-Executor框架的结构" class="headerlink" title="1.2.1.Executor框架的结构"></a>1.2.1.Executor框架的结构</h4><p>Executor框架结构是由三大部分构成</p><ul><li><p><strong>任务：</strong>需要异步执行的任务，该任务需要实现接口<code>Runnable接口</code>或<code>Callable</code>接口</p></li><li><p><strong>任务的执行：</strong>包括任务执行机制的核心接口为<code>Excutor</code>，以及继承自<code>Excutor</code>的<code>ExcutorService</code>接口。<code>Excutor</code>框架有两个关键类实现了<code>ExecutorService</code>接口（<code>ThreadPoolExecutor</code>和<code>ScheduledThreadPoolExecutor</code>）</p></li><li><p><strong>异步计算的结果：</strong>包括接口<code>Future</code>和实现<code>Future</code>接口的<code>FutureTask</code>类</p></li></ul><h5 id="1-2-1-1-Executor框架中类和接口的简介"><a href="#1-2-1-1-Executor框架中类和接口的简介" class="headerlink" title="1.2.1.1.Executor框架中类和接口的简介"></a>1.2.1.1.Executor框架中类和接口的简介</h5><ul><li><p><code>Executor</code>：是一个接口，它是<code>Executor</code>的框架的基础，它将任务的提交和任务的执行分离</p></li><li><p><code>ThreadPoolExecutor</code>：是<strong>线程池的核心实现类</strong>，用来执行被提交的任务</p></li><li><p><code>ScheduledThreadPoolExecutor</code>：是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。<code>ScheduledThreadPoolExecutor</code>比<code>Timer</code>更加灵活，功能更加强大</p></li><li><p><code>Future</code>接口及其实现类<code>FutureTask</code>：代表着异步计算的结果</p></li><li><p><code>Runnable</code>接口和<code>Callable</code>接口的实现类，都可以被<code>ThreadPoolExecutor</code>或<code>ScheduledThreadPoolExecutor</code>执行</p></li></ul><h5 id="1-2-1-2-Executor框架类图"><a href="#1-2-1-2-Executor框架类图" class="headerlink" title="1.2.1.2.Executor框架类图"></a>1.2.1.2.Executor框架类图</h5><p><img src="/2020/02/13/Executor框架/3.jpg" alt></p><h5 id="1-2-1-3-Executor框架执行图"><a href="#1-2-1-3-Executor框架执行图" class="headerlink" title="1.2.1.3.Executor框架执行图"></a>1.2.1.3.Executor框架执行图</h5><p><img src="/2020/02/13/Executor框架/2.jpg" alt></p><h5 id="1-2-1-4-Executor框架执行流程"><a href="#1-2-1-4-Executor框架执行流程" class="headerlink" title="1.2.1.4.Executor框架执行流程"></a>1.2.1.4.Executor框架执行流程</h5><ul><li>主线程首先要创建实现<code>Runnable</code>或者<code>Callable</code>接口的任务对象。<strong>工具类<code>Executor</code>可以把一个<code>Runnable</code>对象封装为i一个<code>Callable</code>对象（Executors.callable(Runnable task)或者Executors.callable(Runnable task ,Object resule)）</strong></li><li>创建好的<code>Runnable</code>对象直接交给<code>ExecutorService</code>执行（ExecutorService.execute(Runnable command)）；或者也可以把<code>Runnable</code>对象或者<code>Callable</code>对象交给<code>ExecutorService</code>执行（ExecutorService.submit(Runnable task) 或 ExecutorService.submit(Callablle<t> task) ）</t></li><li>如果执行<code>ExecutorService.submit(...)</code>，<code>ExecutorService</code>将返回一个实现<code>Future</code>接口的对象(到目前为止返回都是<code>FutureTask</code>对象)。<strong>由于<code>FutureTask</code>实现了<code>Runnable</code>，所以也可以创建<code>FutureTask</code>，直接交给<code>ExecutorService</code>执行。</strong></li><li>主线程可以将<code>ExecutorService.submit()</code>返回的<code>FutureTask</code>，通过该对象的<code>get()</code>方法来等待线程执行完毕，接受其返回值。主线程也可以执行<code>FutureTask.cancel(boolean mayInterruptIfRunning)</code>来取消该任务的执行。</li></ul><h3 id="1-3-Executor成员"><a href="#1-3-Executor成员" class="headerlink" title="1.3.Executor成员"></a>1.3.Executor成员</h3><p><code>Executor</code>框架主要成员有：<code>ThreadPoolExecutor</code>、<code>ScheduledThreadPoolExecutor</code>、<code>Future接口</code>、<code>Runnable接口</code>、<code>Callable接口</code>和<code>Executors</code></p><h4 id="1-3-1-ThreadPoolExecutor"><a href="#1-3-1-ThreadPoolExecutor" class="headerlink" title="1.3.1.ThreadPoolExecutor"></a>1.3.1.ThreadPoolExecutor</h4><p><code>ThreadPoolExecutor</code>可以使用类<code>Executors</code>来创建线程池<strong>(在阿里巴巴开发手册中，不允许使用该工具类声明线程池)</strong>。<code>Executors</code>工具类可以创建3种类型的<code>ThreadPoolExecutor</code>：<code>FixedThreadPool</code>、<code>singleThreadExecutor</code>和<code>CachedThreadPool</code></p><ul><li><p><strong><code>FixedThreadPool</code>：</strong>使用<code>Executors</code>的静态方法，创建一个<strong>固定大小</strong>的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads,ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure><p><code>FixedThreadPool</code>适用于为了满足资源管理的需求，而需求限制当前线程数量的应用场景，它适用于负载比较重的服务器</p></li></ul><ul><li><p><strong><code>singleThreadExecutor</code>：</strong>使用<code>Executors</code>的静态方法，创建<strong>单个线程</strong>的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadPool</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadPool</span><span class="params">(ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure><p><code>singleThreadPool</code>适用于需要保证顺序地执行各个任务；并且在任意时间点不会有多个线程在活动的应用场景</p></li></ul><ul><li><p><strong><code>CachedThreadPool</code>：</strong>使用<code>Executors</code>的静态方法，创建一个会根据需要创建新线程的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure><p><code>CachedThreadPool</code>是一个大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器</p></li></ul><h4 id="1-3-2-ScheduledThreadPoolExecutor："><a href="#1-3-2-ScheduledThreadPoolExecutor：" class="headerlink" title="1.3.2.ScheduledThreadPoolExecutor："></a>1.3.2.ScheduledThreadPoolExecutor：</h4><p><code>ScheduledThreadPoolExecutor</code>通常由<code>Executos</code>工具类来创建。<code>Executors</code>可以创建2种类型的后台任务线程池<code>ScheduledThreadPoolExecutor</code>，如下</p><ul><li><p><strong><code>ScheduledThreadPoolExecutor</code>：</strong>使用<code>Executors</code>创建<strong>固定大小</strong>的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize,ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure><p><code>ScheduledThreadPooleExecutor</code>适用于需要<strong>多个后台线程执行周期任务</strong>，同时为了满足资源管理的需求而<strong>需要限制后台线程的数量</strong>的场景</p></li></ul><ul><li><p><code>SingleScheduledThreadPoolExecutor</code>：使用<code>Executors</code>创建只有一个线程的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleScheduledThreadPool</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleScheduledThreadPool</span><span class="params">(ThreadFactory threadFactory)</span></span>;</span><br></pre></td></tr></table></figure><p><code>SingleScheduledThreadPooleExecutor</code>适用于<strong>单个后台线程执行周期任务</strong>，同时需要保证任务执行的顺序性</p></li></ul><h4 id="1-3-3-Future接口"><a href="#1-3-3-Future接口" class="headerlink" title="1.3.3.Future接口"></a>1.3.3.Future接口</h4><p><code>Future</code>接口及其实现类<code>FutureTask</code>类用来表示异步计算的结果。当把<code>Runnable</code>接口或<code>Callable</code>接口任务通过<code>submit()</code>方法提交给<code>ThreadPoolExecutor</code>或<code>ScheduledThreadPoolExecutor</code>时，<code>Execotor</code>就会返回一个<code>FutureTask</code>对象。下面时<code>Executor</code>对象的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task,T result)</span></span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure><p>到Java8为止<code>submit()</code>方法返回的对象仍然是<code>FutureTask</code>对象。但是在API中可以发现这些方法返回的都是<code>Future</code>接口，未来可以修改其具体实现，就未必是返回<code>FutureTask</code></p><h4 id="1-3-4-Runnable接口和Callable接口"><a href="#1-3-4-Runnable接口和Callable接口" class="headerlink" title="1.3.4.Runnable接口和Callable接口"></a>1.3.4.<code>Runnable</code>接口和<code>Callable</code>接口</h4><p><code>Runnable</code>接口和<code>Callable</code>接口都可以被<code>ThreadPoolExecutor</code>或<code>ScheduledThreadPoolExecutor</code>所执行。两者的区别是，<code>Runnable</code>在执行后没有返回值；<code>Callable</code>在执行后可以返回其执行结果</p><p>除了可以自己实现一个<code>Callable</code>接口外，还可以使用<code>Executos</code>工具类来把<code>Runnable</code>包装成一个<code>Callable</code>。具体代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单的将Runnable包装成一个Callable对象 -&gt;其返回的Future.get() 为null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Callable&lt;Object&gt; <span class="title">callable</span><span class="params">(Runnable task)</span></span>;</span><br><span class="line"><span class="comment">//将Runnable包装成一个Callable对象，并且给这个Callable一个特殊的返回值(Result) -&gt;其返回的Future.get() 为result</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task,T result)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="1-3-ThreadPoolExecutor详解"><a href="#1-3-ThreadPoolExecutor详解" class="headerlink" title="1.3.ThreadPoolExecutor详解"></a>1.3.ThreadPoolExecutor详解</h3><p> <code>Executor</code>框架最核心的类是<code>ThreadPoolExecutor</code>，它是线程池的具体实现类，主要由4个组件构成</p><ul><li>corePool：核心线程池大小</li><li><code>maximumPool</code>：最大线程池池大小</li><li><code>BlokingQueue</code>：用来暂存任务的工作队列</li><li><code>RejectExecutionHandler</code>：当<code>ThreadPoolExecutor</code>已经关闭或饱和（达到了最大线程池大小且工作队列已满），<code>execute()</code>方法将要调用的<code>Handler</code></li></ul><p>通过使用 <code>Executors</code> 中的静态方法可以创建3种不同类型的线程池（在阿里巴巴开发手册中，不建议使用）</p><ul><li>FixedThreadPool</li><li>SingleThreadPoolExecutor</li><li>CahceThreadPool</li></ul><h4 id="1-3-1-FixedThreadPool"><a href="#1-3-1-FixedThreadPool" class="headerlink" title="1.3.1.FixedThreadPool"></a>1.3.1.FixedThreadPool</h4><p><code>FixedThreadPool</code>：被称之为<strong>可重用固定线程数的线程池</strong>。下面是<code>FixedThreadPool</code>的源代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads,nThreads,</span><br><span class="line">                                  <span class="number">0L</span>,TimeUnit.MILLISSECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlokingQueue&lt;Runnable&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FixedThreadPool</code>的<code>corePool</code>和<code>maximumPoolSize</code>都被设置为创建<code>FixedThreadPool</code>时指定的参数<code>nThreads</code>。</p><p>当线程池中的线程数大于<code>corePool</code>时，<code>keepAliveTime</code>为<strong>多余的空闲线程</strong>等待新任务的最长时间，超过这个时间后多余的线程将会被终止。这里把<code>KeepAliveTime</code>设置为0L则表示出现空闲线程即立即终止。</p><p><strong><code>FixedThreadPool</code>执行流程</strong></p><p><code>FixedThreadPool</code>的<code>execute()</code>方法的运行示意图如下</p><p><img src="/2020/02/13/Executor框架/4.jpg" alt></p><p>执行步骤：</p><ul><li>如果当前线程池的线程数小于<code>corePool</code>则创建新线程来执行该任务</li><li>在线程池预热之后（当前运行线程数等于<code>corePool</code>)，将任务添加进工作队列<code>LinkedBlokingQueue</code>。</li><li>线程执行完任务后，会在循环中从工作队列获取任务来执行</li></ul><p><strong>使用无界队列的影响</strong></p><p><code>FixedThreadPool</code>使用无界阻塞队列<code>LinkedBlokingQueue</code>作为线程池的工作队列(队列的容量为<code>Integer.MAX_VALUE</code>)。使用无界队列回对线程池带来如下影响</p><ul><li>当线程池中线程数到达了<code>corePoolSize</code>后，新任务将进入无界队列中等待，因此线程池的线程数不会超过<code>corePoolSize</code>。</li><li>由于线程池中的线程数不会发生变化，则<code>maximumPoolSize</code>是一个无效参数</li><li>由于线程池中的线程数不会超过<code>corePoolSize</code>则<code>keepAliveTime</code>是一个无效参数</li><li>由于使用无界队列，则不会出现线程池满的情况，所以<code>RejectExecutionHandler</code>是无效参数</li><li>由于不会触发拒绝策略，导致开发者不能即使发现线程池的问题同时也可以对线程池进行参数调整</li></ul><h4 id="1-3-2-SingleThreadExecutor"><a href="#1-3-2-SingleThreadExecutor" class="headerlink" title="1.3.2.SingleThreadExecutor"></a>1.3.2.SingleThreadExecutor</h4><p><code>SingleThreadExecutor</code>是使用单个<code>worker</code>线程的<code>Executor</code>。下面是其源码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorServiice</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0L</span>,TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlokingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SingleThreadExecuot</code>的<code>corePoolSize</code>和<code>maximumPoolSize</code>都为1。而其他参数于<code>FixedThreadPool</code>相同，同样使用的是无界队列<code>LinkedBlokingQueue</code>作为工作队列，所以缺点也一致，不适用于耗时高的任务。</p><p><strong><code>SingleThreadExecutor</code>执行流程</strong></p><p><img src="/2020/02/13/Executor框架/5.jpg" alt></p><p>执行步骤：</p><ul><li>如果线程池中的线程数小于1，则创建新的线程来运行提交的任务</li><li>在线程池预热后（也就是线程池中的线程数为1），则会将任务放进工作队列</li><li>线程在执行完任务后，不断地从工作队列中获取任务并且执行</li></ul><h4 id="1-3-3-CacheThreadPool"><a href="#1-3-3-CacheThreadPool" class="headerlink" title="1.3.3.CacheThreadPool"></a>1.3.3.CacheThreadPool</h4><p><code>CacheThreadPool</code>会根据需要来创建新的线程，下面是其源码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCacheThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>,Integer.MAX_VALUE,<span class="number">60L</span>,TimeUnit.SECONDS,<span class="keyword">new</span> SynchronusQueue&lt;Runnable&gt;())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CacheThreadPool</code>的<code>corePoolSize</code>被设置为了0，即<code>corePool</code>为空；<code>maximumPoolSize</code>被设置为<code>Integer.MAX_VALUE</code>，即<code>maximumPool</code>是无界的。这里把<code>keepAliveTime</code>设置为<code>60L</code>则空闲线程在60秒后会被终止</p><p><code>FixedThreadPool</code>和<code>SingleThreadExecutor</code>使用无界队列<code>LinkedBlokingQueue</code>作为线程池中的工作队列。<code>CacheThreadPool</code>使用没有容量的<code>SynchronousQueue</code>作为工作队列，但<code>CacheThreadPool</code>的<code>maximumPool</code>是无界的。这就意味着，如果主线程提交的任务速度高于<code>maximumPool</code>中的执行速度，<code>CacheThreadPool</code>就会不断地创建线程执行，在极端的情况下，系统会因为不断地创建线程而耗尽<code>CPU</code>和内存资源。</p><p><code>CacheThreadPool</code>的<code>execute()方法</code>的执行示意图如下</p><p><img src="/2020/02/13/Executor框架/6.jpg" alt></p><p>执行步骤：</p><ul><li>首先执行<code>synchronousQueue.offe(task)</code>。如果当前<code>maxmumPool</code>存在空闲线程，那么就会被<code>poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>或获取任务，然后交由这个获取到任务的空闲线程所执行</li><li>当初始的<code>maxmumPool</code>为空，或者<code>maxmumPool</code>中没有空闲线程时，将没有线程执行<code>poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>。在这种情况下，线程池会创建新的线程来执行该任务</li><li>线程在执行完任务后，线程会调用<code>poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>，这个<code>poll</code>操作会让空闲线程最多在<code>SynchronousQueue</code>中等待<code>keepAliveTime</code>秒（也就是60秒）。如果在60秒内有新的任务提交，则会获取到这个任务，并且执行，然后继续等待；如果在60秒内没有新的任务提交，则该空闲线程会被销毁。因此长期空闲的<code>CahceThreadPool</code>不会占用系统资源</li></ul><p><code>SynchronousQueue</code>是一个没有容量的阻塞队列。每个插入操作必须等待另外一个线程的对应移除操作，反之亦然。<code>CacheThreadPool</code>使用了<code>SynchronousQueue</code>，把主线程提交的任务传递给了空闲线程执行。</p><p>下面是<code>CacheThreadPool</code>任务的传递示意图</p><p><img src="/2020/02/13/Executor框架/8.jpg" alt></p><h3 id="1-4-ScheduledThreadPoolExecutor详解"><a href="#1-4-ScheduledThreadPoolExecutor详解" class="headerlink" title="1.4.ScheduledThreadPoolExecutor详解"></a>1.4.ScheduledThreadPoolExecutor详解</h3><p><code>ScheduledThreadPoolExecutor</code>继承了<code>ThreadPoolExecutor</code>。它主要用来给定的延迟之后运行任务，或者定期执行任务。<code>ScheduledThreadPoolExecutor</code>的功能于<code>Timer</code>类似，但<code>ScheduledThreadPoolExecutor</code>功能更加强大、更灵活。<strong><code>Timer</code>对应的是单个后台线程</strong>，而<code>ScheduledThreadPoolExecutor</code>可以在构造函数中指定多个对应的后台线程数</p><h4 id="1-4-1-ScheduledThreadPoolExecutor的运行机制"><a href="#1-4-1-ScheduledThreadPoolExecutor的运行机制" class="headerlink" title="1.4.1.ScheduledThreadPoolExecutor的运行机制"></a>1.4.1.ScheduledThreadPoolExecutor的运行机制</h4><p><code>ScheduledThreadPoolExecutor</code>的执行示意图如下（基于JDK6）</p><p><code>scheduledAtFixedRate()</code>：“以固定的频率”执行，period（周期）指的是<strong>两次成功执行之间的时间</strong>  </p><p><code>scheduledWithFixedDelay</code>： 以固定的延时”执行，delay（延时）指的是<strong>一次执行终止和下一次执行开始之间</strong>的延迟 </p><p><img src="/2020/02/13/Executor框架/9.jpg" alt></p><p><code>DelayQueue</code>是一个无界队列，所以<code>ScheduledThreadPoolExecutor</code>的<code>maximumPoolSize</code>在<code>ScheduledThreadPoolExecutor</code>中没有意义</p><p><code>ScheduledThreadPoolExecutor</code>的执行主要分为两大部分</p><ul><li>当调用<code>ScheduledThreadPoolExecutor</code>的<code>scheduledAtFixedRate()</code>方法或者<code>scheduledWithFixedDelay()</code>方法时，会向<code>ScheduledThreadPoolExecutor</code>的<code>DelayQueue</code>添加一个实现了<code>RunnableScheduledFutur</code>接口的<code>ScheduledFutureTask</code></li><li>线程池中的线程会从<code>DelayQueue</code>中获取<code>ScheduledFutureTask</code>，然后执行任务</li></ul><p><code>ScheduledThreadPoolExecutor</code>为了实现周期性执行任务，对<code>ThreadPoolExecutor</code>做了如下的修改</p><ul><li>使用<code>DelayQueue</code>作为工作队列（<code>DelayQueue</code>是一个<strong>阻塞的无界优先级队列</strong>，新添加进的元素，需要等待一段时间后才能被获取）</li><li>执行任务的方式不同</li><li>执行周期任务后，增加了额外的处理</li></ul><h4 id="1-4-2-ScheduledThreadPoolExecutor的实现"><a href="#1-4-2-ScheduledThreadPoolExecutor的实现" class="headerlink" title="1.4.2.ScheduledThreadPoolExecutor的实现"></a>1.4.2.<code>ScheduledThreadPoolExecutor</code>的实现</h4><p><code>ScheduledThreadPoolExecutor</code>会把待调度任务<code>ScheduledFutureTask</code>放到一个<code>DelayQueue</code>中</p><p><code>ScheduledFutureTask</code>主要包含3个成员变量，如下。</p><ul><li>long型成员变量<code>time</code>：表示这个任务将要<strong>被执行的具体时间</strong></li><li>long型成员变量<code>sequenceNumber</code>：表示这个任务被添加到线程池中的<strong>序号</strong></li><li>long型成员变量<code>period</code>：表示任务执行的<strong>间隔周期</strong></li></ul><p><code>DelayQueue</code>封装了一个<code>PriorityQueue</code>，这个<code>PriorityQueue</code>会对队列中的<code>ScheduledFutureTask</code>进行排序。</p><p>排序时，<code>time</code>小的排前面，如果<code>time</code>一致，则<code>period</code>值小的排前面（也就是说，两个任务的执行时间相同，那么优先执行先提交的任务）</p><p><strong>下图是<code>ScheduledThreadPoolExecutor</code>中线程执行周期任务的过程</strong></p><p><img src="/2020/02/13/Executor框架/10.jpg" alt></p><p><strong>执行步骤：</strong></p><ul><li>线程1从<code>Delay</code>获取已经到期的<code>ScheduledFutureTask(DelayQueue.take())</code>。到期任务是指<code>ScheduledFutureTask</code>的<code>time</code>大于等于当前时间。</li><li>线程1执行这个<code>ScheduledFutureTask</code></li><li>线程1修改<code>ScheduledFutureTask</code>的<code>time</code>变量为下次将要被执行的时间</li><li>线程1将修改<code>time</code>后的<code>ScheduledFutureTask</code>放回<code>DelayQueue</code>中<code>DelayQueue.add()</code></li></ul><h4 id="1-4-3-DelayQueue代码分析："><a href="#1-4-3-DelayQueue代码分析：" class="headerlink" title="1.4.3.DelayQueue代码分析："></a>1.4.3.DelayQueue代码分析：</h4><h5 id="1-4-3-1-DelayQueue中获取任务的方法Delay-take"><a href="#1-4-3-1-DelayQueue中获取任务的方法Delay-take" class="headerlink" title="1.4.3.1.DelayQueue中获取任务的方法Delay.take()"></a>1.4.3.1.DelayQueue中获取任务的方法Delay.take()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    lock.lockInterruptedException();<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            <span class="comment">//q是DelayedWorkQueue类中一个ScheduledFutureTask优先级队列</span></span><br><span class="line">            <span class="comment">//获取数组的中第一个元素</span></span><br><span class="line">E first = q.peek();</span><br><span class="line">             <span class="keyword">if</span>(first==<span class="keyword">null</span>)&#123;</span><br><span class="line">                 <span class="comment">//available是DelayedWorkQueue类中的Condition对象</span></span><br><span class="line">                 <span class="comment">//如果为空则等待</span></span><br><span class="line">                 available.await();<span class="comment">//2.1</span></span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="keyword">long</span> delay = fitst.getDealy(TimeUnit.NANOSECONDS);</span><br><span class="line">                 <span class="comment">//如果周期任务时间大于当前时间，则线程等待</span></span><br><span class="line">                 <span class="keyword">if</span>(delay&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                     <span class="keyword">long</span> t1 = availiable.awaitNanos(delay);<span class="comment">//2.2</span></span><br><span class="line">                 &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     E x = q.poll();<span class="comment">//2.3.1</span></span><br><span class="line">                     <span class="keyword">assert</span> x !=<span class="keyword">null</span>;</span><br><span class="line">                     <span class="comment">//如果优先级队列中，仍然存在元素，则唤起其它线程</span></span><br><span class="line">                     <span class="keyword">if</span>(q.size !=<span class="number">0</span>)&#123;</span><br><span class="line">                         available.signalAll();<span class="comment">//2.3.2</span></span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">return</span> x;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock();<span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>流程图：</strong></p><p><img src="/2020/02/13/Executor框架/11.jpg" alt></p><p><strong>执行步骤：</strong></p><ul><li>获取Lock (上图 1)</li><li>获取周期任务<ul><li>如果周期任务为空，当线程到<code>Condition</code>等待 （上图 2.1）</li><li>如果周期任务的时间大于当前时间，则线程到<code>Condition</code>等待到<code>time</code>的时间 （上图 2.2）</li><li>获取<code>PriorityQueue</code>的头元素；如果<code>PriorityQueue</code>不为空，则唤醒在<code>Condition</code>中等待的所有线程 （上图 2.3.1-2.3.2）</li></ul></li><li>释放Lock （上图 3）</li></ul><p><code>ScheduledThreadPoolExecutor</code>在一个循环中获取周期任务，直到线程从<code>PriorityQueue</code>获取到一个元素后才会退出循环（类型于CAS同步代码）</p><h5 id="1-4-3-2-DelayQueue中获取任务的方法Delay-add"><a href="#1-4-3-2-DelayQueue中获取任务的方法Delay-add" class="headerlink" title="1.4.3.2.DelayQueue中获取任务的方法Delay.add()"></a>1.4.3.2.DelayQueue中获取任务的方法Delay.add()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        E first = q.peek();</span><br><span class="line">        q.offer(e);<span class="comment">//2.1</span></span><br><span class="line">        <span class="keyword">if</span>(first == <span class="keyword">null</span> || e.compareTo(first) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="comment">//唤醒全部线程的原因是 因为其他线程因为优先级队列为空而陷入等待</span></span><br><span class="line">            <span class="comment">//需要唤醒这部分线程</span></span><br><span class="line">            availale.signalAll();<span class="comment">//2.2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">final</span>&#123;</span><br><span class="line">        lock.unlock();<span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>流程图：</strong></p><p><img src="/2020/02/13/Executor框架/12.jpg" alt></p><p><strong>执行步骤：</strong></p><ul><li>获取Lock</li><li>添加任务<ul><li>向<code>PriorityQueue</code>添加任务</li><li>如果添加的任务是<code>PriorityQueue</code>的头元素，唤醒在<code>Condition</code>中等待的所有线程</li></ul></li><li>释放Lock</li></ul><h3 id="1-5-FutureTask详解"><a href="#1-5-FutureTask详解" class="headerlink" title="1.5.FutureTask详解"></a>1.5.FutureTask详解</h3><p><code>Future</code>接口和实现<code>Future</code>接口的<code>FutureTask</code>类，代表异步计算的结果</p><h4 id="1-5-1-FutureTask简介"><a href="#1-5-1-FutureTask简介" class="headerlink" title="1.5.1.FutureTask简介"></a>1.5.1.FutureTask简介</h4><p><code>FutureTask</code>除了实现了<code>Future</code>接口外，还实现了<code>Runnable</code>接口。因此，<code>FutureTask</code>可以交给<code>Executor</code>执行，也可以由<strong>调用线程直接执行</strong><code>FutureTask.run</code>。根据<code>FutureTask.run()</code>方法被执行的时机，<code>FutureTask</code>可以处于下面3种状态</p><ul><li>未启动。<code>FutureTask.run()</code>方法在还<strong>没有被执行之前</strong>，<code>FutureTask</code>处于未启动状态。当创建一个<code>FutureTask</code>，且没有执行<code>FutureTask.run()</code>方法之前，这个<code>Future</code>处于未启动状态</li><li>已启动。<code>FutureTask.run()</code>方法被执行的<strong>过程中</strong>，<code>FutureTask</code>处于已启动的状态</li><li>已完成。<code>FutureTask.run()</code>方法被<strong>正常执行结束</strong>，或被<strong>取消</strong><code>FutureTask.cancel(...)</code>，或执行<code>FutureTask.run()</code>方法时<strong>抛出异常</strong>而异常结束，<code>FutureTask</code>处于已完成状态</li></ul><p><strong>下图为<code>FutureTask</code>的状态迁移的示意图</strong></p><p><img src="/2020/02/13/Executor框架/13.jpg" alt></p><p><strong><code>FutureTask.get()</code>执行情况</strong></p><p>当<code>FutureTask</code>处于未启动或已启动状态时，执行<code>FutureTask.get()</code>方法会导致调用线程阻塞；</p><p>当<code>FutureTask</code>处于已完成状态时，执行<code>FutureTask.get()</code>方法将导致调用线程立即返回结果或抛出异常</p><p><strong><code>FutureTask.cannel()</code>执行情况</strong></p><p>当<code>FutureTask</code>处于未启动状态时，执行<code>FutureTask.cancel()</code>方法将导致此任务永远不会被执行</p><p>当<code>FutureTask</code>处于已启动状态时，执行<code>FutureTask.cancel(true)</code>方法将<strong>以中断执行此任务线程的方式来试图停止任务</strong></p><p>当<code>FutureTask</code>处于已启动状态时，执行<code>FutureTask.cancel(false)</code>方法不会对正在执行该任务的线程产生影响</p><p>当<code>FutureTask</code>处于已完成状态时，执行<code>FutureTask.cancel(...)</code>方法返回false</p><p><strong><code>FutureTask.get()/FutureTask.cancel()</code>方法执行示意图</strong></p><p><img src="/2020/02/13/Executor框架/14.jpg" alt></p><h4 id="1-5-2-FutureTask的使用"><a href="#1-5-2-FutureTask的使用" class="headerlink" title="1.5.2.FutureTask的使用"></a>1.5.2.FutureTask的使用</h4><ul><li>可以交由<code>Executor</code>执行</li><li>可以通过<code>ExecutorService.submit()</code>返回一个<code>FutureTask</code>，然后可以执行<code>FutureTask.get()</code>方法或者<code>FutureTask.cancel(..)</code></li><li>可以在当前线程单独使用</li></ul><p>当一个线程需要等待另一个线程把某个任务执行完之后才能继续执行，此时可以使用<code>FutureTask</code>。假设有多个线程执行若干个任务，<strong>每个任务最多只能执行一次</strong>。当多个线程同时执行同一个任务的时，只允许一个线程执行任务，其余线程需要等待这个任务执行完之后才能继续执行。下面时对应的实例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Object, Future&lt;String&gt;&gt; taskCache =</span><br><span class="line">            <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">executionTask</span><span class="params">(<span class="keyword">final</span> String taskName)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//获取任务</span></span><br><span class="line">            Future&lt;String&gt; future = taskCache.get(taskName);</span><br><span class="line">            <span class="comment">//如果任务是空的话就创建任务</span></span><br><span class="line">            <span class="keyword">if</span> (future==<span class="keyword">null</span>)&#123;</span><br><span class="line">                Callable&lt;String&gt; task = ()-&gt; &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"线程run()执行完毕"</span>);</span><br><span class="line">                    <span class="keyword">return</span> taskName;</span><br><span class="line">                &#125; ;</span><br><span class="line">                FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(task);</span><br><span class="line">                <span class="comment">//如果缓存中存在值，就不替换，并且返回对应Key的值</span></span><br><span class="line">                <span class="comment">//这个会发生的原因是多线程环境下的不安全性</span></span><br><span class="line">                future = taskCache.putIfAbsent(taskName,futureTask);</span><br><span class="line">                <span class="comment">//当没有线程执行过的时候执行任务</span></span><br><span class="line">                <span class="keyword">if</span> (future==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    future = futureTask;</span><br><span class="line">                    futureTask.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"获取返回结果"</span>);</span><br><span class="line">                String result = future.get();</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"线程返回"</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">                taskCache.remove(taskName,future);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService  = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>,<span class="number">2</span>,<span class="number">0L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>));</span><br><span class="line">        Demo2 demo2 = <span class="keyword">new</span> Demo2();</span><br><span class="line">        String taskName = <span class="string">"abc"</span>;</span><br><span class="line">        <span class="comment">//提交同一个任务</span></span><br><span class="line">        Callable&lt;String&gt; callable = ()-&gt;demo2.executionTask(taskName);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            Future&lt;String&gt; future = executorService.submit(callable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-3-FutureTask的实现"><a href="#1-5-3-FutureTask的实现" class="headerlink" title="1.5.3.FutureTask的实现"></a>1.5.3.FutureTask的实现</h4><p><code>FutureTask</code>的实现基于<code>AbstractQueueSynchronizer</code>也就是<code>AQS</code>。<code>java.util.concurrent</code>中存在很多可阻塞类(比如<code>ReentrantLock</code>)都是基于<code>AQS</code>实现的。<code>AQS</code>是一个同步框架，它提供机制来原子性管理同步状态、阻塞和唤醒线程、以及维护被阻塞线程的队列。<code>JDK6</code>中<code>AQS</code>被广泛使用，基于<code>AQS</code>实现的同步器包括<code>ReentrantLock</code>、<code>Semaphore</code>、<code>ReentrantReadWriteLock</code>、<code>CountDownLatch</code>和<code>FutureTask</code></p><p>每一个基于<code>AQS</code>实现的同步器都会包含两种类型的操作，如下</p><ul><li>至少一个<code>acquire</code>操作。这个操作会阻塞条哦那个线程，除非/直到<code>AQS</code>的状态允许这个线程继续执行。<code>FutureTask</code>的<code>acquire</code>操作为<code>get()/get(long timeout,TimeUnit unit)</code>方法调用。</li><li>至少一个<code>release</code>操作。这个操作会改变<code>AQS</code>的状态，改变后的状态可允许一个或多个阻塞线程被解除阻塞。<code>FutureTask</code>的<code>release</code>操作包括<code>run()</code>方法和<code>cancel(..)</code>方法</li></ul><p>基于<code>复合优先于继承</code>的原则，<code>FutureTask</code>声明了一个内部私有的继承于<code>AQS</code>的子类<code>Sync</code>，对<code>FutureTask</code>所有公共方法的调用都会就这个子类</p><p><code>AQS</code>被作为<code>模板方法模式</code>的基础类提供给<code>FutureTask</code>的内部子类<code>Sync</code>，这个内部子类只需要实现状态检查和状态更新的方法即可，这些方法将控制<code>FutureTask</code>的获取和释放操作。具体来说<code>Sync</code>实现了<code>AQS</code>的<code>tryAcquireShared(int)</code>方法和<code>tryReleaseShared(int)</code>方法，<code>Sync</code>通过着两个方法来检查和更新同步状态</p><p><strong><code>FutureTask.get()</code>方法会调用<code>AQS.acquireSharedInterrupted(int arg)</code>方法，这个方法的执行过程如下</strong></p><ul><li>调用<code>AQS.acquireSharedInterrupted(int arg)</code>方法，这个方法首先会回调在子类<code>Sync</code>中实现的<code>tryAcquireShare()</code>方法来判断<code>acquire</code>操作是否可以成功。<strong><code>acquire</code>操作可以成功的条件：state为执行完成状态RAN或已取消状态CANCELED，且runner不为null</strong></li><li>如果成功则<code>get()</code>方法将立即返回。如果失败则线程加入到等待队列中去等待其他线程执行<code>release操作</code></li><li>当其他线程执行<code>release</code>操作（比如<code>FutureTask.run()</code>或<code>FutureTask.cancel(..)</code>)唤醒当前线程后，当线程线程再次执行<code>tryAcquireShare()</code>将返回正值1，<strong>当前线程将离开线程等待队列并且唤醒它的后继线程（这里会产生级联唤醒的效果）</strong></li><li>最后返回计算的结果或抛出异常</li></ul><p><strong><code>FutureTask.run()</code>方法执行过程</strong></p><ul><li>判断任务是否已经执行和原子方式来更新执行任务线程(调用<code>UNSAFE.compareAndSwapObject(this, runnerOffset,                             null, Thread.currentThread())</code>)</li><li>如果上述成功则执行在构造函数中执行的任务</li><li>以原子方式来更新同步状态（调用<code>AQS.compareAndSetState(int expect,int update)</code>设置state为执行完成状态RAN)。如果这个操作成功，就设置表达计算结果的变量<code>result</code>为<code>Callable.call()</code>的返回值，然后调用<code>AQS.release(int arg)</code></li><li><code>AQS.release(int arg)</code>首先会回调在子类<code>Sync</code>中实现的<code>tryReleaseShared(arg)</code>来执行<code>release</code>（设置运行任务的线程<code>runner</code>为null，然后返回false);<code>AQS.releaseShared(int arg)</code>，然后回唤醒线程等待队列中的第一个线程</li></ul><p><strong><code>FutureTask.done()</code>方法执行过程</strong></p><p>当执行<code>Future.get()</code>方法时，如果<code>FutureTask</code>不是处于执行完成状态RAN或已取消ANCELED，当前执行线程将到<code>AQS</code>的线程等待队列中等待。当某个线程执行<code>FutureTask.run()</code>方法或者<code>FutureTask.cancel(...)</code>方法时，会唤醒线程等待队列的第一个线程</p><p><img src="/2020/02/13/Executor框架/15.jpg" alt></p><p>假设开始时<code>FutureTask</code>处于未启动状态或已启动状态，等待队列中已经有3个线程（A、B、C）在等待，此时线程D执行<code>get()</code>方法将导致线程D也到等待队列中去等待</p><p>当线程E执行<code>run()</code>方法时，会唤醒队列中的第一个线程A。线程A被唤醒后，首先把自己从队列中删除，然后唤醒它的后继节点B，最后线程A从<code>get()</code>方法中返回。线程B、C和D重复A的过程。最终所有在队列中等待的线程都将被级联唤醒并且从<code>get()</code>方法返回</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Executor框架&quot;&gt;&lt;a href=&quot;#Executor框架&quot; class=&quot;headerlink&quot; title=&quot;Executor框架&quot;&gt;&lt;/a&gt;Executor框架&lt;/h1&gt;&lt;h2 id=&quot;1-Executor框架简介&quot;&gt;&lt;a href=&quot;#1-Execu
      
    
    </summary>
    
      <category term="多线程编程系列" scheme="https://aaccompany.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="多线程编程" scheme="https://aaccompany.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java中的线程池（第九章）</title>
    <link href="https://aaccompany.github.io/2020/02/12/Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://aaccompany.github.io/2020/02/12/Java中的线程池/</id>
    <published>2020-02-11T16:00:00.000Z</published>
    <updated>2020-02-12T10:34:29.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中的线程池"><a href="#Java中的线程池" class="headerlink" title="Java中的线程池"></a>Java中的线程池</h1><h2 id="1-线程池好处"><a href="#1-线程池好处" class="headerlink" title="1.线程池好处"></a>1.线程池好处</h2><p>Java线程池是运用场景最多的并发框架，几乎所有的<strong>需要异步或并发执行任务的程序</strong>都可以使用<strong>线程池</strong>。在开发过程中，合理使用线程池能够带来3个好处</p><ul><li><strong>降低资源消耗：</strong>通过重复利用已创建的线程，降低<strong>线程创建</strong>和<strong>线程销毁</strong>造成的消耗</li><li><strong>提高响应速度：</strong>当任务到达时，可以直接用线程池的空余线程执行，不需要等到线程创建再执行</li><li><strong>提高线程的管理性：</strong>线程在系统中是稀缺资源，如果无限制的创建线程，不仅会消耗系统资源，还会降低系统的可用性，使用线程池可以进行统一分配、调优和监控</li></ul><h2 id="2-线程池的实现原理"><a href="#2-线程池的实现原理" class="headerlink" title="2.线程池的实现原理"></a>2.线程池的实现原理</h2><p><strong>步骤1：</strong>如果当前运行线程少于<code>corePoolSize</code>，则创建新线程来执行任务<strong>（注意，执行这步骤需要获取全局锁）</strong></p><p><strong>步骤2：</strong>如果运行的线程等于或多余<code>corePoolSize</code>，则将任务加入到<code>BlockingQueue</code>(阻塞队列)</p><p><strong>步骤3：</strong>如果无法将任务加入<code>BlokingQueue</code>，则创建新的线程来处理任务<strong>（注意，执行这一步骤需要获取全局锁）</strong>也就是说，创建大于<code>corePoolSize</code>数量的线程，需要线程池线程等于<code>corePoolSize</code>和队列为满</p><p><strong>步骤4：</strong>如果不断通过步骤3创建线程数大于<code>maxmumPoolSize</code>，将执行拒绝策略，也就是会调用<code>RejectedExecutionHandler.rejectExecution()方法</code></p><p><img src="/2020/02/12/Java中的线程池/1.jpg" alt></p><p><code>ThreadPoolExecutor</code>采取上述步骤的总体设计思路，是为了在执行<code>execute()</code>方法时，尽可能地避免获取全局锁（那将会时 一个严重的可伸缩瓶颈）。在<code>ThreadPoolExecutor</code>完成预热后（预热：也就是当前运行线程数大于等于<code>corePoolSize</code>)，几乎所有的<code>execute()</code>方法都是执行步骤2，而步骤2不需要获取全局锁</p><h3 id="2-1-线程池执行源码分析"><a href="#2-1-线程池执行源码分析" class="headerlink" title="2.1.线程池执行源码分析"></a>2.1.线程池执行源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程池中的执行任务的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(command==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 如果当前线程数小于基本线程数 ，则创建线程并且执行任务</span></span><br><span class="line">    <span class="keyword">if</span>(poolSize&gt;=corePoolSize || !addIfUnderCorePoolSize(command))&#123;</span><br><span class="line">        <span class="comment">//如果创建新线程失败的话，线程池状态为RUNNING 则任务加入到工作队列中去</span></span><br><span class="line">        <span class="keyword">if</span>(runState==RUNNING &amp;&amp; workQueue.offer(command))&#123;</span><br><span class="line">            <span class="comment">//如果处于停止状态，并且线程数量等于0</span></span><br><span class="line">            <span class="keyword">if</span>(runState!=RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//确保处于队列的任务执行</span></span><br><span class="line">            ensureQueueTaskHandled(command);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上面执行完毕，说明线程池处于预热后的状态</span></span><br><span class="line">        <span class="comment">//如果线程池不处于运行中或任务无法放进队列，并且当前线程数量小于最大允许的线程数量</span></span><br><span class="line">        <span class="comment">//则创建一个线程执行任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!addIfUnderMaximumPoolSize(command))</span><br><span class="line">            <span class="comment">//抛出RejectedExecutionException异常</span></span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工作线程：</strong>线程池创建线程时，会将线程封装成工作线程 <code>Worker</code>,<code>Worker</code>在执行完任务后，还会循环获取工作队列里来继续工作。下面为<code>Worker</code>中的<code>run</code>方法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Runnable task = firstTask;</span><br><span class="line">        firstTask = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(task !=<span class="keyword">null</span> || (task=getTask()) !=<span class="keyword">null</span> )&#123;</span><br><span class="line">            runTask(task);</span><br><span class="line">            task = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        workerDone(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-ThreadPoolExecutor执行任务流程"><a href="#2-2-ThreadPoolExecutor执行任务流程" class="headerlink" title="2.2. ThreadPoolExecutor执行任务流程"></a>2.2. <code>ThreadPoolExecutor</code>执行任务流程</h3><p><strong>步骤1：</strong>在<code>execute</code>方法中创建一个线程时，会用这个线程执行这个任务</p><p><strong>步骤2：</strong>这个线程在执行完任务后，会重复从队列中获取任务并且执行</p><p><img src="/2020/02/12/Java中的线程池/2.jpg" alt></p><h2 id="3-线程池的使用"><a href="#3-线程池的使用" class="headerlink" title="3.线程池的使用"></a>3.线程池的使用</h2><h3 id="3-1-线程池的创建"><a href="#3-1-线程池的创建" class="headerlink" title="3.1.线程池的创建"></a>3.1.线程池的创建</h3><p>通过<code>ThreadPoolExecutor</code>来创建线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><p><strong>参数说明</strong></p><ul><li><p><strong><code>corePoolSize</code>：</strong>线程池基础大小，当一个任务提交到线程池的时候，线程池会创建一个线程来执行任务，即使线程池中存在空闲线程也会创建线程来执行任务，等到需要执行的任务数大于线程池的基本大小时就会不会继续创建，而是加入到队列中等待消费。</p><p>如果提前调用线程池的<code>prestartAllCoreThreads()</code>方法，线程池会提前创建好线程并且启动所有基本线程</p></li><li><p><strong><code>maximumPoolSize</code>：</strong>线程池的最大值，当队列满的时，再提交队列则会创建新的线程，然后执行任务，最大创建线程数会到达<code>maximumPoolSize</code>值</p></li><li><p><strong><code>keepAliveTime</code>：</strong>线程池的工作线程空闲时，保存存活的最长时间。如果任务量大，但是任务执行时间短，可以提高这个值，提高线程的利用率。</p></li><li><p><strong><code>unit</code>：</strong>时间单位，用于解释<code>keepAliveTime</code>的时间单位</p></li><li><p><strong><code>workQueue</code>：</strong>工作队列（使用阻塞队列），负责存储等待的任务阻塞队列，可以选择以下的阻塞队列</p><ul><li><strong><code>ArrayBlokingQueue</code>：</strong>是一个<strong>基于数组结构</strong>有界阻塞队列，此队列按FIFO（先进先出）原则对元素进读取</li><li><strong><code>LinkedBlokingQueue</code>：</strong>是一个<strong>基于链表结构</strong>有界阻塞队列，此队列按FIFO（先进先出）原子对元素进行读取，<strong>吞吐量会大于<code>ArrayBlokingQueue</code></strong>，静态工厂方法<code>Executor.newFixedThreadPool()</code>使用的就是这个阻塞队列</li><li><strong><code>SysnchronizedQueue</code>：</strong>一个不存储元素的阻塞队列。每个插入操作必须等待另外一个线程执行移除操作，否则插入操作将一直阻塞，<strong>吞吐量通常会大于<code>LinkedBlokingQueue</code></strong>，静态工厂方法<code>Executor.newCachedThreadPool</code>使用了该队列</li><li><strong><code>PriorityBlokingQueue</code>：</strong>一个具有优先级的无界阻塞队列</li></ul></li><li><p><strong><code>threadFactory</code>：</strong>用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架<code>guava</code>提供的<code>ThreadFactorBuilder</code>可以快速给线程池里的线程设置有意义的名字，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadFactorBuilder().setNameFormart(<span class="string">"XX-task-%d"</span>).build();</span><br></pre></td></tr></table></figure></li><li><p><strong><code>handler</code>：</strong>饱和策略，当队列和线程都满了，说明线程池处于饱和状态，那么将必须采取一个策略处理新的提交的任务。<strong>线程池策略默认情况下为<code>AbortPolicy</code></strong>，表示无法处理的时候将抛出异常。在<code>JDK5</code>中 Java线程池提供以下策略</p><ul><li><strong><code>AbortPolicy</code>：</strong>直接抛出异常</li><li><strong><code>CallerRunsPolicy</code>：</strong>只用调用者所在线程来运行任务</li><li><strong><code>DiscardOldestPolicy</code>：</strong>丢弃队列里最近的一个任务，并且执行当前任务</li><li><strong><code>DiscardPolicy</code>：</strong>不处理，丢弃掉当前任务</li></ul></li></ul><h3 id="3-2-向线程池提交任务"><a href="#3-2-向线程池提交任务" class="headerlink" title="3.2.向线程池提交任务"></a>3.2.向线程池提交任务</h3><p>线程池存在两个方法用来提交任务，分别是<code>execute()</code>和<code>submit()</code>方法</p><p>execute()方法用于提交不需要接受其返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可以发现执行的任务对象时Runnable类的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">threadsPool.execute(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>submit()方法用于提交有返回值的任务。线程池会返回一个<code>Future</code>类型的对象，通过这<code>Future</code>对象可以判断对象是否执行成功，并且通过<code>future</code>的<code>get()</code>方法来获取线程的返回值，<code>get()</code>方法会阻塞当前线程直到任务执行完成，而使用<code>get(long timeout,TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回，有时候这个线程还没有执行完毕。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(harReturnValueTask);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Object s = future.get();</span><br><span class="line">&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">    <span class="comment">//处理中断异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ExecutionException e)&#123;</span><br><span class="line">    <span class="comment">//处理无法执行的异常</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//关闭线程池</span></span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-关闭线程池"><a href="#3-3-关闭线程池" class="headerlink" title="3.3.关闭线程池"></a>3.3.关闭线程池</h3><p>可以使用<code>shutdwon()</code>和<code>shutdownNow()</code>方法来关闭线程池。</p><p>他们的原理是遍历线程池中所有工作线程，然后逐个调用线程的<code>interrupt()</code>方法来中断线程，所以无法响应中断任务将可能永远无法终止。</p><p><strong><code>shutdownNow()</code>：</strong>首先将线程池的状态设置为<code>STOP</code>，然后尝试<strong>停止所有的正在执行或暂停任务的线程</strong>，并<strong>返回等待执行执行任务列表</strong></p><p><strong><code>shutdown()</code>：</strong>将线程池状态设置为<code>SHUTDOWN</code>，然后<strong>中断所有没有正在执行任务的线程</strong></p><p>只要调用这两个方法中的任意一个，<code>isShutdown()</code>方法就会返回<code>true</code>。当所有任务都已经关闭后，才表示线程池关闭成功，这时候调用<code>isTerminaed()</code>方法就会返回<code>true</code></p><p>通常使用<code>shutdown</code>方法来停止线程池，如果不需要等待任务执行完毕的话，可以调用<code>shutdownNow()</code>方法来停止线程</p><h3 id="3-4-合理地配置线程池"><a href="#3-4-合理地配置线程池" class="headerlink" title="3.4.合理地配置线程池"></a>3.4.合理地配置线程池</h3><p>要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。</p><ul><li>任务的性质：CPU密集任务、IO密集型任务和混合型任务</li><li>任务的优先级：高、中和低</li><li>任务的执行时间：长、中和短</li><li>任务的依赖性：是否依赖其他系统资源，如数据库连接</li></ul><h4 id="3-4-1-根据不同任务性质配置线程池"><a href="#3-4-1-根据不同任务性质配置线程池" class="headerlink" title="3.4.1.根据不同任务性质配置线程池"></a>3.4.1.根据不同任务性质配置线程池</h4><p><strong>性质不同的任务</strong>可以用不同规模的线程池分开处理。</p><p><strong>CPU密集型任务：</strong>应分配尽可能小的线程，如配置<code>N(CPU)+1</code>个线程的线程池，这样可以避免大量的线程上下文切换</p><p><strong>IO密集型任务：</strong>这类型并非一直在执行任务，可能在等待IO，这种任务就需要配置尽可能多的线程，如配置<code>2*N(CPU)</code></p><p><strong>混合型任务：</strong>如果任务可以拆分，则将其拆分为CPU密集型任务和IO密集型任务，只要这两个任务执行的时间相差并不大，那么分解后交友不同的线程池执行，那么在分解后执行的吞吐量将高于串行执行的吞吐量。但是如果拆分后两个小任务的执行时间相差很大的话就不适合采用这种模式，因为一个小任务等待另外一个小任务会消耗大量时间</p><blockquote><p>可以通过<code>Runtime.getRuntime().availableProcessors()</code>来获取当前设置的CPU个数</p></blockquote><p><strong>优先级不同的任务</strong>可以使用优先级队列<code>PriorityBlokingQueue</code>来处理，它可以让高优先级的任务先执行，但是低优先级的任务可能将永远不能执行</p><p><strong>执行时间不同的任务</strong>可以交给不同规模的线程池来执行，或者使用优先级队列，优先执行执行时间短的任务</p><p><strong>依赖数据库连接的任务</strong>因为线程在提交<code>SQL</code>后需要等待数据库返回结果，等待的时间越长，则CPU的空闲时间越长，那么针对这种任务可以适当的提高线程池的数量，这样就能更好的利用CPU资源</p><h4 id="3-4-2-使用有界队列"><a href="#3-4-2-使用有界队列" class="headerlink" title="3.4.2.使用有界队列"></a>3.4.2.使用有界队列</h4><p>使用有界队列能够增加系统稳定性和预警能力，可以根据需要设置大一点，比如几千。</p><p>案例：在后台系统任务线程池队列和线程都满了，不断抛出抛弃任务的异常，通过排查发现是数据库出现问题，导致执行<code>SQL</code>变得非常缓慢，因为后台任务线程池中全都是需要向数据库插入数据和查询数据，所以导致线程池里的工作线程全部阻塞，任务会挤压在线程池里。如果设置为无界队列的话，队列会不断的膨胀，最后会导致内存爆炸，导致整个系统不可用，而不只是后台任务出问题。</p><h3 id="3-5-线程池的监控"><a href="#3-5-线程池的监控" class="headerlink" title="3.5.线程池的监控"></a>3.5.线程池的监控</h3><p>如果系统中使用了大量的线程池，则十分有必要对线程池进行监控，方便在出现问题的时候根据线程池的状况快速定位问题。而我们可以使用线程池提供的参数进行监控，在监控线程池的时候可以使用以下的属性</p><ul><li><strong><code>taskCount</code>：</strong>线程池需要执行的任务的数量</li><li><strong><code>completedTaskCount</code>：</strong>线程池在运行过程中已完成的任务数量，小于或等于<code>taskCount</code></li><li><strong><code>largeestPoolSize</code>：</strong>线程池里曾经创建过的最大线程数，通过这个数字<strong>可以判断线程池是否满过</strong>。如果这个数值等于线程池的最大值，则表示线程池曾经满过。</li><li><strong><code>getPoolSize</code>：</strong>线程池的线程数量。如果线程池不销毁话，线程池里的线程不会销毁，所以这个大小自增不减</li><li><strong><code>getActiveCount</code>：</strong>获取活动的线程数</li></ul><h2 id="4-手写一个线程池"><a href="#4-手写一个线程池" class="headerlink" title="4.手写一个线程池"></a>4.手写一个线程池</h2><p>由上面的知识可以大致的写出下面的简单线程池实现</p><h3 id="4-1-线程池接口"><a href="#4-1-线程池接口" class="headerlink" title="4.1.线程池接口"></a>4.1.线程池接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="comment">//执行一个任务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">    <span class="comment">//关闭线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//增加工作线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWorker</span><span class="params">(<span class="keyword">int</span> mun)</span></span>;</span><br><span class="line">    <span class="comment">//移除工作线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> mun)</span></span>;</span><br><span class="line">    <span class="comment">//获取正在工作的线程数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池中的全部线程大小</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPoolSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-线程池的实现类"><a href="#4-2-线程池的实现类" class="headerlink" title="4.2.线程池的实现类"></a>4.2.线程池的实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> <span class="keyword">implements</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolTest</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        workerQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        addWorker(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储任务队列</span></span><br><span class="line"><span class="comment">     * 线程安全</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    LinkedBlockingQueue&lt;Runnable&gt; workerQueue;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储工作线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Worker&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable command;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> runState;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String name, <span class="keyword">int</span> runState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">            <span class="keyword">this</span>.runState = runState;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; (command = getWork()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    setState(<span class="number">1</span>);</span><br><span class="line">                    command.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    setState(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Runnable <span class="title">getWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Runnable work = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                work = workerQueue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程响应中断===》停止获取任务"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> work;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取工作线程的状态</span></span><br><span class="line"><span class="comment">         * 1：表示运行</span></span><br><span class="line"><span class="comment">         * 0：表示停止</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRunState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> runState;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置工作线程的状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.runState = state;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//任务添加到任务队列</span></span><br><span class="line">        <span class="keyword">boolean</span> isSuccess = workerQueue.offer(command);</span><br><span class="line">        <span class="keyword">if</span> (!isSuccess) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"提交任务失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWorker</span><span class="params">(<span class="keyword">int</span> mun)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mun; i++) &#123;</span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker(<span class="string">"Thread-"</span> + threads.size(), <span class="number">0</span>);</span><br><span class="line">            worker.start();</span><br><span class="line">            threads.add(worker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWorker</span><span class="params">(<span class="keyword">int</span> mun)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mun&gt;threads.size())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"移除线程数超过最大值"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Iterator&lt;Worker&gt; iterator = threads.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Worker worker = iterator.next();</span><br><span class="line">            worker.interrupt();</span><br><span class="line">            iterator.remove();</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count==mun)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Worker worker : threads) &#123;</span><br><span class="line">            count = worker.getRunState()==<span class="number">1</span>?count+<span class="number">1</span>:count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threads.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java中的线程池&quot;&gt;&lt;a href=&quot;#Java中的线程池&quot; class=&quot;headerlink&quot; title=&quot;Java中的线程池&quot;&gt;&lt;/a&gt;Java中的线程池&lt;/h1&gt;&lt;h2 id=&quot;1-线程池好处&quot;&gt;&lt;a href=&quot;#1-线程池好处&quot; class=&quot;he
      
    
    </summary>
    
      <category term="多线程编程系列" scheme="https://aaccompany.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="多线程编程" scheme="https://aaccompany.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>HashMap 解析</title>
    <link href="https://aaccompany.github.io/2020/02/05/HashMap%E8%A7%A3%E6%9E%90/"/>
    <id>https://aaccompany.github.io/2020/02/05/HashMap解析/</id>
    <published>2020-02-04T16:00:00.000Z</published>
    <updated>2020-02-06T10:48:46.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅析HashMap问题"><a href="#浅析HashMap问题" class="headerlink" title="浅析HashMap问题"></a>浅析HashMap问题</h1><h2 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h2><p>HashMap数据结构是由数组和链表构成，具体可以表示为下图。</p><p>每个数组存储的位置的数据结构为key-value，这个结构在JDK7中称之为Entity在JDK8中称之为节点</p><p><img src="/2020/02/05/HashMap解析/1.jpg" alt></p><p><strong><code>put(&#39;key&#39;,value)</code>执行步骤</strong></p><ul><li>通过内置Hash函数计算Key值然后取模于数组长度得出存储位置</li><li>然后将key-value存储到对应数组位置上</li></ul><p><strong><code>put</code>方法执行过程待解决问题</strong></p><ul><li>用hash函数对Key进行计算并且取模于数组长度是有可能出现计算值重复，导致插入到数组的同一个位置。</li><li>在数组中有限的长度，如果插入大量的数据会使得HashMap与list没有区别了，并且也无法解决hash值计算重复的问题</li><li>根据以上的问题，也可以发现为什么HashMap要引入链表结构了</li></ul><p><strong>HashMap链表结构</strong></p><p>每个节点会存在指向下一个节点的指针</p><p><img src="/2020/02/05/HashMap解析/2.jpg" alt></p><h2 id="链表如何插入？"><a href="#链表如何插入？" class="headerlink" title="链表如何插入？"></a>链表如何插入？</h2><p>JDK7之前新值是替换原有值，然后原有值添加到链表中，也就是头插法</p><p>JDK8开始时改为尾插入新节点</p><h2 id="HashMap是如何扩容？"><a href="#HashMap是如何扩容？" class="headerlink" title="HashMap是如何扩容？"></a>HashMap是如何扩容？</h2><ul><li><p><strong>HashMap的扩容机制</strong></p><p>因为采用的是数组链表机制，数组容量有限，并且链表长到一定长度的话会降低访问效率，所以需要存在扩容机制</p></li><li><p>什么时候扩容（resize）？内部存在两个元素会影响扩容</p><p>1）<code>Capacity</code> : HashMap的容器大小</p><p>2）<code>LoadFactor</code> : 负载因子，默认为<code>0.75f</code></p></li><li><p>什么是负载因子？有什么用？</p><p>负载因子是告诉HashMap什么时候可以扩容</p><p>例如：负载因子<code>0.75f</code> , <code>Capacity</code>为100，当容器存储元素到达了75个再插入第76个的时候就会出发扩容机制</p></li><li><p>如何扩容？</p><p>1）创建新的<code>Entity</code>数组，大小为原来的两倍</p><p>2）遍历全部元素重新计算Hash值，然后添加到新的数组中</p><ul><li><p>为什么不直接将数据复制过去 而是重新计算Hash值呢？</p><p>因为数据长度发生变化了，<code>Hash的公式---&gt; index = HashCode（Key） &amp; （Length - 1）</code> ，这就会导致存储的位置不对了，最后想要通过Key去获取value也会失败</p></li></ul></li><li><h3 id="为什么到JDK8链表便从头插换到尾插？"><a href="#为什么到JDK8链表便从头插换到尾插？" class="headerlink" title="为什么到JDK8链表便从头插换到尾插？"></a><strong>为什么到JDK8链表便从头插换到尾插？</strong></h3><p><strong>put流程重要代码</strong></p><p>  1）首先hashmap进行元素的插入，在元素个数达到阀值时： </p><p><img src="/2020/02/05/HashMap解析/5.jpg" alt></p><p>  2) addEntry对判断桶有没有达到阀值，达到阀值就会走resize方法： </p><p><img src="/2020/02/05/HashMap解析/6.jpg" alt></p><p>   3) resize方法里调用transfer方法转移元素： </p><p><img src="/2020/02/05/HashMap解析/7.jpg" alt></p><p>  4) 将每个节点数据转移到新的数组中，而HashMap中出现死循环问题也是下面的代码逻辑上不合理</p><p><img src="/2020/02/05/HashMap解析/8.jpg" alt></p><p><strong>单线程环境</strong></p><p><code>resize</code>会重新计算Hash值并且添加回新的Table数组中，<code>resize</code>会将之前的链表顺序逆转，并且不会出现安全问题</p><p><img src="/2020/02/05/HashMap解析/4.jpg" alt></p><p><strong>多线程环境</strong></p><p>环境：系统中存在两个线程同时插入元素并且同时使HashMap发生扩容</p><p>线程A：执行到了下图状态</p><p>线程B：对HashMap扩容完成</p><p><img src="/2020/02/05/HashMap解析/9.jpg" alt></p><p>线程A继续执行代码，则会出现下图</p><p><img src="/2020/02/05/HashMap解析/10.jpg" alt></p><p><img src="/2020/02/05/HashMap解析/11.jpg" alt></p><p>这时候在内存中就会出现环状链表，后面进行<code>get()</code>的时候就会出现死循环，所以这也是头插入在多线程中出现的问题。</p><p><strong>为什么采用尾插入，能够解决多线程扩容发生死循环问题（不能解决多线程数据安全问题）</strong></p><p>​    如果使用链表使用尾插入则在扩容的时候不会发生逆序的现象，自然也不会出现多线程环境下成环的情况</p></li></ul><h2 id="为什么HashMap默认初始化大小为16？"><a href="#为什么HashMap默认初始化大小为16？" class="headerlink" title="为什么HashMap默认初始化大小为16？"></a>为什么HashMap默认初始化大小为16？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure><p>阿里巴巴开发手册中也提到了，HashMap的初始长度最好设置为2的整数幂，哪怕传递非2的整数幂在内部也会向下取值，那么这么做的好处是什么</p><p>之前提到过，再每次调用put方法的时候，需要计算key的哈希值然后插入到对应位置上。</p><p><code>Hash的公式---&gt; index = HashCode（Key） &amp; （Length - 1）</code> </p><p>假设<code>Length= 16</code>那么<code>Length-1=15</code>转化为二进制就是<code>1111</code>当一个Hash值与 <code>1111</code>做运算的时候，就等于Hash值的低四位。那么只需要保证哈希函数能够平均分配，那么计算出来的<code>index</code>值也是平均分配。</p><p>所以采用<code>Length</code>等于2的整数幂值就能够实现均匀分配</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浅析HashMap问题&quot;&gt;&lt;a href=&quot;#浅析HashMap问题&quot; class=&quot;headerlink&quot; title=&quot;浅析HashMap问题&quot;&gt;&lt;/a&gt;浅析HashMap问题&lt;/h1&gt;&lt;h2 id=&quot;HashMap的数据结构&quot;&gt;&lt;a href=&quot;#HashM
      
    
    </summary>
    
      <category term="Java集合类" scheme="https://aaccompany.github.io/categories/Java%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
    
      <category term="Map集合" scheme="https://aaccompany.github.io/tags/Map%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java并发容器和框架（第六章）</title>
    <link href="https://aaccompany.github.io/2020/02/03/Java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6/"/>
    <id>https://aaccompany.github.io/2020/02/03/Java并发容器和框架/</id>
    <published>2020-02-02T16:00:00.000Z</published>
    <updated>2020-02-08T15:59:19.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java并发容器和框架"><a href="#Java并发容器和框架" class="headerlink" title="Java并发容器和框架"></a>Java并发容器和框架</h1><h2 id="1-ConcurrentHashMap的实现原理与使用"><a href="#1-ConcurrentHashMap的实现原理与使用" class="headerlink" title="1.ConcurrentHashMap的实现原理与使用"></a>1.ConcurrentHashMap的实现原理与使用</h2><p><code>ConcurrentHashMap</code>是线程安全集合类，那么它是如何实现的呢？</p><h3 id="1-1-为什么要使用ConcurrentHashMap"><a href="#1-1-为什么要使用ConcurrentHashMap" class="headerlink" title="1.1.为什么要使用ConcurrentHashMap?"></a>1.1.为什么要使用ConcurrentHashMap?</h3><ul><li><p><strong>线程不安全的<code>HashMap</code></strong></p><p>多线程环境下使用<code>HashMap</code>，在JDK7<strong>HashMap扩容（resize）</strong>因为采用链表头插导致链表成环，遍历链表的时候就会出现死循环，导致CPU到达100%。在JDK8在扩容时采用链表尾插，就不会存在链表成环的现象，但是在多线程环境下put方法和get方法仍然时不安全的。</p></li><li><p><strong>线程安全但效率低下的<code>HashTable</code></strong></p><p>线程安全的实现方式是方法锁，在使用调用一个方法的时候，其他全部方法都将阻塞，所以在线程竞争激烈的场景下效率会越来越慢</p></li><li><p><strong>ConcurrentHashMap锁分段技术可有效提高访问率</strong></p><p>HashTable因为多线程在争夺一把锁导致效率低下，而ConcurrentHashMap是为了避免多线程争夺一把锁引入了分段式锁的概念，每一把锁用于锁住容器中一部分数据，当多线程访问容器中不同数据段的时候便不会出现锁竞争现象，从而提高可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的分段技术。</p><p>首先将数据分成一段一段地存储，然后给每一段数据分配一把锁，当一个线程占用锁访问一段数据的时候，其他段的数据也能访问</p></li></ul><h3 id="1-2-ConcurrentHashMap的结构"><a href="#1-2-ConcurrentHashMap的结构" class="headerlink" title="1.2.ConcurrentHashMap的结构"></a>1.2.ConcurrentHashMap的结构</h3><p>通过ConcurrentHashMap的类图来分析ConcurrentHashMap的结构</p><p><img src="/2020/02/03/Java并发容器和框架/1.jpg" alt></p><p><img src="/2020/02/03/Java并发容器和框架/2.jpg" alt></p><h3 id="1-3-ConcurrentHashMap的初始化"><a href="#1-3-ConcurrentHashMap的初始化" class="headerlink" title="1.3.ConcurrentHashMap的初始化"></a>1.3.ConcurrentHashMap的初始化</h3><p>ConcurrentHashMap初始化方法是通过<code>initialCapacity</code>、<code>loadFactor</code>和<code>concurrencyLevel</code>等几个参数初始化<code>segment数组</code>、<code>段偏移量segmentShift</code>、<code>段掩码segmentMask</code>和<code>每个segment中的HashEntity数组</code></p><h4 id="1-3-1-初始化segment数组"><a href="#1-3-1-初始化segment数组" class="headerlink" title="1.3.1.初始化segment数组"></a>1.3.1.初始化segment数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(concurrencyLevel&gt;MAX_SEGMENTS)</span><br><span class="line">    concurrentLevel = MAX_SEGMENTS;</span><br><span class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sszie = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(ssize&lt;concurrencyLevel)&#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize&lt;&lt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">segmentShift = ssize -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>.segments = Segment.newArray(ssize);</span><br></pre></td></tr></table></figure><p>由上方代码可以发现，segment数组的长度是由concurrencyLevel计算得出。为了能通过<strong>按位与的散列算法</strong>来定位segment数组的索引，<strong>必须保证数组长度为2的N次方（power-of-two size)</strong>，所以必须计算出一个大于或等于concurrencyLevel的值做为数组长度。</p><p>假如concurrencyLevel为14、15、16最后数组长度也会为16</p><blockquote><p>concurrentcyLevel的最大值为65535，说明了segment数组的长度最大值65536，对应的二进制是16位1</p></blockquote><h4 id="1-3-2-初始化segmentShift和segmentMask"><a href="#1-3-2-初始化segmentShift和segmentMask" class="headerlink" title="1.3.2.初始化segmentShift和segmentMask"></a>1.3.2.初始化segmentShift和segmentMask</h4><p>这两个全局变量需要在定位segment时的散列算法里使用，sshift等于ssize从1向左移动的次数，在默认情况下concurrencyLevel等于16，1需要向左移位4次，所以sshift等于4。</p><p>segmentShift用于定位参与散列运算的位数，segmentShift等于32减去sshift，所以等于28，这里之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数位32的。</p><p>segmentMask是散列运算的掩码，等于ssize减1，即15掩码的二进制各个位的值都是1。</p><p>因为ssize的最大长度是65536，所以segmentShift最大值是16（因为最大移动次数为16次，segmentShift = 32 - ssshift），segmentMask最大值是65535，对应的二进制是16位，每位都为1。</p><h4 id="1-3-3-初始化每个segment"><a href="#1-3-3-初始化每个segment" class="headerlink" title="1.3.3.初始化每个segment"></a>1.3.3.初始化每个segment</h4><p>输出参数<code>initialCapacity</code>是ConcurrentHashMap的初始容量，<code>localfactor</code>是每个segment的负载因子，在构造方法里需要通过这两个参数来初始化segment数组中的每个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(initialCapacity&gt;MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"><span class="comment">// c 的值为每个Segment中存放多少个元素</span></span><br><span class="line"><span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line"><span class="comment">// 避免没有整除向下取值，做加一操作</span></span><br><span class="line"><span class="keyword">if</span>(c * ssize &lt; initialCapacity)</span><br><span class="line">    ++c;</span><br><span class="line"><span class="comment">// cap为具体存放多少个元素，取等于或大于c的2的次数幂</span></span><br><span class="line"><span class="keyword">int</span> cap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(cap &lt; c)&#123;</span><br><span class="line">    cap &lt;&lt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length;i++)</span><br><span class="line">    <span class="comment">//初始化segment</span></span><br><span class="line">    <span class="keyword">this</span>.segments[i] = <span class="keyword">new</span> Segment&lt;K,V&gt;(cap,loadFactor);</span><br></pre></td></tr></table></figure><p>上面代码中的变量cap就是segment里HashEntity数组的长度，它等于<code>initialCapacity</code>除以<code>ssize</code>的倍数c，如果c大于1，则cap就会大于等于c的2的N次方值，所以cap的值不是1就是2的N次方。segment的容量<code>threshold =(int) cap * loadFactor</code>，默认情况下initialCapacity等于16，loadFactor等于0.75，带入运算cap等于1，threshold等于0</p><h4 id="1-3-4-定位Segment"><a href="#1-3-4-定位Segment" class="headerlink" title="1.3.4.定位Segment"></a>1.3.4.定位Segment</h4><p>既然ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素的时候，必须先通过散列算法定位到具体的segment。可以看到ConcurrentHashMap会首先使用<code>Wang/Jenkins hash</code>的变种算法对元素的hashCode<strong>再</strong>进行一次散列（也就是获取到key的HashCode然后再进行hash计算）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">    h += (h&lt;&lt;<span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">    h ^= (h&gt;&gt;&gt;<span class="number">10</span>);</span><br><span class="line">    h += (h&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    h ^= (h&gt;&gt;&gt;<span class="number">6</span>);</span><br><span class="line">    h += (h&lt;&lt;<span class="number">2</span>) + (h&lt;&lt;<span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> h^ (h&gt;&gt;&gt;<span class="number">16</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以需要再散列，目的是为了减少散列冲突，使元素能够均匀地分布再不同的segment上，从而提高容器的存取效率。假如散列的质量差到极点，那么所有的元素都将在同一个segment中，不仅存取效率慢，同时会不断的扩容分布锁也将失去了意义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> segemnts[ (hash&gt;&gt;segmentShift) &amp; segmentMask]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下segmentShift为28，segmentMask为15，再散列后的数最大值是32位二进制数据，向右无符号移动28位，意思是让高4位参与散列运算中<code>（hash&gt;&gt;segmentShift)&amp;segmentMask</code>的运算结果。就可以降低散列值冲突情况</p><h3 id="1-4-ConcurrentHashMap的操作"><a href="#1-4-ConcurrentHashMap的操作" class="headerlink" title="1.4.ConcurrentHashMap的操作"></a>1.4.ConcurrentHashMap的操作</h3><h4 id="1-4-1-get操作"><a href="#1-4-1-get操作" class="headerlink" title="1.4.1.get操作"></a>1.4.1.get操作</h4><p>Segment的get操作实现非常简单和高效。先经过一次散列后再进行散列，然后使用这个散列值通过散列运算定位到具体的Segment，再通过散列算法定位到元素，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 先获取key的hash值然后再进行散列</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.HashCode());</span><br><span class="line">    <span class="comment">// 先获取对应的Segment然后再获取对应的HashEntity</span></span><br><span class="line">    <span class="keyword">return</span> SegmentFor(hash).get(key,hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空才会加锁重读。</p><p><strong>HashTable容器的get方法是加锁的，那么ConcurrentHashMap的get操作是如何做到不加锁的呢？</strong></p><p>因为在ConcurrentHashMap中get方法所使用的共享变量都被<strong>volatile修饰</strong>，如用于统计当前Segment大小的<strong>count字段</strong>和用于<strong>存储值的HashEntity的value</strong>。这就保证了这些变量在多线程之间的可见性，能够被多线程同时读，并且保证不会读取到过期的值，但是只能被单个线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在get操作只需要读不需要写共享变量count和value，所以可以不用加锁。之所以不会读到过期的值，是因为根据Java内存模型happen before原则，对volatile字段的写操作先于读操作，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值。这就是用volatile替换锁的经典应用场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">volatile</span> V value;</span><br></pre></td></tr></table></figure><p>定位元素的代码可以发现，定位HashEntity和定位Segment的散列算法虽然医院，都在数组的长度减去1再相“与”的值不一样，定位Segment使用的是元素hashcode通过再散列后得到的值的高位，而定位HashEntity直接使用的是再散列后的值。其目的是为了避免两次散列后的值一样，虽然元素再Segment里散开了，但是却没有再HashEntity里散列开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash&gt;&gt;&gt; segmentShift ) &amp; segmentMask <span class="comment">//定位Segment所使用的hash算法</span></span><br><span class="line"><span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>) <span class="comment">//定位HashEntity所使用的hash算法</span></span><br></pre></td></tr></table></figure><h4 id="1-4-2-put操作"><a href="#1-4-2-put操作" class="headerlink" title="1.4.2.put操作"></a>1.4.2.put操作</h4><p>由于put方法里需要对共享变量进行写入操作，所以为了线程安全，在操作共享变量时必须加锁。put方法首先定位到Segment，然后在Segment里进行操作插入操作。</p><p>第一步：判断是否需要对Segment里的HashEntity数进行扩容</p><ul><li><p>是否需要扩容</p><p>在插入元素前会先判断Segment里的HashEntity数据是否超过容量(threshold)，如果超过阈值，则对数组进行扩容。值得一提的是，Segment的扩容判断比HashMap更加合理，因为HashMap是在插入元素后判断是否到达容量的，如果到达了就进行扩容，但是很有可能扩容没有新元素插入，这时HashMap就进行了一次无用的扩容</p></li><li><p>如何扩容</p><p>在扩容的时候，首先会创建一个容量是原来容量的两倍的数组，然后将原数组里的元素进行再散列后插入到新数组里。为了高效，ConcurrentHashMap不会对整个容器进行扩容，而是只对某个segment进行扩容</p></li></ul><p>第二步：定位需要添加元素的位置，然后将其放在HashEntity数组里</p><h4 id="1-4-3-size操作"><a href="#1-4-3-size操作" class="headerlink" title="1.4.3.size操作"></a>1.4.3.size操作</h4><p>如果要统计整个ConcurrentHashMap里元素的大小，就必须统计所有Segment元素的大小后求和。Segment里的全局变量count是一个volatile变量，那么在多线程环境下对全部Segment里的count相加是否就是ConcurrentHashMap的大小呢？</p><p>然而并不是这样做就可以得到容器的大小，因为在多线程环境下，容器的大小会变化，导致了计算不精准。但是如果对全部Segment进行加锁，然后进行计算容器大小会导致效率低下。</p><p>在累加count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式统计各个Segment大小。<strong>如果统计的过程中，容器的count发生变化，则再采用加锁的方式来统计所有Segment大小。</strong></p><p>ConcurrentHashMap是如何判断容器再进行计算大小的时候是否发生变化？使用modCount变量，在put、remove和clear方法里操作元素前都会将modCount变量加1，那么在统计size前后比较modCount是否发生变化，从而得知容器大小是否发生变化<strong>（也就是安全失败机制 fail-fast机制）</strong></p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ul><li>方腾飞：《Java并发编程的艺术》 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java并发容器和框架&quot;&gt;&lt;a href=&quot;#Java并发容器和框架&quot; class=&quot;headerlink&quot; title=&quot;Java并发容器和框架&quot;&gt;&lt;/a&gt;Java并发容器和框架&lt;/h1&gt;&lt;h2 id=&quot;1-ConcurrentHashMap的实现原理与使用&quot;&gt;
      
    
    </summary>
    
      <category term="多线程编程系列" scheme="https://aaccompany.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="多线程编程" scheme="https://aaccompany.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发机制的底层实现原理（第二章）</title>
    <link href="https://aaccompany.github.io/2020/02/03/Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://aaccompany.github.io/2020/02/03/Java并发机制的底层实现原理/</id>
    <published>2020-02-02T16:00:00.000Z</published>
    <updated>2020-02-04T07:53:28.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java并发机制的底层实现原理"><a href="#Java并发机制的底层实现原理" class="headerlink" title="Java并发机制的底层实现原理"></a>Java并发机制的底层实现原理</h1><h2 id="1-Java运行过程"><a href="#1-Java运行过程" class="headerlink" title="1.  Java运行过程"></a>1.  Java运行过程</h2><p><img src="/2020/02/03/Java并发机制的底层实现原理/1.jpg" alt></p><p>Java中所使用的并发机制依赖于<code>JVM</code>的实现和CPU指令，所以需要研究的地方便为这两处</p><h2 id="2-多线程重要概念"><a href="#2-多线程重要概念" class="headerlink" title="2.多线程重要概念"></a>2.多线程重要概念</h2><h3 id="2-1-现代CPU模型"><a href="#2-1-现代CPU模型" class="headerlink" title="2.1.现代CPU模型"></a>2.1.现代CPU模型</h3><p>一个CPU中会存在多核心，每个核心都会有多个缓存，这么做解决了CPU和主存速度不匹配的问题</p><p>CPU在运算的时候会先从<code>高速缓存1</code>-&gt;<code>高速缓存2</code>-&gt;…-&gt;<code>主存</code>获取数据，如果有一处命中则不会继续向下获取数据</p><p><img src="/2020/02/03/Java并发机制的底层实现原理/2.jpg" alt></p><h3 id="2-2-多线程三大特性"><a href="#2-2-多线程三大特性" class="headerlink" title="2.2.多线程三大特性"></a>2.2.多线程三大特性</h3><p>多线程编程中如果这三个性质没有得到保证就容易出现安全问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可见性：一个线程中修改了某个值，在其他线程可以察觉最新值</span><br><span class="line">原子性：一个操作或者多个操作，要么一起执行要么都不执行，原子性就像数据库事务一样像一个团队共同生死</span><br><span class="line">有序性：程序执行的顺序于代码顺序一致</span><br></pre></td></tr></table></figure><h3 id="2-2-CPU术语的定义"><a href="#2-2-CPU术语的定义" class="headerlink" title="2.2. CPU术语的定义"></a>2.2. CPU术语的定义</h3><table><thead><tr><th align="center">术语</th><th align="center">英文单词</th><th align="left">术语描述</th></tr></thead><tbody><tr><td align="center">内存屏障</td><td align="center">memory barriers</td><td align="left">一组处理器指令，用于实现对内存操作的顺序限制（顺序性）</td></tr><tr><td align="center">缓冲行</td><td align="center">cache line</td><td align="left">CPU高速缓存中可以分配的最小存储单位。<br>处理器在填写缓存行时，会加载整个缓存行。<br>现代CPU需要执行几百次CPU指令</td></tr><tr><td align="center">原子操作</td><td align="center">atomic operations</td><td align="left">不可中断的一个或一系列操作</td></tr><tr><td align="center">缓冲行填充</td><td align="center">cache line fill</td><td align="left">当处理器识别到从内存中去读操作数是可缓存的<br>处理器读取整个高速缓存行到适应的缓存（<code>L1、L2、L3</code>到所有）</td></tr><tr><td align="center">缓存命中</td><td align="center">cache hit</td><td align="left">如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时<br>处理器从缓存中获取数据而不是从主存中获取数据</td></tr><tr><td align="center">写命中</td><td align="center">write hit</td><td align="left">当处理器将操作数写回到一个内存缓存区域时，它首先回检查这个缓存的内存地址<br>是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存<br>而不是写回到内存，这个操作被称为写命中</td></tr><tr><td align="center">写缺失</td><td align="center">write misses the cache</td><td align="left">一个有效的缓存行被写入到了不存在的内存区域</td></tr><tr><td align="center">比较并交换</td><td align="center">compare and swap</td><td align="left">CAS操作需要输入两个数值，一个是旧值（期望操作前的值）和一个新值<br>在操作期间先比较旧值有没有发生变化，如果没有发生变化则更新成功或者失败</td></tr><tr><td align="center">CPU流水线</td><td align="center">CPU pipeline</td><td align="left">指令的执行，需要取址、执行、IO等，这三个操作分别在不同CPU内部结构中执行<br>但是为了提高CPU的吞吐量，会将这些操作异步执行</td></tr><tr><td align="center">内存顺序冲突</td><td align="center">Memory order violation</td><td align="left">内存顺序冲突一般是由假共享起因的，假共享是指多个CPU同一时刻修改同一个缓存的不同部分<br>当出现了这个冲突的时候CPU必须清空CPU流水线</td></tr></tbody></table><h2 id="3-Volatile"><a href="#3-Volatile" class="headerlink" title="3. Volatile"></a>3. Volatile</h2><p>多线程编程中Volatile和Synchronized都是常见修饰符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">环境：</span><br><span class="line">存在两个线程A、B分别在不同的核心中运行</span><br><span class="line">存在一个共享变量var</span><br><span class="line">线程A线程B</span><br><span class="line">- 读取var-修改var</span><br><span class="line">- 进行操作</span><br><span class="line">- 读取var</span><br><span class="line"></span><br><span class="line">问题：</span><br><span class="line">线程A再第二次读取var的变量并不是最新的值，而是脏数据</span><br><span class="line">因为线程B再修改完数据之后只是将数据写入到了CPU的高速缓存中，并没有写到主存</span><br><span class="line">线程A再读取值的时候也只会读取到高速缓存的值</span><br><span class="line">导致线程A读取到的值是脏数据</span><br></pre></td></tr></table></figure><p>Volatile修饰符可以保证在<code>多处理器</code>环境下变量可见性</p><h3 id="3-1-volatile的定义与实现原理"><a href="#3-1-volatile的定义与实现原理" class="headerlink" title="3.1. volatile的定义与实现原理"></a>3.1. volatile的定义与实现原理</h3><p><code>Java编程语言允许线程访问共享变量，为了确保共享变量能够被准确和一直地更新，线程应该采用排他锁单独获取这个变量</code></p><p><code>是不是能够通过这个原理联想到在分布式环境下双缓冲的问题?</code></p><p>Java语言提供了volatile在一些情况下会比加锁效果好，如果一个字段被修饰为volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的</p><p>有volatile修饰的变量在进行写操作的时候，会在汇编指令中加入<code>lock</code>的标识，当<strong>多核处理器</strong>发现<code>lock</code>标识会做两件事情</p><ul><li>将当前处理器缓存行写入到主存中</li><li>上面的写入操作会使在其他处理器核心中缓存该内存地址的数据无效</li></ul><p>为了解决CPU与主存的速度不匹配造成的处理速度低下的问题，处理器将不直接与主存进行通信，而是通过高速缓存。</p><p>这就会在多核处理器中出现脏数据，因为每个核心都会有数据备份，当有一个核心修改了数据，其他核心数据并未读取最新的数据造成。</p><p>为了保证各个缓存数据一致性，会实现<strong>缓存一致性协议<code>MESI</code></strong>，每个处理器通过嗅探在总线上传播的数据来检查自己缓存是否已经过期，如果发现缓存过期，那么就会标识当前处理器的缓存为无效状态，当处理再次获取该缓存的时候会跳过缓存从主存获取最新值，并且修改缓存值。</p><h3 id="3-2-volatile的两条实现原则"><a href="#3-2-volatile的两条实现原则" class="headerlink" title="3.2. volatile的两条实现原则"></a>3.2. volatile的两条实现原则</h3><ul><li>Lock前缀指令会引起处理器将数据写回主存</li><li>一个处理器在将缓存写回主存，会导致其他处理器对应内存地址的缓存失效</li></ul><h3 id="3-3-volatile优化"><a href="#3-3-volatile优化" class="headerlink" title="3.3. volatile优化"></a>3.3. volatile优化</h3><p>从<code>3.2</code>中可以发现volatile 在写的过程中会导致其他处理器对应内存地址的缓存失效</p><p>所有多线程编程大师<code>Doug Lea</code>在<code>LinkedTransferQueue</code>类中，对头节点和尾节点进行字节填充</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列头节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">final</span> PaddedAtomicReference&lt;QNode&gt; head;</span><br><span class="line"><span class="comment">//队列尾节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">final</span> PaddedAtomicReference&lt;QNode&gt; tail;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddedAtomicReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AtomicReference</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用15个四节点的对象填充</span></span><br><span class="line">    Object p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pa,pb,pc,pd,pe;</span><br><span class="line">    PaddedAtomicReference(T r)&#123;</span><br><span class="line">        <span class="keyword">super</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么在对象中追加字节能够优化性能？</p><p>在<code>LinkedTransferQueue</code>中，内部类<code>PaddedAtomicReference</code>扩展到了(15+1)*4字节也就是64字节</p><p>现代CPU中高速缓存的缓存行是64字节宽，不支持部分填充缓存行，这意味着，如果队列的头节点和尾节点都不足64字节，处理器会将他们读取到同一个缓存行中，在多个处理器核心都会缓存这个head、tail。如果其中一个处理器核心修改head的话，根据缓存一致性协议，其他处理器核心的该缓存行将失效，导致无法在高速缓存中获取尾节点数据，需要从主存中获取大大的降低了操作速度。</p><p>在队列中，入列和出列操作都很频繁，这就导致在多线程环境下会存在很多高速缓存失效的情况，所以<code>Doug lea</code>使用追加头节点和尾节点到64字节方式来填充高速缓存，避免头节点和尾节点填充到同一个高速缓存行，使头、尾节点在修改时不会相互锁定，这将大大提高在多线程环境下入列出列操作速度。</p><h4 id="3-3-1-是不是什么时候都可以采用追加字节提高volatile效率？"><a href="#3-3-1-是不是什么时候都可以采用追加字节提高volatile效率？" class="headerlink" title="3.3.1.是不是什么时候都可以采用追加字节提高volatile效率？"></a>3.3.1.是不是什么时候都可以采用追加字节提高volatile效率？</h4><p>并不是在所有的场合都适用追加字节来提高volatile的效率，在一下两个场景时不能使用</p><ul><li><strong>缓存行为32字节宽的处理器：</strong>如<code>P6系列和奔腾处理器</code>，它们的高速缓存行为32字节宽</li><li><strong>共享变量并不会被频繁的写：</strong>使用追加字节的方式采用空间换时间，如果不经常写的变量一般是不会被锁住的，所以也没有必要进行字节追加</li></ul><p>在<code>JDK7</code>以上追加字节的方式会无效，因为<code>JVM</code>会智能淘汰或重新排列无用字段，所以需要使用其他方式来进行字段追加</p><h2 id="4-Synchronized"><a href="#4-Synchronized" class="headerlink" title="4.  Synchronized"></a>4.  Synchronized</h2><h3 id="4-1-什么是Synchronized？"><a href="#4-1-什么是Synchronized？" class="headerlink" title="4.1. 什么是Synchronized？"></a>4.1. 什么是Synchronized？</h3><p>synchronized在1.6之前被称为重量级锁，性能低下。</p><p>1.6之后synchronized涅槃重生，进行了大量优化。提高了锁在释放和获取的效率</p><ul><li>进行锁优化，例如<strong>自旋锁、适应自旋锁、锁消除、锁粗化</strong></li><li>例如引入<strong>无锁、偏向锁、轻量级锁 ，重量级锁</strong>。增加锁升级的机制</li></ul><h3 id="4-2-锁优化"><a href="#4-2-锁优化" class="headerlink" title="4.2.锁优化"></a>4.2.锁优化</h3><p>观察下面的锁优化其实可以很容易发现，主要目的减少线程上下文切换次数，提高系统运行速度</p><h4 id="4-2-1-自旋锁"><a href="#4-2-1-自旋锁" class="headerlink" title="4.2.1.自旋锁"></a>4.2.1.自旋锁</h4><p>线程在获取锁的过程中，并不会获取不到锁就直接将当前线程加入同步队列，而是会在获取锁处循环获取。</p><p>因为在一般的同步代码块中，任务量少，执行时间很快，没有必要将线程加入同步队列，而是在锁处循环获取锁，其他线程能够很快的将锁释放。（默认自旋次数为10次）</p><p>好处：因为同步代码块任务量少，执行时间短，能够很快释放锁，其他线程也不需要加入到同步队列，减少了线程上下文切换，加快了线程运行时间</p><p>坏处：循环获取锁的弊端很明显，就是需要占用CPU运算资源，做无用的循环获取锁，如果获取不到则一直循环，浪费运输资源。所以同步代码块任务量大时使用自旋锁将降低系统运行效率</p><h4 id="4-2-2-自适应自旋锁"><a href="#4-2-2-自适应自旋锁" class="headerlink" title="4.2.2.自适应自旋锁"></a>4.2.2.自适应自旋锁</h4><p>自适应自旋锁在自旋锁的基础上做了增强。</p><p>在Java 6 中加入了自适应自旋锁，该锁不同于自旋锁的地方为，该锁并非采用固定的自旋次数，而是会自动感知上次自旋时间以及锁的拥有者的状态来做。如果上次再很短的时间自旋获取锁，那么可以认为这次也能够在很短时间的获取到锁，那么就会允许它增加自旋次数。相反如果上次自旋没有获取到锁或者是很长时间才获取到锁，那么再下次获取锁的时候就会放弃自旋或者降低自旋次数</p><p>这样做的好处是避免因为自旋而浪费CPU的运算资源</p><h4 id="4-2-3-锁消除"><a href="#4-2-3-锁消除" class="headerlink" title="4.2.3.锁消除"></a>4.2.3.锁消除</h4><p>多线程编程中，JVM会感知是否存在锁竞争的现象，如果不存在锁竞争的现象，那么将会撤销锁</p><p>锁消除的依据是逃逸分析的数据支持。如果不存在竞争，那么为什么还需要加锁，所以锁消除能够去掉没有必要请求锁和释放锁的时间。</p><p>但是多线程编程不是程序员编写的么？那为什么会出现不存在锁竞争但是还加锁的操作呢？是程序员有问题么？</p><p>系统开发的过程中，不是说我们这样写就不会出现这个现象，它可能会因为我们不小心调用了<code>JDK</code>内置类或者第三方类库的时候出现的加锁操作</p><p>例如String Buffer、Vector、Hash Table等等，他们在一些方法上都会存在加锁操作，但是如果在单线程，或者变量未逸出的时候，这些加锁操作是否有必要？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">vectorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">            vector.add(i + <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(vector);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>观察一下上方代码可以发现，vector变量一直在方法内，并没有逸出操作。所以它是不会出现安全问题，但是<code>vector.add()</code>会出现加锁操作，JVM检查到没有变量逸出，这时候就会锁消除</p><h4 id="4-2-4-锁粗化"><a href="#4-2-4-锁粗化" class="headerlink" title="4.2.4.锁粗化"></a>4.2.4.锁粗化</h4><p>多线程编程中，加锁操作一般都是在涉及到共享变量的时候才存在，而且在编程的过程中也会刻意的将同步代码块范围弄的小点，但是如果在代码中连续获取同一把锁，那么JVM会将锁的范围扩大，避免刚释放锁没有过多久又要申请锁的问题。</p><h3 id="4-3-Synchronized以什么做为锁？"><a href="#4-3-Synchronized以什么做为锁？" class="headerlink" title="4.3. Synchronized以什么做为锁？"></a>4.3. Synchronized以什么做为锁？</h3><p>在Java中所有对象都可以作为锁对象，具体表现为3类</p><ul><li>对于普通同步方法，锁对象为当前实例对象</li><li>对于静态同步方法，锁对象为当前实例的类对象</li><li>对于同步方法块，<code>synchronized(lockObject)</code>锁对象为配置的对象</li></ul><h3 id="4-4-Synchronized在JVM如何体现？"><a href="#4-4-Synchronized在JVM如何体现？" class="headerlink" title="4.4. Synchronized在JVM如何体现？"></a>4.4. Synchronized在JVM如何体现？</h3><p>JVM基于进入和退出 <strong>Monitor</strong>对象来实现<strong>方法同步</strong>和<strong>代码块同步</strong>，但是两者具体实现不一样。代码块的同步实现是通过<code>monitorenter</code>和<code>monitorexit</code>来实现。方法同步时使用另外一种方式实现，但是JVM规范中没有详细说明。但是同步方法也可以使用两个指令来实现同步。</p><p><code>monitorenter</code>：在代码编译后由JVM插入到同步方法前</p><p><code>monitorexit</code>：在同步方法结束处和在异常结束处添加该指令。在异常处添加指令是为了避免无法释放锁，所以查看生成字节码文件会发现存在两个<code>monitorexit</code>指令</p><h3 id="4-5-Synchronized同步过程"><a href="#4-5-Synchronized同步过程" class="headerlink" title="4.5. Synchronized同步过程"></a>4.5. Synchronized同步过程</h3><p>每个对象在对象头都会有<code>monitor</code>的标识，当执行到同步方法的时候，当前线程会尝试获取对应对象的<code>monitor</code>，当获取到了则执行同步代码，否则将进入同步队列</p><h4 id="4-5-1-对象头"><a href="#4-5-1-对象头" class="headerlink" title="4.5.1.对象头"></a>4.5.1.对象头</h4><p>synchronized使用的锁是存在Java对象头的。如果Java对象为数组则虚拟机用3个字宽（Word）存储对象头，如果Java对象为非数组则用2个字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32 bit</p><p>Java对象对数据结构</p><table><thead><tr><th align="center">长度</th><th align="center">内容</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">32/64 bit</td><td align="center">Mark Word</td><td align="center">存储对象的HashCode和锁信息等</td></tr><tr><td align="center">32/64 bit</td><td align="center">Class Metadata Address</td><td align="center">存储对象的类对象指针</td></tr><tr><td align="center">32/64 bit</td><td align="center">Array Length</td><td align="center">数组的长度（对象为数组时）</td></tr></tbody></table><p>Java对象头Mark Word存储结构以及变化过程</p><table><thead><tr><th align="center">锁状态</th><th align="center">25 bit</th><th align="center">4 bit</th><th align="center">1 bit 是否为偏向锁</th><th align="center">2 bit 锁标志</th></tr></thead><tbody><tr><td align="center">无锁状态</td><td align="center">对象的HashCode</td><td align="center">对象的分代年龄（最大15岁）</td><td align="center">0</td><td align="center">01</td></tr><tr><td align="center">偏向锁</td><td align="center">线程ID( 占两部分Epoch</td><td align="center">Epoch)对象分代年龄</td><td align="center">1</td><td align="center">01</td></tr><tr><td align="center">轻量级锁</td><td align="center">指向栈中锁记录指针</td><td align="center">指向栈中锁记录指针</td><td align="center">指向栈中锁记录指针</td><td align="center">00</td></tr><tr><td align="center">重量级锁</td><td align="center">执行互斥量的指针</td><td align="center">执行互斥量的指针</td><td align="center">执行互斥量的指针</td><td align="center">10</td></tr><tr><td align="center">GC标记</td><td align="center">空</td><td align="center">空</td><td align="center">空</td><td align="center">11</td></tr></tbody></table><p>这个时候观察表格可以发现，为什么需要1 bit来描述是否为偏向锁，因为对象头的状态有5种，但是锁标记位只有2 bit导致不够描述，所以添加多一个bit作为说明</p><h3 id="4-6-锁的升级与对比"><a href="#4-6-锁的升级与对比" class="headerlink" title="4.6.锁的升级与对比"></a>4.6.锁的升级与对比</h3><p>锁会锁着锁的竞争激烈程度进行升级，但是不能降级，这样做的目的是为了提高获取锁和释放锁的效率</p><h4 id="4-6-1-偏向锁"><a href="#4-6-1-偏向锁" class="headerlink" title="4.6.1.偏向锁"></a>4.6.1.偏向锁</h4><p>偏向锁顾名思义，偏向锁会偏向一个线程。</p><p>在大多数情况下，锁不仅不存在多线程竞争，而且总是同一个线程进入同步代码块，如果不断的进行获取锁释放锁效率将降低很多</p><p>所以偏向锁会记录第一次获取锁的线程ID，并且在这个线程再次进入的时候，直接放行，加快了进入同步代码块的速度</p><h5 id="4-6-1-1-偏向锁的获取"><a href="#4-6-1-1-偏向锁的获取" class="headerlink" title="4.6.1.1.偏向锁的获取"></a>4.6.1.1.偏向锁的获取</h5><p><img src="/2020/02/03/Java并发机制的底层实现原理/4.jpg" alt></p><h5 id="4-6-1-2-偏向锁的释放"><a href="#4-6-1-2-偏向锁的释放" class="headerlink" title="4.6.1.2.偏向锁的释放"></a>4.6.1.2.偏向锁的释放</h5><p>偏向锁采用了一种等到出现多线程竞争的情况才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</p><p>偏向锁的撤销，需要等待全局安全点（也就是GC点）。</p><p>偏向锁的过程</p><ul><li>暂停拥有偏向锁的线程</li><li>检查拥有偏向锁的线程是否存活，如果该线程不处于活动状态，则将该对象头设置成无锁状态</li><li>如果线程处于活动状态，拥有偏向锁的线程栈会被执行，遍历变相对象的锁记录，栈中的锁记录和对象头的Mark Word 要么重新偏向其他线程，要么恢复到无锁状态或标记对象不适合作为偏向锁，最后唤醒暂停的线程</li></ul><h5 id="4-6-1-3-偏向锁流程图"><a href="#4-6-1-3-偏向锁流程图" class="headerlink" title="4.6.1.3.偏向锁流程图"></a>4.6.1.3.偏向锁流程图</h5><p><img src="/2020/02/03/Java并发机制的底层实现原理/3.jpg" alt></p><h5 id="4-6-1-4-关闭偏向锁"><a href="#4-6-1-4-关闭偏向锁" class="headerlink" title="4.6.1.4.关闭偏向锁"></a>4.6.1.4.关闭偏向锁</h5><p>如果系统存在很明显的锁竞争关系，那么可以关闭偏向锁，提高系统的允许速度。减少锁升级的过程</p><p>Java 6后默认开启偏向锁，但是它是存在启动延迟，也就是说在系统启动后X秒才开启偏向锁，如果又必要的话可以调整延迟时间，<code>-XX:BiasedLockingStartupDelay=0</code>。</p><p>如果系统对锁都存在竞争关系，那么可以关闭偏向锁<code>-XX:-UseBiasedLocking=flase</code>，那么系统将直接进入轻量级锁状态</p><h4 id="4-6-2-轻量级锁"><a href="#4-6-2-轻量级锁" class="headerlink" title="4.6.2.轻量级锁"></a>4.6.2.轻量级锁</h4><p>会使用锁优化中的自适应锁自旋</p><h5 id="4-6-2-1-轻量级锁的获取"><a href="#4-6-2-1-轻量级锁的获取" class="headerlink" title="4.6.2.1.轻量级锁的获取"></a>4.6.2.1.轻量级锁的获取</h5><ul><li>线程栈中创建存储锁记录空间</li><li>将对象头中的Mark Word复制到锁记录空间（这个过程官方称之为Displaced Mark Word)</li><li>使用<code>CAS</code>替换对象头中Mark Word指向线程栈中锁记录，成功则获取锁，失败则<strong>自旋</strong></li></ul><h5 id="4-6-2-2-轻量级锁的释放"><a href="#4-6-2-2-轻量级锁的释放" class="headerlink" title="4.6.2.2.轻量级锁的释放"></a>4.6.2.2.轻量级锁的释放</h5><ul><li>使用<code>CAS</code>将锁记录中的Displaced Mark Word复制回对象头中Mark Word</li><li>如果成功则说明释放锁成功</li><li>失败则说明发生锁竞争，升级为重量级锁</li></ul><h5 id="4-6-2-3-轻量级锁膨胀流程图"><a href="#4-6-2-3-轻量级锁膨胀流程图" class="headerlink" title="4.6.2.3.轻量级锁膨胀流程图"></a>4.6.2.3.轻量级锁膨胀流程图</h5><p>因为自旋会消耗CPU的运算资源，为了避免无用的自旋，一旦升级为重量级锁，则不会降级了。当锁处于这个重量级锁的状态，其他线程试图获取锁时都会阻塞，当持有锁的线程释放锁之后会唤醒所有被阻塞的线程，接下来则会进行锁竞争的过程。</p><p><img src="/2020/02/03/Java并发机制的底层实现原理/5.jpg" alt></p><h4 id="4-6-3-不同锁的对比"><a href="#4-6-3-不同锁的对比" class="headerlink" title="4.6.3.不同锁的对比"></a>4.6.3.不同锁的对比</h4><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗<br>和非同步方法仅仅存在纳秒级的差距</td><td>如果线程间存在锁竞争<br>会带来额外的锁撤销消耗</td><td>适用于只有一个线程访问同步代码块<br>没有过多的锁竞争</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞<br>提高了程序响应速度</td><td>始终得不到锁的线程将不断地自旋浪费CPU运算</td><td>追求响应时间<br>同步代码块执行时间很快<br>适用于存在少量锁竞争场景</td></tr><tr><td>重量级锁</td><td>线程不会自旋，减少CPU的浪费</td><td>不断的进行请求锁和释放锁<br>存在大量的线程上下文切换的消耗</td><td>执行速度最慢，因为相比于轻量级锁<br>多了很多线程上下文切换的时间<br>适用于锁竞争激烈的场景</td></tr></tbody></table><h2 id="5-原子操作的实现原理"><a href="#5-原子操作的实现原理" class="headerlink" title="5.原子操作的实现原理"></a>5.原子操作的实现原理</h2><p>原子（atomic）本意是“不可进一步分割的最小粒子”，而原子操作（atomic operation)意为“不可以被中断的一个或一系列的操作”</p><h3 id="5-1-处理器如何实现原子操作"><a href="#5-1-处理器如何实现原子操作" class="headerlink" title="5.1.处理器如何实现原子操作"></a>5.1.处理器如何实现原子操作</h3><ul><li>解决方案有两种：<ul><li>总线加锁：对总线加锁，在写的过程中，其他CPU都无法访问主存</li><li>缓存加锁：对缓存行加锁，在写的过程中会锁住该缓存行，在其他CPU中该缓存行失效，重新从主存获取</li></ul></li><li>处理器会自动保证基本的内存操作的原子性</li><li><strong>两种情况下处理器不会适用缓存行锁定</strong><ul><li>数据跨多个缓存行，CPU会采用锁总线操作；数据不能被加载进高速缓存</li><li>处理器不支持锁缓存行</li></ul></li></ul><h3 id="5-2-Java如何实现原子操作"><a href="#5-2-Java如何实现原子操作" class="headerlink" title="5.2.Java如何实现原子操作"></a>5.2.Java如何实现原子操作</h3><p>Java中很多操作都非原子操作，例如最常见的<code>i++</code>就是一个非原子的操作</p><p>Java中可以采用<code>CAS</code>和加锁操作来完成原子操作</p><h4 id="5-2-1-使用循环CAS实现原子操作"><a href="#5-2-1-使用循环CAS实现原子操作" class="headerlink" title="5.2.1.使用循环CAS实现原子操作"></a>5.2.1.使用循环CAS实现原子操作</h4><p>JVM中的CAS操作是底层使用了处理器提供的CMPXCHG指令实现。</p><p>自旋CAS实现的基本思路循环CAS操作直到完成为止</p><blockquote><p>从JDK1.5开始，Java提供的并发包提供了一些类来支撑某些原子操作，如AtomicBoolean(用原子方式更新Boolean)，AtomicInteger（用原子操作更新int值）等等</p></blockquote><p>下面操作即为实现CAS线程安全的计数器方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicI = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Counter counter = <span class="keyword">new</span> Counter();</span><br><span class="line">        List&lt;Thread&gt; threadList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//创建100个线程 每个线程任务为计数自增1000次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; <span class="number">1000</span>; i1++) &#123;</span><br><span class="line">                        counter.safeCount();</span><br><span class="line">                        counter.count();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threadList.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开启100个线程</span></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//main线程等待100个线程执行完毕</span></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程安全计数器:"</span>+counter.atomicI.get());</span><br><span class="line">        System.out.println(<span class="string">"非线程安全计数器:"</span>+counter.i);</span><br><span class="line">        System.out.println(<span class="string">"执行耗时:"</span>+(System.currentTimeMillis()-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用CAS的线程安全计数器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">safeCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//自旋CAS操作，减少线程上下文切换</span></span><br><span class="line">        <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">            <span class="comment">//获取最新值</span></span><br><span class="line">            <span class="keyword">int</span> i = atomicI.get();</span><br><span class="line">            <span class="comment">//使用CAS替换值，如果生成则退出</span></span><br><span class="line">            <span class="keyword">boolean</span> suc = atomicI.compareAndSet(i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (suc)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非线程安全计数器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-使用CAS实现原子操作的三大问题"><a href="#5-2-2-使用CAS实现原子操作的三大问题" class="headerlink" title="5.2.2.使用CAS实现原子操作的三大问题"></a>5.2.2.使用CAS实现原子操作的三大问题</h4><ul><li>ABA问题<ul><li>在CAS的原理上，是检查旧值和内存中的值是否一样，如果一样就替换为新值。这就会出现一个BUG，如果在更新的过程中有人修改了值，最后又变成了旧值，那么它在检查的时候CAS会发现值未发现改变，然后替换。</li><li>这个概念可能会很抽象，并且不好理解有啥危害。个人理解，简单的说就是狸猫换太子</li><li>举个例子：<ul><li>小A有一个满的水，小A离开了房间</li><li>小B看到房间有杯水，喝完了然后倒回去</li><li>小A回来看到水还是水，然后继续喝了</li></ul></li><li>解决方案：<ul><li>每次修改都添加版本号，就像1A-&gt;2B-&gt;3A，这样就能够避免出现ABA的问题</li><li>在Java中提供了AtomicStampedReference类来实现</li></ul></li></ul></li><li>循环时间长开销大<ul><li>通过<code>5.2.1</code>的代码可以发现有个<code>for(;;)</code>操作，不断的循环，做无用的运算</li></ul></li><li>只能保证一个变量进行原子操作<ul><li>如果有多个变量需要进行CAS原子操作，可以将多个变量合成一个Java对象，Java提供了AtomicReference来实现对象的原子操作</li></ul></li></ul><h3 id="5-3-Java使用锁机制来完成原子操作"><a href="#5-3-Java使用锁机制来完成原子操作" class="headerlink" title="5.3.Java使用锁机制来完成原子操作"></a>5.3.Java使用锁机制来完成原子操作</h3><p>锁机制保证了只有获取锁的线程才能进入同步代码块。JVM内部实现了很多锁机制，有偏向锁、轻量级锁、重量级锁（互斥锁），JVM中锁机制都是通过CAS来完成获取锁和释放锁</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ul><li>方腾飞：《Java并发编程的艺术》 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java并发机制的底层实现原理&quot;&gt;&lt;a href=&quot;#Java并发机制的底层实现原理&quot; class=&quot;headerlink&quot; title=&quot;Java并发机制的底层实现原理&quot;&gt;&lt;/a&gt;Java并发机制的底层实现原理&lt;/h1&gt;&lt;h2 id=&quot;1-Java运行过程&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="多线程编程系列" scheme="https://aaccompany.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="多线程编程" scheme="https://aaccompany.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>并发编程的挑战（第一章）</title>
    <link href="https://aaccompany.github.io/2020/01/31/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98/"/>
    <id>https://aaccompany.github.io/2020/01/31/并发编程的挑战/</id>
    <published>2020-01-30T16:00:00.000Z</published>
    <updated>2020-02-03T06:02:20.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程的挑战"><a href="#并发编程的挑战" class="headerlink" title="并发编程的挑战"></a>并发编程的挑战</h1><h2 id="1-什么是多线程？"><a href="#1-什么是多线程？" class="headerlink" title="1.什么是多线程？"></a>1.什么是多线程？</h2><h3 id="1-1-为什么要使用多线程？"><a href="#1-1-为什么要使用多线程？" class="headerlink" title="1.1.为什么要使用多线程？"></a>1.1.为什么要使用多线程？</h3><p><strong>并发编程的好处是为了提高系统运行速度</strong></p><p>并不是启动越多的线程系统的运行速度就能越快，因为在多线程编程中会存在各种坑。例如：死锁、线程的上下文切换、硬件、软件。</p><p>如果没有理解好这些各种各样的坑的话，那么写出来的多线程程序并不能提高系统运行速度，反而会降低系统的运行速度</p><h3 id="1-2-什么是线程的上下文切换"><a href="#1-2-什么是线程的上下文切换" class="headerlink" title="1.2.什么是线程的上下文切换"></a>1.2.什么是线程的上下文切换</h3><p>CPU（单核）在某个时刻只能有一个线程执行，那系统中存在那么多的线程该如何执行呢？</p><p>CPU通过给每个线程分配时间片来实现多线程的执行。（时间片：CPU将时间划分为一个个小的时间段，每个时间段处理一个线程）在一个时间片之后如果该线程没有执行完毕，那么就会保存该线程当前状态，并且加入下个待执行线程的状态，执行</p><p>CPU保存当前线程状态–&gt;加载下一个线程状态  ：这个过程为线程的上下文切换</p><p><strong>CPU线程的上下文切换会导致系统的运行速度低下</strong></p><h3 id="1-3-如何查看上下文切换次数和时长"><a href="#1-3-如何查看上下文切换次数和时长" class="headerlink" title="1.3.如何查看上下文切换次数和时长"></a>1.3.如何查看上下文切换次数和时长</h3><ul><li><code>Lmbench3</code>可以测量上下文切换的时长</li><li>Linux命令<code>vmstat</code>可以测量上下文切换次数</li></ul><h3 id="1-4-如何减少线程上下文切换"><a href="#1-4-如何减少线程上下文切换" class="headerlink" title="1.4.如何减少线程上下文切换"></a>1.4.如何减少线程上下文切换</h3><p>减少上下文切换的方法有无锁编程、<code>CAS</code>算法、使用最少线程和使用协程</p><ul><li>无锁并发编程：多线程竞争锁的时候，会引发频繁的上下文切换，所以在多线程处理数据的时，可以采用一些方法避免使用锁，例如将数据的ID进行Hash算法取模分段，不同的线程处理不同数据段</li><li><code>CAS</code>算法：Java的<code>Atomic</code>包下有许多类可以保证对单个变量的修改具有原子性，同时不会存在线程上下文切换，因为使用了自旋的模式来完成修改</li><li>使用最少线程：避免创建不需要的线程，比如系统任务量很少，但是线程数很多，导致会出现无用的线程上下文切换，所以在使用线程池的时候，并不是说将线程数设置越大越好，而是需要按需设置</li><li>协程：进程-&gt;线程-&gt;协程（上下级关系都为一对多），协程目前的多线程模型的最小单位，协程不由操作系统系统，而是由程序控制，减少了线程的上下文切换，因为根本不存在多线程。</li></ul><h2 id="2-锁"><a href="#2-锁" class="headerlink" title="2.锁"></a>2.锁</h2><h3 id="2-1-什么是锁？"><a href="#2-1-什么是锁？" class="headerlink" title="2.1.什么是锁？"></a>2.1.什么是锁？</h3><p>旅游的时候会出现一个现象，许许多多的人在厕所门口排队上厕所，而上厕所的步骤就是等待上个人<strong>开门</strong>出来-&gt;下个人进入<strong>锁门</strong></p><p>每个不同的人可以理解为不同的线程</p><p>厕所坑可以理解为临界资源</p><p>厕所坑一次只能有一个人蹲，所以人在上厕所的可以将门锁起来，让别人不能进来一起蹲</p><p>所以锁的作用可以理解为让满足条件的线程对临界资源访问</p><p>但是并不是说锁只能由一个线程持有，在读写锁<code>ReentrantReadWriteLock</code>，读锁和写锁互斥，读锁和读锁是共享。也就是说读锁和写锁在一个时刻中只用有一个持有锁，但是读锁和读锁能够同时持有锁</p><h3 id="2-2-死锁"><a href="#2-2-死锁" class="headerlink" title="2.2.死锁"></a>2.2.死锁</h3><ul><li><p>一个线程一直持有锁并且不释放锁，导致后面的线程无法执行</p></li><li><p>多个线程对多个资源获取顺序不一致导致相互等待对方释放资源，陷入死锁。例如 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程： t1 t2</span><br><span class="line">资源： AB</span><br><span class="line">资源： B   A</span><br><span class="line">这就会出现</span><br><span class="line">t1在等待B资源，但是B资源被t2持有</span><br><span class="line">t2在等待A资源，但是A资源被t1持有</span><br><span class="line">t1 t2 陷入相互等待的状态，这种状态也就是死锁</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-1-如何避免死锁"><a href="#2-2-1-如何避免死锁" class="headerlink" title="2.2.1.如何避免死锁"></a>2.2.1.如何避免死锁</h4><ul><li>避免一个线程持有多个锁</li><li>一定要在<code>finally</code>代码块中释放锁</li><li>避免在一段代码中使用多个锁，尽量做到一个代码块占用一个锁</li><li>尝试使用定时锁，避免重复等待锁资源<code>lock.tryLock(timeout)</code></li><li>对于数据库锁，加锁和解锁必须在同一个<code>Connection</code>中，否则会失效、并且会因为无法释放锁导致出现死锁</li></ul><h2 id="3-多线程编程与资源限制"><a href="#3-多线程编程与资源限制" class="headerlink" title="3.多线程编程与资源限制"></a>3.多线程编程与资源限制</h2><h3 id="3-1-什么是资源限制"><a href="#3-1-什么是资源限制" class="headerlink" title="3.1.什么是资源限制"></a>3.1.什么是资源限制</h3><p>多线程程序的运行速度并不是线程数多变快，而会受制于计算机的<strong>硬件资源和软件资源</strong></p><p>例如：服务器下载速度<code>2M/S</code>，客户端单线程下载某资源的速度是<code>1M/S</code>，这时候并不会因为开启10个线程而让客户端的下载速度达到<code>10M/S</code>（因为服务器最大下载速度是<code>2M/S</code>，所以客户端最大只能开启两个线程让下载速度到达<code>2M/S</code>)</p><p>所以在多线程编程中需要考虑资源限制这个问题。</p><ul><li>硬件资源：网络带宽、硬盘读写速度、CPU的处理速度</li><li>软件资源：数据库的最大连接数、socket的连接数</li></ul><h3 id="3-2-资源限制引发的问题"><a href="#3-2-资源限制引发的问题" class="headerlink" title="3.2.资源限制引发的问题"></a>3.2.资源限制引发的问题</h3><p>客户端如果是单核CPU，强行将代码由串行修改为并行，那么会因为客户端的单核CPU导致预计中的并行执行仍然在串行执行，这样会造成多余的线程上下文切换时间消耗。</p><p>所以多线程编程中需要考虑资源限制引发的问题（并未提高效率，反倒于效率下降）</p><h3 id="3-3-如何解决资源限制的问题"><a href="#3-3-如何解决资源限制的问题" class="headerlink" title="3.3.如何解决资源限制的问题"></a>3.3.如何解决资源限制的问题</h3><p>解决资源限制的方法，就要从为什么会出现资源限制中解决。</p><p>发生资源限制是因为 <strong>硬件限制、软件限制</strong> 那么解决这两个限制，就可从根本上解决问题</p><ul><li>解决硬件限制：单机处理速度跟不上，可以追加服务器数量，让运算在多机器上并发的执行</li><li>解决软件限制：合理提高连接池数量、socket连接数量、代码质量</li></ul><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ul><li>方腾飞：《Java并发编程的艺术》 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发编程的挑战&quot;&gt;&lt;a href=&quot;#并发编程的挑战&quot; class=&quot;headerlink&quot; title=&quot;并发编程的挑战&quot;&gt;&lt;/a&gt;并发编程的挑战&lt;/h1&gt;&lt;h2 id=&quot;1-什么是多线程？&quot;&gt;&lt;a href=&quot;#1-什么是多线程？&quot; class=&quot;header
      
    
    </summary>
    
      <category term="多线程编程系列" scheme="https://aaccompany.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="多线程编程" scheme="https://aaccompany.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>重走框架系列说明</title>
    <link href="https://aaccompany.github.io/2019/07/14/%E9%87%8D%E8%B5%B0%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97%E8%AF%B4%E6%98%8E/"/>
    <id>https://aaccompany.github.io/2019/07/14/重走框架系列说明/</id>
    <published>2019-07-14T11:47:47.000Z</published>
    <updated>2019-07-14T12:02:48.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重走框架系列说明"><a href="#重走框架系列说明" class="headerlink" title="重走框架系列说明"></a>重走框架系列说明</h1><h2 id="自我反思"><a href="#自我反思" class="headerlink" title="自我反思"></a>自我反思</h2><p>由于思想觉悟出现了问题，总想着快点学习，却没有想到丢了芝麻也丢了西瓜。</p><p>自己的基础严重的不牢固，导致前进的十分缓慢。又看了许多大神的教学视频，感觉自己依旧十分的弟弟，所以觉得自己有点揠苗助长，故有了重走框架系列，希望自己能够在这次重新学习后端框架的时候能够不断发现自己的知识盲区，找到自己的不足。</p><p>在重走框架的道路上，希望能够借助自己做的项目中，仔细思考在项目中引入新的后端框架会对系统增加严重的BUG，以及对这些BUG如何去做到预防以及解决。</p><p>借用《劝学》</p><p>故不积跬步，无以至千里，不积小流，无以成江海。</p><p>望自己能够一直记住。</p><p><img src="/2019/07/14/重走框架系列说明/1.gif" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重走框架系列说明&quot;&gt;&lt;a href=&quot;#重走框架系列说明&quot; class=&quot;headerlink&quot; title=&quot;重走框架系列说明&quot;&gt;&lt;/a&gt;重走框架系列说明&lt;/h1&gt;&lt;h2 id=&quot;自我反思&quot;&gt;&lt;a href=&quot;#自我反思&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="杂谈" scheme="https://aaccompany.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="https://aaccompany.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>重走spring框架 AOP部分</title>
    <link href="https://aaccompany.github.io/2019/07/14/%E9%87%8D%E8%B5%B0Spring%E6%A1%86%E6%9E%B6(AOP%E9%83%A8%E5%88%86)/"/>
    <id>https://aaccompany.github.io/2019/07/14/重走Spring框架(AOP部分)/</id>
    <published>2019-07-14T11:40:50.000Z</published>
    <updated>2020-02-01T11:11:32.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重走Spring框架（AOP部分）"><a href="#重走Spring框架（AOP部分）" class="headerlink" title="重走Spring框架（AOP部分）"></a>重走Spring框架（AOP部分）</h1><h2 id="1-分析银行转账流程"><a href="#1-分析银行转账流程" class="headerlink" title="1.分析银行转账流程"></a>1.分析银行转账流程</h2><h3 id="1-1-银行转账出现的问题"><a href="#1-1-银行转账出现的问题" class="headerlink" title="1.1.银行转账出现的问题"></a>1.1.银行转账出现的问题</h3><ul><li>从代码的角度上分析<ul><li>本次代码架构为：<code>spring + dbutils + c3p0</code></li><li>从下图代码可以分析出，如果某个流程出现了异常，那么就会出现数据不匹配的现象，即可能出现转账没有进入目标账户。</li><li>发生原因：<ul><li><code>queryRunner</code>对象在系统中采用的是多例模式，并且<code>queryRunner</code>在每次创建的时候会<code>DataSource.getConnection</code>意味着每次都是获取了新的连接对象，并且<code>QeuryRunner</code>对象在执行完语句后就会让内置的<code>connection</code>自动提交，将<code>QeuryRunner</code>对象中内置的<code>Connection</code>对象提取到<code>service</code>层便能在该层进行事务控制了。</li></ul></li><li>解决方案：<ul><li>将事务控制从<code>dao</code>层迁移到<code>service</code>层，让<code>service</code>具有<code>commit  rallback</code>的权利</li></ul></li><li><strong><code>ThreadLoad</code>数据和线程绑定？</strong><ul><li><code>ThreadLocal</code>是什么？<ul><li>这是一个与单个线程绑定的类，这个类会开在内存中开辟一个空间，专门存储这个线程专属数据，做到线程隔离。</li></ul></li><li><code>ThreadLocal</code>如何实现的？<ul><li>每个线程都会去维护一个<code>ThreadLocalMap</code>，在这个特殊的Map中，key指的是线程本身，而value是存储的值，所以能够实现一个独属单个线程的数据存储，做到线程隔离。</li></ul></li><li><code>ThreadLocal</code>存储的数据会一直存在吗？<ul><li>在<code>ThreadLocal</code>的值不会一直存在，当线程死亡的时候，存储的值的空间也会被归还，但是需要用到<code>JVM</code>的垃圾处理机制，但是如果我们能够确定什么时候使用完毕，那么我们可以自行删除数据，调用<code>ThreadLocal.remove()</code>便可以做到数据与线程解绑，加快垃圾回收。</li></ul></li></ul></li></ul></li></ul><p><img src="/2019/07/14/重走Spring框架(AOP部分)/8.jpg" alt></p><h4 id="1-1-1-第一次改良"><a href="#1-1-1-第一次改良" class="headerlink" title="1.1.1.第一次改良"></a>1.1.1.第一次改良</h4><ul><li><p>找到问题所在，将<code>Connection</code>与<code>ThreadLocal</code>线程绑定，保证在执行一次业务操作的时候使用的是同一个<code>Connection</code>同时在这个<code>Connection</code>中开启事务</p></li><li><p>流程图</p><p><img src="/2019/07/14/重走Spring框架(AOP部分)/9.jpg" alt></p></li><li><p><strong>第一步，创建<code>ConnectionUtils</code>：</strong>将原本注入到<code>QueryRunner</code>中的线程池取出来，改为由自己从<code>DataSource</code>获取<code>Connection</code>，将获取到的<code>Connection</code>与<code>ThreadLocal</code>进行线程绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Accompany</span></span><br><span class="line"><span class="comment"> * 获取当前线程的Connection</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Connection&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个连接对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Connection对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getThreadLocalConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection connection = threadLocal.get();</span><br><span class="line">            <span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//表示当前线程没有连接对象</span></span><br><span class="line">                connection = dataSource.getConnection();</span><br><span class="line">                threadLocal.set(connection);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> connection;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"出现未知异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解除线程与Connection的绑定关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>第二步，在<code>Service</code>层中开启事务：</strong>将<code>ConnectionUtils</code>注入到<code>Service</code>层中，获取到当前线程的<code>Connection</code>，然后开启线程并且传递到<code>dao</code>层中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String resourceId, String targetId, <span class="keyword">float</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取到当前线程的Connection对象</span></span><br><span class="line">        Connection connection = connectionUtils.getThreadLocalConnection();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//2.开启事务管理</span></span><br><span class="line">            connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//3.获取账户信息</span></span><br><span class="line">            Optional&lt;Account&gt; resourceOptional = accountDao.findById(resourceId);</span><br><span class="line">            Optional&lt;Account&gt; targetOptional = accountDao.findById(targetId);</span><br><span class="line">            <span class="keyword">if</span> (!resourceOptional.isPresent() || !targetOptional.isPresent())&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"用户不存在"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Account resourceAccount = resourceOptional.get();</span><br><span class="line">            Account targetAccount = targetOptional.get();</span><br><span class="line">            <span class="comment">//3.修改余额</span></span><br><span class="line">            <span class="keyword">float</span> resourceMoney = resourceAccount.getMoney() - money;</span><br><span class="line">            <span class="keyword">if</span> (resourceMoney&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"转账失败:余额不足"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            resourceAccount.setMoney(resourceMoney);</span><br><span class="line">            targetAccount.setMoney(targetAccount.getMoney() + money);</span><br><span class="line">            <span class="comment">//4.执行更新</span></span><br><span class="line">            accountDao.update(resourceAccount);</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">            accountDao.update(targetAccount);</span><br><span class="line">            <span class="comment">//5.提交更新</span></span><br><span class="line">            connection.commit();</span><br><span class="line">            <span class="comment">//6.将连接放回资源池</span></span><br><span class="line">            connection.close();</span><br><span class="line">            <span class="comment">//7.解除线程与Connection的绑定关系</span></span><br><span class="line">            connectionUtils.removeConnection();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">//8.发生异常回滚</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.rollback();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>第三步：</strong>在<code>Dao</code>层获取当前线程的<code>Connection</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Accompany</span></span><br><span class="line"><span class="comment"> * 账户Dao层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> QueryRunner runner;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRunner</span><span class="params">(QueryRunner runner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.runner = runner;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ConnectionUtils connectionUtils;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnectionUtils</span><span class="params">(ConnectionUtils connectionUtils)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connectionUtils = connectionUtils;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String sql = <span class="string">"insert into account values(?,?)"</span>;</span><br><span class="line">            runner.update(connectionUtils.getThreadLocalConnection(),sql,account.getId(),account.getMoney());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;Account&gt; <span class="title">findById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String sql = <span class="string">"select * from account where id = ?"</span>;</span><br><span class="line">            account = runner.query(connectionUtils.getThreadLocalConnection(),sql,<span class="keyword">new</span> BeanHandler&lt;&gt;(Account.class),id);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String sql = <span class="string">"update account set money = ? where id = ?"</span>;</span><br><span class="line">            runner.update(connectionUtils.getThreadLocalConnection(),sql,account.getMoney(),account.getId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-1-2-第二次改良"><a href="#1-1-2-第二次改良" class="headerlink" title="1.1.2.第二次改良"></a>1.1.2.第二次改良</h4><ul><li><p>从第一次改良中可以发现，在service层中出现了<code>try-catch</code>已经其嵌套，同时也导致了代码量变长了，可以适当的封装，让其客观性更好。</p></li><li><p>流程图：</p><p><img src="/2019/07/14/重走Spring框架(AOP部分)/10.jpg" alt></p></li><li><p><strong>第一步，新增事务控制器：</strong>由于事务操作在需要的业务操作中都会存在，可以适当进行抽取，以达到代码重用性高，客观性强的目的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Accompany</span></span><br><span class="line"><span class="comment"> * 事务管理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConnectionUtils connectionUtils;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnectionUtils</span><span class="params">(ConnectionUtils connectionUtils)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connectionUtils = connectionUtils;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionUtils.getThreadLocalConnection().setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionUtils.getThreadLocalConnection().commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回滚</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connectionUtils.getThreadLocalConnection().rollback();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将Connection放回连接池</span></span><br><span class="line">            connectionUtils.getThreadLocalConnection().close();</span><br><span class="line">            <span class="comment">//将Connection与线程解绑</span></span><br><span class="line">            connectionUtils.removeConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>第二步，修改<code>Service</code>：</strong>因为新增了事务管理器<code>TransactionManager</code>所以就不需要在<code>Service</code>中引用<code>Connection</code>来控制事务，而是将事务管理权交给了事务管理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Accompany</span></span><br><span class="line"><span class="comment"> * 账户业务层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(AccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> TransactionManager transactionManager;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransactionManager</span><span class="params">(TransactionManager transactionManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.transactionManager = transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String resourceId, String targetId, <span class="keyword">float</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.开启事务管理</span></span><br><span class="line">            transactionManager.beginTransaction();</span><br><span class="line">            <span class="comment">//3.获取账户信息</span></span><br><span class="line">            Optional&lt;Account&gt; resourceOptional = accountDao.findById(resourceId);</span><br><span class="line">            Optional&lt;Account&gt; targetOptional = accountDao.findById(targetId);</span><br><span class="line">            <span class="keyword">if</span> (!resourceOptional.isPresent() || !targetOptional.isPresent()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"用户不存在"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Account resourceAccount = resourceOptional.get();</span><br><span class="line">            Account targetAccount = targetOptional.get();</span><br><span class="line">            <span class="comment">//3.修改余额</span></span><br><span class="line">            <span class="keyword">float</span> resourceMoney = resourceAccount.getMoney() - money;</span><br><span class="line">            <span class="keyword">if</span> (resourceMoney &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"转账失败:余额不足"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            resourceAccount.setMoney(resourceMoney);</span><br><span class="line">            targetAccount.setMoney(targetAccount.getMoney() + money);</span><br><span class="line">            <span class="comment">//4.执行更新</span></span><br><span class="line">            accountDao.update(resourceAccount);</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            accountDao.update(targetAccount);</span><br><span class="line">            <span class="comment">//5.提交更新</span></span><br><span class="line">            transactionManager.commit();</span><br><span class="line">            <span class="comment">//6.释放资源</span></span><br><span class="line">            transactionManager.release();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            transactionManager.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-1-3-第三次改良"><a href="#1-1-3-第三次改良" class="headerlink" title="1.1.3.第三次改良"></a>1.1.3.第三次改良</h4><ul><li>从第二次改良中可以发现，针对一个业务如果需要进行事务控制增加了不少的代码，但是如果是针对很多个业务的话就会出现代码重复，并且也不能让程序员更加专注的处理业务需求（因为需要关注事务管理）。所以可以加入动态代理，去增强原本的<code>Servicec</code>层。</li><li>什么是动态代理？<ul><li>动态代理是在，</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重走Spring框架（AOP部分）&quot;&gt;&lt;a href=&quot;#重走Spring框架（AOP部分）&quot; class=&quot;headerlink&quot; title=&quot;重走Spring框架（AOP部分）&quot;&gt;&lt;/a&gt;重走Spring框架（AOP部分）&lt;/h1&gt;&lt;h2 id=&quot;1-分析银
      
    
    </summary>
    
      <category term="后端框架" scheme="https://aaccompany.github.io/categories/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="spring" scheme="https://aaccompany.github.io/tags/spring/"/>
    
      <category term="重走系列" scheme="https://aaccompany.github.io/tags/%E9%87%8D%E8%B5%B0%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>重走spring框架 IOC部分</title>
    <link href="https://aaccompany.github.io/2019/07/14/%E9%87%8D%E8%B5%B0spring%E6%A1%86%E6%9E%B6(IOC%E9%83%A8%E5%88%86)/"/>
    <id>https://aaccompany.github.io/2019/07/14/重走spring框架(IOC部分)/</id>
    <published>2019-07-14T11:40:50.000Z</published>
    <updated>2019-09-20T16:15:22.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h1><p>学习过程中的问题：</p><ul><li>为什么在使用JDBC使用的是<code>Class.forName(&quot;DriverName&quot;)</code> 而不是 <code>DriverManager.register(new Driver)</code>？</li><li>工厂模式的好处是什么？</li><li>工厂模式下创建的Bean对象应该为多例还是单例？</li><li>什么时候用多例什么时候用单例？</li><li>Spring是如何做到立即加载的？</li><li>Spring核心容器下两个顶级接口的区别是什么？（<code>BeanFactory/ApplicationContext</code>）</li><li>为什么使用XML配置Bean需要给属性设置set/get方法才能注入，而使用注解配置Bean不需要设置set/get方法就能注入？</li><li>配置注解类就取代掉配置文件，那么配置文件还有存在的意义吗？</li></ul><h2 id="1-Spring到底是个什么妖魔鬼怪？"><a href="#1-Spring到底是个什么妖魔鬼怪？" class="headerlink" title="1.Spring到底是个什么妖魔鬼怪？"></a>1.Spring到底是个什么妖魔鬼怪？</h2><h3 id="1-1-Spring的自我介绍？"><a href="#1-1-Spring的自我介绍？" class="headerlink" title="1.1.Spring的自我介绍？"></a>1.1.Spring的自我介绍？</h3><p>1）Spring是分层的 Java SE/EE应用 <strong>full-stack</strong> （提供了全栈式的解决方案）轻量级开源框架</p><p>2）以 <strong>IoC</strong>（Inverse Of Control： 反转控制）和 <strong>AOP</strong>（Aspect Oriented Programming：面向切面编程）为<strong>内核</strong></p><p>3）提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多 著名的第三方框架和类库</p><p>4）Java后端开发的标准 </p><h3 id="1-2-Spring的发展历程"><a href="#1-2-Spring的发展历程" class="headerlink" title="1.2. Spring的发展历程"></a>1.2. Spring的发展历程</h3><p>1997 年 IBM提出了EJB 的思想   </p><p>1998 年，SUN制定开发标准规范 EJB1.0   </p><p>1999 年，EJB1.1 发布   </p><p>2001 年，EJB2.0 发布   </p><p>2003 年，EJB2.1 发布   </p><p>2006 年，EJB3.0 发布   </p><p><strong>Rod Johnson（spring之父）</strong>   </p><p> Expert One-to-One J2EE Design and Development(2002)    阐述了 J2EE 使用EJB 开发设计的优点及解决方案   </p><p> Expert One-to-One J2EE Development without EJB(2004)    阐述了 J2EE 开发不使用 EJB的解决方式（Spring 雏形）      </p><p>2017 年 9 月份发布了 spring 的最新版本 spring 5.0 通用版（GA） </p><h3 id="1-3-为什么要使用Spring？"><a href="#1-3-为什么要使用Spring？" class="headerlink" title="1.3.为什么要使用Spring？"></a>1.3.为什么要使用Spring？</h3><p>1）方便解耦，简化开发</p><p>通过Spring提供的IOC（控制反转）容器，让Bean对象放入到Spring容器中，这样对象之间的依赖关系就可以由Spring去处理，避免硬编码造成程序耦合。也不需要注重Bean是设计成单例还是设计成多例的代码。可以花更多时间去注重上层代码</p><p>2）AOP支持(面向切面)</p><p>通过Spring提供的AOP支持，可以做到传统的OOP很难完成事情。</p><p>3）声明式事务的支持</p><p>可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理， 提高开发效率和质量。 </p><p>4）方便程序的测试 </p><p> 可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可 做的事情</p><p>5）方便集合各种优秀的框架</p><p>可以很快的整合Mybatis、Spring MVC 、Struts等框架。</p><p>6）降低了Java EE的API使用难度</p><p>在Spring中，对Java EE（如 JDBC、JavaMail、远程调用等）进行了一层封装，能够通过更少的代码去使用这些技术。</p><p>7）代码编写的榜样</p><p>Spring采用的代码编写的技巧，设计都十分巧妙，结构清晰，注释完整。是十分值得学习的榜样。</p><h3 id="1-4-Spring的体系结构"><a href="#1-4-Spring的体系结构" class="headerlink" title="1.4.Spring的体系结构"></a>1.4.Spring的体系结构</h3><p>在Spring的体系结构中也可以看出Spring是个<strong>full-stack</strong>型框架，提供了各层的解决方案。</p><p>其中重要的是Core Container中的部分，这是使用Spring必备部分，不可缺失。</p><p><img src="/2019/07/14/重走spring框架(IOC部分)/spring-overview.png" alt></p><h2 id="2-如何做到程序解耦？（IOC部分）"><a href="#2-如何做到程序解耦？（IOC部分）" class="headerlink" title="2.如何做到程序解耦？（IOC部分）"></a>2.如何做到程序解耦？（IOC部分）</h2><h3 id="2-1-程序的耦合和解耦"><a href="#2-1-程序的耦合和解耦" class="headerlink" title="2.1.程序的耦合和解耦"></a>2.1.程序的耦合和解耦</h3><p>在说明IOC先知道什么是程序的耦合和耦合</p><h4 id="2-1-1-程序的耦合？"><a href="#2-1-1-程序的耦合？" class="headerlink" title="2.1.1.程序的耦合？"></a>2.1.1.程序的耦合？</h4><p>在软件工程中，耦合指的就是就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。划分模块的一个 准则就是高内聚低耦合。</p><p> 它有如下分类： </p><p>模块耦合分为<strong>数据耦合、特征耦合、控制耦合、公共环境耦合、内容耦合</strong>。耦合程度由低到高。</p><p><strong>1）数据耦合：</strong></p><p>两个模块彼此间通过参数交换信息，而且交换的信息仅仅是数据（指的是单一的原子的数据片段），那么这种耦合称为数据耦合。<strong>数据耦合是低耦合。系统中至少必须存在这种耦合。这是不可避免的。</strong></p><p><strong>2）特征耦合</strong></p><p>当把整个<strong>数据结构</strong>作为参数、局部变量或者返回值，而被调用的模块只需要使用其中一部分数据元素时，就出现了特征耦合。（意思为传递了一个数据结构，但是调用方没有将该数据结构中全部数据使用便为特征耦合）</p><p>比如判断一个人是否成年，只需要传递该人的出生日期即可，不必要把人传进去。</p><p>因此这种耦合，通常是可以通过修改参数、局部变量或者返回值，只使用必要的数据元素来避免。</p><p><strong>3）控制耦合</strong></p><p>传递的信息中有控制信息(尽管有时这种控制信息以数据的形式出现)，则这种耦合称为控制耦合。控制耦合是中等程度的耦合。</p><p>比如，传递的参数中包含一个枚举类型的参数，在方法的具体逻辑中判断该参数实现不同的功能。<br>那么，完全可以通过将一个方法修改为多个方法改进这种耦合。</p><p><strong>4）公共环境耦合</strong></p><p>当两个或多个模块通过一个公共数据环境相互作用时，它们之间的耦合称为公共环境耦合。<br>公共环境可以是全程变量、共享的通信区、内存的公共覆盖区、任何存储介质上的文件、物理设备等。<br>公共环境耦合的复杂程度随耦合的模块个数而变化，当耦合的模块个数增加时复杂程度显著增加。</p><p>只有两个模块有公共环境，耦合有下面两种可能。</p><ol><li>一个模块往公共环境送数据，另一个模块从公共环境取数据。这是数据耦合的一种形式，是比较松散的耦合。</li><li>两个模块都既往公共环境送数据又从里面取数据，这种耦合比较紧密，介于数据耦合和控制耦合之间。</li></ol><p>限制范围，比如如果是依赖的是汇率，提供一个统一获汇率配置的方法，限制耦合范围。</p><p><strong>5）内容耦合</strong></p><p>最高程度的耦合是内容耦合。如果出现下列情况之一，两个模块间就发生了内容耦合。</p><ol><li>一个模块访问另一个模块的内部数据。</li><li>一个模块不通过正常入口而转到另一个模块的内部。</li><li>两个模块有一部分程序代码重叠(只可能出现在汇编程序中)。</li><li>一个模块有多个入口(这意味着一个模块有几种功能)。</li></ol><p>应该坚决避免使用内容耦合，重构吧。</p><h4 id="2-1-4-解决jdbc代码耦合"><a href="#2-1-4-解决jdbc代码耦合" class="headerlink" title="2.1.4.解决jdbc代码耦合"></a>2.1.4.解决jdbc代码耦合</h4><p><strong>思考1：</strong>为什么在使用JDBC使用的是<code>Class.forName(&quot;DriverName&quot;)</code> 而不是 <code>DriverManager.register(new Driver)</code>？</p><ul><li><p><strong>第一：</strong>使用<code>DriverManager.register</code> 会出现强依赖的现象</p><p>第一步出现了依赖现象，如果在Maven中没有导入jdbc的包则会在编译期出现错误。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.注册驱动 在这一步因为需要new 一个Driver对象，出现了强依赖</span></span><br><span class="line">      DriverManager.registerDriver(<span class="keyword">new</span> com.mysql.jdbc.Driver());</span><br><span class="line">      <span class="comment">//2.创建连接</span></span><br><span class="line">      Connection con = DriverManager.getConnection(<span class="string">"url"</span>,<span class="string">"username"</span>,<span class="string">"password"</span>);</span><br><span class="line">      <span class="comment">//3.使用连接，创建sql预处理对象</span></span><br><span class="line">      String sql = <span class="string">"select * from department"</span>;</span><br><span class="line">      PreparedStatement ps = con.prepareStatement(sql);</span><br><span class="line">      <span class="comment">//4.执行查询对象</span></span><br><span class="line">      ResultSet resultSet = ps.executeQuery();</span><br><span class="line">      <span class="comment">//5.遍历数据</span></span><br><span class="line">      <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">          System.out.print(resultSet.getString(<span class="string">"id"</span>));</span><br><span class="line">          System.out.print(resultSet.getString(<span class="string">"name"</span>));</span><br><span class="line">          System.out.println();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//6.释放资源</span></span><br><span class="line">      resultSet.close();</span><br><span class="line">      ps.close();</span><br><span class="line">      con.close();</span><br></pre></td></tr></table></figure><ul><li><p><strong>第二：</strong>如果使用的是<code>DriverManager.register</code>的方式去注册，那么驱动会被注册两次</p><p>第一次：从翻看源码中可以发现一旦  <code>com.mysql.Driver</code>  被加载，则会调用静态构造函数从而执行<code>java.sql.DriverManager.registerDriver(new Driver());</code>完成驱动注册</p><p>第二次：为自己在代码中手动注册了注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该mysql连接包的版本为5.1.46  在6.0+的版本中，就不使用com.mysql.Driver的类了</span></span><br><span class="line"><span class="comment">//而是使用com.mysql.cj.jdbc.Driver去完成注册操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Register ourselves with the DriverManager</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct a new driver and register it with DriverManager</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     *             if a database error occurs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>Class.forName(String driverName)</code>的好处</p><p>使用了这种方式传递的是字符串，所以并不会在编译期出现错误。从而减少了耦合度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.注册驱动 在这一步因为需要new 一个Driver对象，出现了强依赖</span></span><br><span class="line">      <span class="comment">//DriverManager.registerDriver(new com.mysql.jdbc.Driver());</span></span><br><span class="line">      <span class="comment">//在5.0的驱动版本中使用的是</span></span><br><span class="line">      <span class="comment">//Class.forName("com.mysql.jdbc.Driver()");</span></span><br><span class="line">      <span class="comment">// 在6.0+的驱动版本中使用的是</span></span><br><span class="line">      Class.forName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">      <span class="comment">//2.创建连接</span></span><br><span class="line">      Connection con = DriverManager.getConnection(<span class="string">"jdbc:mysql://120.76.56.183:33306/qingzhai_base"</span>,<span class="string">"root"</span>,<span class="string">"root"</span>);</span><br><span class="line">      <span class="comment">//3.使用连接，创建sql预处理对象</span></span><br><span class="line">      String sql = <span class="string">"select * from department"</span>;</span><br><span class="line">      PreparedStatement ps = con.prepareStatement(sql);</span><br><span class="line">      <span class="comment">//4.执行查询对象</span></span><br><span class="line">      ResultSet resultSet = ps.executeQuery();</span><br><span class="line">      <span class="comment">//5.遍历数据</span></span><br><span class="line">      <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">          System.out.print(resultSet.getString(<span class="string">"id"</span>));</span><br><span class="line">          System.out.print(resultSet.getString(<span class="string">"name"</span>));</span><br><span class="line">          System.out.println();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//6.释放资源</span></span><br><span class="line">      resultSet.close();</span><br><span class="line">      ps.close();</span><br><span class="line">      con.close();</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-1-3耦合总结"><a href="#2-1-3耦合总结" class="headerlink" title="2.1.3耦合总结"></a>2.1.3耦合总结</h4><p>总之，耦合是影响软件复杂程度的一个重要因素。<br>应该采取下述设计原则：<br><strong>尽量使用数据耦合，少用控制耦合和特征耦合，限制公共环境耦合的范围，完全不用内容耦合。</strong></p><p>ps: 编译器不依赖，运行期才依赖</p><h3 id="2-2-如何更加通用的方式解决程序耦合问题？"><a href="#2-2-如何更加通用的方式解决程序耦合问题？" class="headerlink" title="2.2.如何更加通用的方式解决程序耦合问题？"></a>2.2.如何更加通用的方式解决程序耦合问题？</h3><p>通过在2.1.4.中发现了可以使用字符串的方式减少了 new 关键字的出现，便减少程序的耦合度。由此可以进一步挖掘，是否在之后的new  对象的过程省略，而是使用字符串去完成对象的创建，这样便进一步的解决了系统的耦合度。</p><p>这时候就可以想到使用Java的反射，创建一个配置文件，在配置文件中，设置类的关键字映射到对应类的全路径上，通过反射完成对象的创建。</p><h4 id="2-2-1-使用工厂模式解耦"><a href="#2-2-1-使用工厂模式解耦" class="headerlink" title="2.2.1.使用工厂模式解耦"></a>2.2.1.使用工厂模式解耦</h4><h5 id="2-2-1-1-什么是工厂模式"><a href="#2-2-1-1-什么是工厂模式" class="headerlink" title="2.2.1.1.什么是工厂模式"></a>2.2.1.1.什么是工厂模式</h5><p><strong>个人理解：</strong>将创建的类的过程交由工厂去解决，工厂负责封装具体创建类的过程，只对外提供对应的方法，客户端只需要调用对应的接口便可以获取到对应的类。</p><p><strong>好处：</strong>通过工厂模式可以进一步解除系统耦合。</p><p><strong>图解：</strong></p><p>在未使用工厂模式下客户端直接获取资源(也就是new 对象)，这就造成了高耦合度，不易于扩展</p><p><img src="/2019/07/14/重走spring框架(IOC部分)/%E9%87%8D%E8%B5%B0spring%E6%A1%86%E6%9E%B6%5C1.jpg" alt></p><p>当使用了工厂模式情况下，客户端需要通过工厂去获取对象，而具体的实现过程被工厂隐藏，工厂读取配置文件，通过反射实例化对象，系统便具有了高扩展性。</p><p><img src="/2019/07/14/重走spring框架(IOC部分)/%E9%87%8D%E8%B5%B0spring%E6%A1%86%E6%9E%B6%5C2.jpg" alt></p><h5 id="2-2-1-2-简单使用工厂模式创建类"><a href="#2-2-1-2-简单使用工厂模式创建类" class="headerlink" title="2.2.1.2.简单使用工厂模式创建类"></a>2.2.1.2.简单使用工厂模式创建类</h5><p>简单使用：通过<code>BeanName</code>创建对象，减少耦合程度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : Accompany</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> :  2019/09/10</span></span><br><span class="line"><span class="comment"> * 实现类对象的创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties properties;</span><br><span class="line">    <span class="comment">//加载配置文件信息</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过类加载器读取配置文件</span></span><br><span class="line">            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(<span class="string">"application.properties"</span>);</span><br><span class="line">            properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            properties.load(in);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Object <span class="title">getBean</span><span class="params">(String beanName)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取到类路径</span></span><br><span class="line">        String beanPath = properties.getProperty(beanName);</span><br><span class="line">        <span class="comment">//创建类对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Class.forName(beanPath).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-1-3-完善工厂模式"><a href="#2-2-1-3-完善工厂模式" class="headerlink" title="2.2.1.3.完善工厂模式"></a>2.2.1.3.完善工厂模式</h5><p><strong>问题1：</strong>单例和多例的区别是什么？好处是什么？</p><p><strong>区别：</strong></p><ul><li>单例：多次通过工厂模式创建同一个对象只会在内存中存在一个实例。<ul><li>使用场景：在类中有共享数据或没有成员变量（例如 dao层 service层 ）</li><li>好处：因为只创建了一个实例，节省内存和JVM垃圾回收造成的性能浪费、可以存放共享数据（但是会存在线程安全问题）、效率会比多例模式快</li><li>坏处：因为是单例的所以会出现线程安全问题</li></ul></li><li>多例：每次通过工厂模式去创建同一个对象都会在内存中创建一个新的实例<ul><li>使用场景：当一个类只需要临时使用、每次都需要读最新的配置文件的时候可以使用。</li><li>好处：防止并发错误，如果在多线程的情况下，使用的是单例，假如修改了状态值，那么整个请求就会发生异常。</li><li>坏处：因为是不断的创建对象，就会占用大量的内存，同时也会导致<code>GC</code>的活动频繁导致性能下降。</li></ul></li></ul><p><strong>问题2：</strong>创建Bean应该为多例还是单例？</p><ul><li>具体问题需要具体分析<ul><li>像dao层和service层，没有了成员变量，在线程安全问题上就降低很多，可以使用单例模式</li><li>像controller层，在struts2中使用的是多例，但是在spring mvc中使用的是单例。</li></ul></li><li>当对象含有可改变状态时（更精确的说，在实际的应用中该状态会发生改变），使用多例，否则单例</li></ul><p><strong>修改代码：</strong>同时这也是spring的设计思想，当bean为单例的时候，会将对象在容器初始化的时候创建并且存进Map集合中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; objectMap;</span><br><span class="line">    <span class="comment">//加载配置文件信息</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过类加载器读取配置文件</span></span><br><span class="line">            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(<span class="string">"application.properties"</span>);</span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            objectMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">            properties.load(in);</span><br><span class="line">            <span class="comment">//将配置文件中全部的对象映射地址创建成对象封装到map集合中</span></span><br><span class="line">            Enumeration&lt;Object&gt; keys = properties.keys();</span><br><span class="line">            <span class="keyword">while</span> (keys.hasMoreElements())&#123;</span><br><span class="line">                <span class="comment">//读取某个对象路径地址</span></span><br><span class="line">                String objKey = (String) keys.nextElement();</span><br><span class="line">                String objPath = properties.getProperty(objKey);</span><br><span class="line">                Object object = Class.forName(objPath).newInstance();</span><br><span class="line">                objectMap.put(objKey,object);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Object <span class="title">getBean</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        未修改前</span></span><br><span class="line"><span class="comment">        //获取到类路径</span></span><br><span class="line"><span class="comment">        String beanPath = properties.getProperty(beanName);</span></span><br><span class="line"><span class="comment">        //创建类对象</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            return Class.forName(beanPath).newInstance();</span></span><br><span class="line"><span class="comment">        &#125; catch (InstantiationException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125; catch (IllegalAccessException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125; catch (ClassNotFoundException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return null;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (!objectMap.containsKey(beanName))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">"类不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objectMap.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-IOC是个啥玩意？"><a href="#2-3-IOC是个啥玩意？" class="headerlink" title="2.3. IOC是个啥玩意？"></a>2.3. IOC是个啥玩意？</h3><p>IOC ：inversion of control （控制反转），这是一种思想理念，并不是只有Spring独有的，在Spring中使用DI去实现了这种思想。</p><p>在Spring中的解释为将Bean的创建权、管理权转交由Spring去管理，这样程序员就不必过多的关注Bean的生命周期的问题了，可以更加关注于业务处理。</p><h4 id="2-3-1-Spring中IOC"><a href="#2-3-1-Spring中IOC" class="headerlink" title="2.3.1. Spring中IOC"></a>2.3.1. Spring中IOC</h4><ul><li><p>1）在工程的POM文件中导入Spring-Context的基本坐标,便具备了Spring IOC功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当导入文件会发现会多了很多依赖，对应1.4中Spring的体系结构，可以看出点端倪</p><ul><li><p>自动加入了<code>spring-apo</code>包，说明了Spring的基础功能需要依赖<code>spring-aop</code></p></li><li><p>spring中对apache.logging日志处理系统进行封装（<code>spring-jcl</code>包）这就需要注意，如果导入其他框架，该框架也有日志系统的话，那么就会出现冲突问题，这时候就需要解决了。</p></li></ul></li></ul><p><img src="/2019/07/14/重走spring框架(IOC部分)/%E9%87%8D%E8%B5%B0spring%E6%A1%86%E6%9E%B6%5C3.jpg" alt></p><ul><li><p>2）在resources目录下创建配置文件（<code>*.xml</code>）文件，该文件的作用为，阐述类的信息和类之间依赖关系</p><ul><li><p>配置文件信息</p><p>根据前面的如何自定义手动解耦的思想，那么可以知道，在配置文件中最起码需要具备 </p><p>一个标识符、标识符指向的类的全路径</p><p>所以在Spring的配置文件中便会出现Beans的大标签下有Bean的小标签代表着一个个的bean对象。</p><p>id便是标识符、class便是指向类的全路径</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.service.impl.studentServiceImpl"</span> <span class="attr">id</span>=<span class="string">"studentService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>3）在简单使用</p><ul><li><p>在ui中读取配置文件，并且将存储在spring IOC容器的对象取出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//读取配置文件</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"application.xml"</span>);</span><br><span class="line">        <span class="comment">//将对象从IOC容器中取出</span></span><br><span class="line">        studentService studentService = (studentService) context.getBean(<span class="string">"studentService"</span>);</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        studentService.findAll();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-3-2-Spring-的-BeanFactory-是什么？"><a href="#2-3-2-Spring-的-BeanFactory-是什么？" class="headerlink" title="2.3.2. Spring 的 BeanFactory 是什么？"></a>2.3.2. Spring 的 BeanFactory 是什么？</h4><p>BeanFactory是spring的工厂模式的顶级接口。同时可以从图中看出该接口具体很多实现类，到那时具体使用的只有三个。</p><ul><li><code>AnnotationConfigApplicationContext</code>：是有关于注解配置</li><li><code>ClassPathXMLApplicationContext</code>：读取src目录下的配置文件，也就是存放在resources下的配置文件</li><li><code>FileSystemXmlApplicationContext</code>：读取系统中绝对路径下XML文件文件（不推荐使用）</li></ul><p><img src="/2019/07/14/重走spring框架(IOC部分)/%E9%87%8D%E8%B5%B0spring%E6%A1%86%E6%9E%B6%5C4.jpg" alt></p><h4 id="2-3-3-BeanFacotry与ApplicationContext的区别"><a href="#2-3-3-BeanFacotry与ApplicationContext的区别" class="headerlink" title="2.3.3. BeanFacotry与ApplicationContext的区别"></a>2.3.3. BeanFacotry与ApplicationContext的区别</h4><p>BeanFacotry是一个顶级接口，而ApplicationContext是继承了BeanFactory下的HierarchicalBeanFactory也就是说，间接的继承了BeanFactory。</p><p><code>BeanFacotry</code>与<code>ApplicaitonContext</code>区别</p><ul><li><p>他们在创建Bean对象的时间点不同，</p><p><code>BeanFacotry</code>（实现类<code>XMLBeanFactory</code>已经弃用的对象）采用的策略是懒加载策略：</p><ul><li>懒加载：在Bean对象被使用的时候才被加载，容器初始化的时候不会被加载</li></ul><p><code>ApplicaitonContext</code>采用的策略是立即加载</p><ul><li>立即加载：在容器初始化的时候就被加载放进了Map集合</li></ul></li></ul><p>思考：什么时候使用懒加载什么时候使用立即加载呢？</p><p>单例模式使用立即加载</p><p>多例模式使用懒加载（因为多例模式最好是在需要的时候在去创建是最节省空间的）</p><h4 id="2-3-4-IOC中Bean标签和管理对象细节"><a href="#2-3-4-IOC中Bean标签和管理对象细节" class="headerlink" title="2.3.4. IOC中Bean标签和管理对象细节"></a>2.3.4. IOC中Bean标签和管理对象细节</h4><h5 id="2-3-4-1-Bean标签"><a href="#2-3-4-1-Bean标签" class="headerlink" title="2.3.4.1. Bean标签"></a>2.3.4.1. Bean标签</h5><p>bean标签存在的位置：在spring的配置文件中出现</p><p>作用：将对象的管理权交由spring管理</p><p>属性：</p><ul><li>id：指向全路径类的标识符（通常写成类名/接口名）</li><li>class：类的全路径信息</li><li>scope：指定类对象的作用范围<ul><li>singleton：默认值 单例</li><li><code>prototyoe</code>：多例</li><li><code>request</code>：WEB项目中，将该对象创建放进request域中</li><li><code>session</code>：WEB项目中，将该对象创建放进session域中</li><li><code>global session</code>：WEB项目中，应用在分布式环境下，将对象创建放进全局session中，如果不是分布式环境下，那么该配置相当于session</li></ul></li></ul><h5 id="2-3-4-2实例化Bean的三种方式"><a href="#2-3-4-2实例化Bean的三种方式" class="headerlink" title="2.3.4.2实例化Bean的三种方式"></a>2.3.4.2实例化Bean的三种方式</h5><ul><li><p><strong>第一种：通过构造函数去实例化Bean</strong></p><ul><li>在无参构造函数下实例化</li><li>参数说明：<ul><li><code>bean</code>：声明一个交由Spring IOC管理的Bean对象</li><li><code>id</code>：指向全路径类的标识符（通常写成类名/接口名）</li><li><code>class</code>：类的全路径信息</li></ul></li></ul><p>这种方式创建的对象是针对无参构造函数的，当存在有参构造函数的时候会出现错误</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentService"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.service.impl.studentServiceImpl"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在有参构造函数下实例化</li><li>参数说明<ul><li><code>constructor-arg</code>：阐述构造函数参数的信息<ul><li><code>name</code>：表示参数的名称</li><li><code>value</code>：插入基本数据类型和String类型</li><li><code>ref</code>：插入对象类型数据（该对象类型数据必须交由Spring管理才能注入）</li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"Student"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.bean.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"15"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"date"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"date"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>第二种：通过静态工厂模式实例化</strong></p><ul><li><p>该模式是当存在一个工厂，该工厂具有一个静态方法可以获取到一个对象，那么可以通过该方法获取到返回的对象直接放入spring容器中，无须将工厂注入也可以完成。<strong>（这种适用于框架整合，同时该方法必须为静态方法）</strong></p><p>工厂对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFacotry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">createStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        student.setName(<span class="string">"梨花"</span>);</span><br><span class="line">        student.setAge(<span class="number">11</span>);</span><br><span class="line">        student.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件：</p><ul><li>需要注意 class 写的是工厂类的全路径，factory-method 写的是从工厂获取到类的方法</li><li>不需要提供需要实例化的对象的全路径</li><li>如果方法中需要传值，那么就需要在实例化的对象中加入构造传值</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"StaticStudent"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.Factory.StaticFacotry"</span> <span class="attr">factory-method</span>=<span class="string">"createStudent"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>第三种：通过非静态工厂实例化</strong></p><ul><li><p>该模式是当存在一个工厂，该工厂具有一个非方法可以获取到一个对象，需要将工厂注入到Spring容器，再通过具体需要实例化的类去调用注入的工厂的方法完成实例化<strong>（这种适用于框架整合，这个工厂方法为非静态方法）</strong></p><p>工厂对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">createStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        student.setName(<span class="string">"张三丰"</span>);</span><br><span class="line">        student.setAge(<span class="number">100</span>);</span><br><span class="line">        student.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><ul><li>需要注意：在使用非静态工厂方法的时候<ul><li>1.先将工厂对象交由spring管理</li><li>2.在需要实例化的对象中加入 <code>factory-bean</code>：指向spring中工厂类</li><li>3.<code>factory-method</code>：为工厂类中提供对象的方法</li><li>4.在需要实例化的对象中不需要添加实例化对象的全路径</li><li>5.如果方法中需要传值，那么就需要在实例化的对象中加入构造传值</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"factory"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.Factory.Factory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">factory-bean</span>=<span class="string">"factory"</span> <span class="attr">factory-method</span>=<span class="string">"createStudent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"string"</span> <span class="attr">value</span>=<span class="string">"yyx"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2-3-4-3-Bean对象的生命周期"><a href="#2-3-4-3-Bean对象的生命周期" class="headerlink" title="2.3.4.3. Bean对象的生命周期"></a>2.3.4.3. Bean对象的生命周期</h5><p>不同的Bean对象作用范围，生命周期不同。</p><p>生命周期方法：在bean标签中</p><p><code>init-method</code>：Bean被初始化时调用</p><p><code>destory-method</code>：Bean被销毁时调用</p><ul><li><strong>scope=”singleton”：单例对象</strong> <ul><li>在整个应用中只会存在一个对象</li><li>生命周期<ul><li>对象初始化：当Spring 容器加载的时候，对象就开始初始化（前提是该对象为立即加载）</li><li>对象存活：只要容器在，那么对象就会存活</li><li>对象死亡：当容器死亡那么对象就死亡</li></ul></li></ul></li><li><strong>scope=”prototype”：多例对象</strong><ul><li>每次get都会创建新的对象</li><li>生命周期<ul><li>对象初始化：当调用了<code>getBean</code>的方法的时候开始完成对象的初始化</li><li>对象存活：只要对象任然在使用中，那么对象就一直存活</li><li>对象死亡：当对象没有被使用，等待<code>GC</code>回收，然后释放所占用的内存（需要注意，由于Spring不知道对象什么时候死亡，所以destroy-method 的方法是无法执行的）</li></ul></li></ul></li></ul><h4 id="2-3-5-DI（依赖注入）是个什么玩意？"><a href="#2-3-5-DI（依赖注入）是个什么玩意？" class="headerlink" title="2.3.5. DI（依赖注入）是个什么玩意？"></a>2.3.5. DI（依赖注入）是个什么玩意？</h4><h5 id="2-3-5-1-DI自述"><a href="#2-3-5-1-DI自述" class="headerlink" title="2.3.5.1. DI自述"></a>2.3.5.1. DI自述</h5><p>DI ：Dependency injection  也称为依赖注入，它是Spring框架IOC的具体实现</p><p>DI在Spring中的作用是，当容器运行时，能够将对象依赖的数据注入到对象中，比如通过构造方法注入属性，SET方法注入属性。</p><h5 id="2-3-5-2-为什么叫依赖注入呢？"><a href="#2-3-5-2-为什么叫依赖注入呢？" class="headerlink" title="2.3.5.2.为什么叫依赖注入呢？"></a>2.3.5.2.为什么叫依赖注入呢？</h5><p>例子：就像是 service层 需要依赖dao层  ，在交给Spring容器管理的时候， 就需要在service层中说明依赖了那个dao层接口，这样service层就可以使用dao层方法了。</p><p><strong>好处：</strong>通过将对象注入到对象，维护了类之间依赖关系。这种方式相比于传统模式下更加好，因为减少了硬编码，不需要在代码中写出具体的实现类是什么，而是通过在Bean工厂中获取到对应的实现类，这种方式减少耦合度，增加了系统的可扩展性。</p><p><strong>传统模式下的实现方式</strong></p><p><img src="/2019/07/14/重走spring框架(IOC部分)/5.jpg" alt></p><p><strong>DI方式下的实现方式</strong></p><p><img src="/2019/07/14/重走spring框架(IOC部分)/6.jpg" alt></p><h5 id="2-3-5-3-构造函数注入"><a href="#2-3-5-3-构造函数注入" class="headerlink" title="2.3.5.3. 构造函数注入"></a>2.3.5.3. 构造函数注入</h5><p>解释：在实例化Bean对象的时候，容器读取配置文件，通过构造函数去实例化对象。</p><p>好处：强制要求Bean对象在初始化一定要传递什么值。</p><p>坏处：不够灵活，如果有些值不必要传递那么就需要强硬的传值。</p><ul><li>参数说明<ul><li><code>constructor-arg</code>：阐述构造函数参数的信息<ul><li><code>name</code>：表示参数的名称</li><li><code>value</code>：插入基本数据类型和String类型</li><li><code>ref</code>：插入对象类型数据（该对象类型数据必须交由Spring管理才能注入）</li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"Student"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.bean.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"15"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"date"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"date"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-3-5-4-Set-方法注入"><a href="#2-3-5-4-Set-方法注入" class="headerlink" title="2.3.5.4. Set 方法注入"></a>2.3.5.4. Set 方法注入</h5><p>解释：通过给属性设置set方法，容器底层调用set方法将配置文件中对应属性的值注入到对象中。<strong>（属性值必须具有Set方法才能使用）</strong></p><p>好处：能够很灵活的给Bean对象注入属性值</p><p>坏处：有些属性必须赋值缺做不到，所以需要通过构造函数注入加上Set注入完成最佳化</p><p>参数说明</p><ul><li><code>property</code>：阐述构造函数参数的信息<ul><li><code>name</code>：set方法名，去掉set， 第一个字母小写</li><li><code>value</code>：插入基本数据类型和String类型</li><li><code>ref</code>：插入对象类型数据（该对象类型数据必须交由Spring管理才能注入）</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student1"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.bean.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"200"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"请勿打扰"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"date"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-3-5-5-p标签注入"><a href="#2-3-5-5-p标签注入" class="headerlink" title="2.3.5.5. p标签注入"></a>2.3.5.5. p标签注入</h5><p>解释：这种方式底层还是使用set方法注入，<strong>需要在引入约束头中加入p空间约束才能使用</strong></p><p>好处：更加简单使用set方法注入属性</p><p>坏处：需要在约束头中加入p空间约束才能使用</p><p>步骤：</p><ul><li>1.现在约束中加入p空间约束<strong>(在第二行)</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span>      </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>   </span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>2.在bean标签中使用P空间<ul><li>格式： <ul><li>调用set方法名：<code>set方法名，去掉set， 第一个字母小写</code> </li><li>基础数据类型/String数据类型：p: <code>调用set方法名</code>= “属性值”</li><li>对象数据类型：p: <code>调用set方法名</code>-ref = “属性值”</li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student2"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.bean.Student"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:age</span>=<span class="string">"250"</span> <span class="attr">p:name</span>=<span class="string">"我真帅"</span> <span class="attr">p:birthday-ref</span>=<span class="string">"date"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-3-5-6-注入集合属性数据"><a href="#2-3-5-6-注入集合属性数据" class="headerlink" title="2.3.5.6.注入集合属性数据"></a>2.3.5.6.注入集合属性数据</h5><p>Spring的DI可以给对象注入 数组，List，Set, Map, Properties的数据,同时也存在着一定的规律</p><ul><li><p>规律：</p><ul><li>数组,List,Set是同类型的数据结构，在声明数据结构的时候可以混用</li><li>Map,properties是同类型的数据结构，在声明数据结构的时候可以混用</li></ul></li><li><p>给对象注入数组类型（array | list | set）推荐使用 <code>&lt;list&gt; &lt;value&gt;20&lt;/value&gt; &lt;/list&gt;</code></p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student3"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.bean.Student"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"arr"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>5<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>10<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>15<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>20<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>25<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>30<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"set"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>300<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>键值对类型 （map | properties） 推荐使用<code>&lt;map&gt; &lt;entry key=&quot;aa&quot; value=&quot;AA&quot;/&gt; &lt;/map&gt;</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"aa"</span> <span class="attr">value</span>=<span class="string">"AA"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"bb"</span> <span class="attr">value</span>=<span class="string">"BB"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"cc"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"qq"</span> &gt;</span>QQ<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"ww"</span> &gt;</span>WW<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-IOC注解部分"><a href="#2-4-IOC注解部分" class="headerlink" title="2.4. IOC注解部分"></a>2.4. IOC注解部分</h3><h4 id="2-4-1-在Spring如何开启注解？"><a href="#2-4-1-在Spring如何开启注解？" class="headerlink" title="2.4.1. 在Spring如何开启注解？"></a>2.4.1. 在Spring如何开启注解？</h4><p>i.在Spring中，由于注解都是在类上的，又没有告知spring，所以可以知道，要开启注解需要告知spring 在哪里扫描类上的注解。</p><p>ii.在告知spring的时候 需要在命名空间加上有关于context 的约束</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启注解扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.accompany.spring.demo1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-4-2-IOC注解在Spring中的分类"><a href="#2-4-2-IOC注解在Spring中的分类" class="headerlink" title="2.4.2. IOC注解在Spring中的分类"></a>2.4.2. IOC注解在Spring中的分类</h4><h5 id="2-4-2-1-用于创建对象"><a href="#2-4-2-1-用于创建对象" class="headerlink" title="2.4.2.1.用于创建对象"></a>2.4.2.1.用于创建对象</h5><ul><li><p>这类型标签相当于在XML文件中加入了<code>&lt;bean&gt;</code>标签</p></li><li><p>注解：作用在具体的的实现类上</p><ul><li>@Component：声明将该类交由spring管理</li><li>@Service：声明该类为服务层对象，同时交由spring管理</li><li>@Repository：声明该类为数据持久层对象，同时交由spring管理</li><li>@Controller：声明该类为控制层对象，同时交由spring管理</li></ul></li><li><p>从源码的角度上分析，对于上面四种注解，@Service、@Repository、@Controller 都是由@Component衍生出来的。无论是@Service、@Repository、@Controller，在注解类上都会存在@Component注解，同时在属性上，也指向了Component的value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Repository &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment"> * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = Component.class)</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-4-2-2-用于数据注入"><a href="#2-4-2-2-用于数据注入" class="headerlink" title="2.4.2.2.用于数据注入"></a>2.4.2.2.用于数据注入</h5><ul><li><p>相当于在XML配置文件的<code>&lt;bean&gt;</code>标签中的<code>&lt;property&gt;</code>标签一致。</p></li><li><p><strong>缺点：</strong>无法给对象注入数组/集合类型数据</p></li><li><p>问题？：为什么使用XML配置Bean需要给属性设置set/get方法才能注入，而使用注解配置Bean不需要设置set/get方法就能注入？</p><ul><li><p>分析原因：是否走了set方法？</p><ul><li>给属性加入set方法进行标记，然后通过注解注入，最后发现并没有走自定义的set方法，说明了并不是使用set方法对属性值进行注入</li></ul></li><li><p>网上查询：读取类文件，通过反射暴力访问私有属性并且对其赋值，大致方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取class对象 （有三种方法）</span></span><br><span class="line">      <span class="comment">//i.通过类名称获取  类名.class;</span></span><br><span class="line">      <span class="comment">//ii.通过对象获取    对象名.getClass()</span></span><br><span class="line">      <span class="comment">//iii.通过类的全路径获取    Class.forName("classPath")</span></span><br><span class="line">      Class&lt;StudentServiceImpl2&gt; c = StudentServiceImpl2.class;</span><br><span class="line">      <span class="comment">//2.通过反射实例化对象</span></span><br><span class="line">      StudentServiceImpl2 rs = c.newInstance();</span><br><span class="line">      <span class="comment">//3.类的属性字段</span></span><br><span class="line">      Field field = c.getDeclaredField(<span class="string">"s1"</span>);</span><br><span class="line">      <span class="comment">//4.设置属性字段允许暴力访问</span></span><br><span class="line">      field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">//5.设置字段值</span></span><br><span class="line">      field.set(rs,<span class="string">"yyx你真帅"</span>);</span><br><span class="line">      rs.print();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>注解：作用在属性上</p><ul><li><p>注入对象数据类型</p><ul><li><p><code>@Autowired</code>：从IOC容器中找到类型<strong>唯一且一致</strong>的对象注入。需要注意，当IOC存在多个类型一致的对象，那么在注入的时候，会先找到一批类型一致的对象，在找到属性名称与存储在IOC容器属性名称一致的对象注入。</p><ul><li>图解</li></ul><p><img src="/2019/07/14/重走spring框架(IOC部分)/7.jpg" alt></p><ul><li>@Qualifier：与<code>@Autowired</code>配合使用，通过@Qualifier(value=”bean Name”)指定在IOC容器中对应Bean的KEY值，解决了找不到唯一对象注入的问题</li></ul></li><li><p>@Resource(name=”bean Name”)：在IOC容器中找到同数据类型相同且名称等于bean Name的对象注入</p></li></ul></li></ul></li></ul><ul><li><p>注入基础数据类型/String数据类型</p><ul><li>@Value(value=”xx “)：将xx的值直接注入到属性上</li></ul></li></ul><h5 id="2-4-2-3-用于改变作用范围"><a href="#2-4-2-3-用于改变作用范围" class="headerlink" title="2.4.2.3.用于改变作用范围"></a>2.4.2.3.用于改变作用范围</h5><ul><li>相当于在XML配置文件的<code>&lt;bean&gt;</code>标签中加入了<code>Scope=&quot;singleton/prototype...&quot;</code></li><li>注解：作用在类上<ul><li>@Scope(“singleton/prototype…”)</li></ul></li></ul><h5 id="2-4-2-4-和生命周期相关"><a href="#2-4-2-4-和生命周期相关" class="headerlink" title="2.4.2.4.和生命周期相关"></a>2.4.2.4.和生命周期相关</h5><ul><li>相当于在XML配置文件的<code>&lt;bean&gt;</code>标签中加入了<code>init-method=&quot;&quot; destroy-method=&quot;&quot;</code></li><li>注解：作用在方法上<ul><li><code>@PostConstruct</code>：类加载时运行（单例模式执行一次，多例模式获取一次执行一次）</li><li><code>@PreDestroy</code>：类销毁时运行（单例：容器关闭执行，多例不执行）</li></ul></li></ul><h4 id="2-4-3-配置信息类注解"><a href="#2-4-3-配置信息类注解" class="headerlink" title="2.4.3. 配置信息类注解"></a>2.4.3. 配置信息类注解</h4><h5 id="2-4-3-1-配置信息类有什么用？"><a href="#2-4-3-1-配置信息类有什么用？" class="headerlink" title="2.4.3.1.配置信息类有什么用？"></a>2.4.3.1.配置信息类有什么用？</h5><h5 id="2-4-3-2-用于声明该类为配置类"><a href="#2-4-3-2-用于声明该类为配置类" class="headerlink" title="2.4.3.2.用于声明该类为配置类"></a>2.4.3.2.用于声明该类为配置类</h5><ul><li>相当于XML配置文件本身</li><li>使用说明：跟XML配置差不多，在启动的时候使用<code>ApplicationContext context = new AnnotationConfigApplicationContext(xxx.class...)</code>需要告知主配置类的位置。当使用new 然后传递配置类的时候，可以不用在类上标记注解。同时也可以认为这个类是主配置类。</li><li>注解：作用在类上<ul><li><code>@Configuration</code>：在某些情况下可以不加此注解<ul><li><code>@Import(xxx.class...)</code>在配置类上导入其他配置类，一般放在主配置类上，导入其他配置类（被导入的配置类可以不用加入<code>@Configuration</code>注解）</li></ul></li></ul></li></ul><h5 id="2-4-3-3-包扫描"><a href="#2-4-3-3-包扫描" class="headerlink" title="2.4.3.3.包扫描"></a>2.4.3.3.包扫描</h5><ul><li><p>相当于在XML配置文件中加入了<code>&lt;context:component-scan base-package=&quot;xx&quot; /&gt;</code></p></li><li><p>注解：</p><ul><li><code>@ComponentScan(&quot;pakeage Path&quot;)</code>：配置单个扫描包</li><li><code>@ComponentScan({&quot;xx&quot;,&quot;yy&quot;})</code>：配置多个扫描包</li></ul></li><li><p>注解源码：可以看出 value 和 basePackages 相互指向，所以在传参时，用那个都行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Alias for &#123;<span class="doctag">@link</span> #basePackages&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Allows for more concise annotation declarations if no other attributes</span></span><br><span class="line"><span class="comment"> * are needed &amp;mdash; for example, &#123;<span class="doctag">@code</span> <span class="doctag">@ComponentScan</span>("org.my.pkg")&#125;</span></span><br><span class="line"><span class="comment"> * instead of &#123;<span class="doctag">@code</span> <span class="doctag">@ComponentScan</span>(basePackages = "org.my.pkg")&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"basePackages"</span>)</span><br><span class="line">String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base packages to scan for annotated components.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&#123;<span class="doctag">@link</span> #value&#125; is an alias for (and mutually exclusive with) this</span></span><br><span class="line"><span class="comment"> * attribute.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Use &#123;<span class="doctag">@link</span> #basePackageClasses&#125; for a type-safe alternative to</span></span><br><span class="line"><span class="comment"> * String-based package names.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-4-3-4-用于将方法返回的对象放进容器"><a href="#2-4-3-4-用于将方法返回的对象放进容器" class="headerlink" title="2.4.3.4.用于将方法返回的对象放进容器"></a>2.4.3.4.用于将方法返回的对象放进容器</h5><ul><li>相当于在XML加入了<code>&lt;bean&gt;</code>标签，不过和<code>@Component</code>不同的是，<code>@Bean</code>作用在方法上而<code>@Component</code>作用在类上</li><li>问题：<ul><li>1.如果返回值不是对象，而是基本数据类型，那么是会报错还是会发生什么？<ul><li>根据测试得知，是不会报错，而是会将基本数据类型存进容器，id为方法名（觉得自己很蠢，万物皆对象啊！！！！）</li></ul></li><li>2.如果方法中有参数，如何给参数传递值？<ul><li>当Spring读取到被<code>@Bean</code>控制方法时，参数注入形式是与<code>@Autowired</code>一致，所以根据这个可知，可以与<code>@Qualifier</code>一同使用达到根据id获取到具体Bean对象。</li></ul></li></ul></li><li>注解：可以与<code>@Scope</code>注解配合使用，控制作用范围<ul><li><code>@Bean(name=&quot;id&quot;)</code>：name=”id” 属性值 可加可不加，当不加入的时候，id为方法名。</li></ul></li></ul><h5 id="2-4-3-5-用于读取配置文件"><a href="#2-4-3-5-用于读取配置文件" class="headerlink" title="2.4.3.5.用于读取配置文件"></a>2.4.3.5.用于读取配置文件</h5><ul><li>相当于再XML加入了<code>&lt;context:property-placeholder location=``&quot;classpath:conf/*.properties&quot;</code> `file-encoding=<code>&quot;UTF-8&quot;</code>/&gt;</li><li>注意：无法读取<code>yml</code>文件</li><li>注解：<code>classpath</code>是定义在注解里面特殊字符，表示在类路径找文件，默认采用的是<code>UTF-8</code>解码<ul><li><code>@PropertyScource(&quot;classpath:xxx&quot;)</code></li></ul></li></ul><h4 id="3-4-4-问题"><a href="#3-4-4-问题" class="headerlink" title="3.4.4.问题"></a>3.4.4.问题</h4><ul><li>配置注解类就取代掉配置文件，那么配置文件还有存在的意义吗？<ul><li>全注解开发：<ul><li>好处：不用写XML配置文件，更简单的配置Bean对象，完成注入等一系列问题。</li><li>坏处：由于注解都是写在类上，当类的数量多了起来，那么在后期维护的时候找起来也是一个问题。</li></ul></li><li>纯XML配置开发：<ul><li>好处：在XML配置文件中配置可以很广泛的知道在系统中配置了多个Bean，以及注入信息是什么，作用范围是什么。</li><li>坏处：XML配置是繁琐的，厚重的。</li></ul></li><li>半注解半配置开发：<ul><li>好处：在一定程度上结合了全注解开发以及纯XML配置开发的好处。</li><li>什么时候用？：当开发自定义类的时候可以使用注解开发，当配置其他框架的类的时候可以使用XML配置模式开发。</li></ul></li></ul></li></ul><h2 id="3-有关于整合-Junit"><a href="#3-有关于整合-Junit" class="headerlink" title="3.有关于整合 Junit"></a>3.有关于整合 Junit</h2><h3 id="3-1-分析问题"><a href="#3-1-分析问题" class="headerlink" title="3.1.分析问题"></a>3.1.分析问题</h3><p>在测试类中，如果是spring项目测试，就永远离不开IOC容器，但是Junit是不知道是否使用spring，以及配置文件在何处（或主配置类）在何处。</p><p>所以也就离不开两句话，同时也不支持注入到测试类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取XML配置或去读配置类</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationConfig.class);</span><br><span class="line"><span class="comment">//获取对应的对象</span></span><br><span class="line">Object a = context.getBean(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure><h3 id="3-2-解决问题思路"><a href="#3-2-解决问题思路" class="headerlink" title="3.2.解决问题思路"></a>3.2.解决问题思路</h3><p>需要让Junit在启动的时候就运行Spring，这样就可以完成在测试中加入注入属性，而不是通过context去获取，但是如何去做？就需要做到替换Junit的启动器<code>Runner</code>成spring自定义的启动器。</p><h3 id="3-3-代码实现"><a href="#3-3-代码实现" class="headerlink" title="3.3.代码实现"></a>3.3.代码实现</h3><ul><li><p>1.导入有关于测试对应的坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring与junit整合包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--junit --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>2.在测试类上加入注解</p><ul><li><code>@Runwith(SpringJUnit4ClassRunner.class)</code>：表示使用<code>Spring-Test</code>提供的<code>Runner</code>启动器</li><li><code>@ContextConfiguration()</code>：表示配置文件位置或者配置类的位置<ul><li>属性值：<ul><li><code>value=&quot;classpath: &quot;</code>：表示使用XML配置文件，同时在类路径下查找文件</li><li><code>classes=&quot;xxx.class...&quot;</code>：表示使用注解类</li></ul></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = ApplicationConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a:"</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring框架&quot;&gt;&lt;a href=&quot;#Spring框架&quot; class=&quot;headerlink&quot; title=&quot;Spring框架&quot;&gt;&lt;/a&gt;Spring框架&lt;/h1&gt;&lt;p&gt;学习过程中的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么在使用JDBC使用的是&lt;code&gt;Cla
      
    
    </summary>
    
      <category term="后端框架" scheme="https://aaccompany.github.io/categories/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="spring" scheme="https://aaccompany.github.io/tags/spring/"/>
    
      <category term="重走系列" scheme="https://aaccompany.github.io/tags/%E9%87%8D%E8%B5%B0%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Active消息中间件</title>
    <link href="https://aaccompany.github.io/2019/07/02/Active%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://aaccompany.github.io/2019/07/02/Active消息中间件/</id>
    <published>2019-07-02T02:13:52.000Z</published>
    <updated>2019-07-10T05:08:29.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h1><p>当没有采用消息中间件的系统模块图,当运营商后台去调用搜索服务和页面生成服务的时候，不需要知道他们返回的结果，所以在这里为了提高效率、降低系统耦合度可以采用消息中间件的解决方案。</p><p><img src="/2019/07/02/Active消息中间件/01.png" alt="01"></p><p>当采用了消息中间件之后的系统模块图，中间去除了dubbo和减少了对搜索服务和页面生成服务的依赖，降低了系统耦合度</p><p><img src="/2019/07/02/Active消息中间件/02.png" alt></p><h2 id="1-什么是消息中间件"><a href="#1-什么是消息中间件" class="headerlink" title="1.什么是消息中间件"></a>1.什么是消息中间件</h2><p>消息中间件利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在<strong><em>分布式环境</em></strong>下扩展进程间的通信。对于消息中间件，常见的角色大致也就有Producer（生产者）、Consumer（消费者）</p><p>1.1常见的消息中间件产品</p><p>JMS:JAVA MESSAGE SERVICE</p><p>（1）ActiveMQ</p><p>ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。</p><p>（2）RabbitMQ</p><p>AMQP协议的领导实现，支持多种场景。淘宝的MySQL集群内部有使用它进行通讯，OpenStack开源云平台的通信组件，最先在金融行业得到运用。</p><p>（3）ZeroMQ</p><p>史上最快的消息队列系统</p><p>（4）Kafka</p><p>Apache下的一个子项目 。特点：高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统。适合处理海量数据。</p><h3 id="1-1-什么是JMS"><a href="#1-1-什么是JMS" class="headerlink" title="1.1.什么是JMS"></a>1.1.什么是JMS</h3><p>JMS（<a href="http://lib.csdn.net/base/java" target="_blank" rel="noopener"><strong>Java</strong> </a>Messaging Service）是Java平台上有关面向消息中间件的技术规范，它便于消息系统中的Java应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发。</p><p>​       JMS本身只定义了一系列的接口规范，是一种与厂商无关的 API，用来访问消息收发系统。它类似于 JDBC(<a href="http://lib.csdn.net/base/java" target="_blank" rel="noopener"><strong>java</strong> </a>Database Connectivity)：这里，JDBC 是可以用来访问许多不同关系<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="noopener"><strong>数据库</strong></a>的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。许多厂商目前都支持 JMS，包括 IBM 的 MQSeries、BEA的 Weblogic JMS service和 Progress 的 SonicMQ，这只是几个例子。 JMS 使您能够通过消息收发服务（有时称为消息中介程序或路由器）从一个 JMS 客户机向另一个 JML 客户机发送消息。消息是 JMS 中的一种类型对象，由两部分组成：报头和消息主体。报头由路由信息以及有关该消息的元数据组成。消息主体则携带着应用程序的数据或有效负载。</p><p>JMS 定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一</p><p>些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p><p>· TextMessage–一个字符串对象</p><p>· MapMessage–一套名称-值对</p><p>· ObjectMessage–一个序列化的 Java 对象</p><p>· BytesMessage–一个字节的数据流</p><p>· StreamMessage – Java 原始值的数据流</p><h3 id="1-2-JMS消息传递"><a href="#1-2-JMS消息传递" class="headerlink" title="1.2.JMS消息传递"></a>1.2.JMS消息传递</h3><p>在消息传递存在两种类型：</p><h4 id="1-2-1-点对点"><a href="#1-2-1-点对点" class="headerlink" title="1.2.1.点对点"></a>1.2.1.点对点</h4><p>一个生产者会对应一个消费者，一个生成者发布的消息会存放在队列中，然后消费者不一定需要及时将队列的数据取出，而是可以不定时的去获取数据。当数据被取出的时候队列中的消息就会减少一条。</p><p>当存在多个消费者监听的队列是同一个的时候，谁先监听消息队列谁就先获取到数据。</p><p><img src="/2019/07/02/Active消息中间件/03.png" alt></p><h4 id="1-2-2-发布-订阅"><a href="#1-2-2-发布-订阅" class="headerlink" title="1.2.2.发布/订阅"></a>1.2.2.发布/订阅</h4><p>一个生产者会对应多个消费者，当一个生产者发布了一条信息，会将数据存放在topic中，然后即时发生给每个在线的消费者，类似与广播的特性。</p><p>当有一个消费者没有上线的时候，会接受不到广播。</p><p><img src="/2019/07/02/Active消息中间件/04.png" alt></p><h2 id="2-ActiveMQ安装（Linux）"><a href="#2-ActiveMQ安装（Linux）" class="headerlink" title="2.ActiveMQ安装（Linux）"></a>2.ActiveMQ安装（Linux）</h2><p>（1）将apache-activemq-5.12.0-bin.tar.gz 上传至服务器</p><p>（2）解压此文件</p><p>   tar  zxvf    apache-activemq-5.12.0-bin.tar.gz   </p><p>（3）为apache-activemq-5.12.0目录赋权</p><p> <code>chmod 777 apache-activemq-5.12.0</code></p><p>（4）进入apache-activemq-5.12.0\bin目录</p><p>（5）赋与执行权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   chmod <span class="number">755</span> activemq    </span><br><span class="line">--------------------------  **知识点小贴士**------------------------   </span><br><span class="line">linux 命令chmod <span class="number">755</span>的意思   </span><br><span class="line">chmod是 Linux 下设置文件权限的命令，后面的数字表示不同用户或用户组的权限。   </span><br><span class="line">一般是三个数字：    </span><br><span class="line">第一个数字表示文件所有者的权限    </span><br><span class="line">第二个数字表示与文件所有者同属一个用户组的其他用户的权限    </span><br><span class="line">第三个数字表示其它用户组的权限。         </span><br><span class="line">权限分为三种：读（r=<span class="number">4</span>），写（w=<span class="number">2</span>），执行（x=<span class="number">1</span>） 。 </span><br><span class="line">综合起来还有可读可执行（rx=<span class="number">5</span>=<span class="number">4</span>+<span class="number">1</span>）、</span><br><span class="line">可读可写（rw=<span class="number">6</span>=<span class="number">4</span>+<span class="number">2</span>）、</span><br><span class="line">可读可写可执行(rwx=<span class="number">7</span>=<span class="number">4</span>+<span class="number">2</span>+<span class="number">1</span>)。         </span><br><span class="line">所以，chmod <span class="number">755</span> 设置用户的权限为：    </span><br><span class="line"><span class="number">1</span>.文件所有者可读可写可执行       --<span class="number">7</span>   </span><br><span class="line"><span class="number">2</span>.与文件所有者同属一个用户组的其他用户可读可执行 --<span class="number">5</span>     </span><br><span class="line"><span class="number">3</span>.其它用户组可读可执行                                            --<span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="1-3-3启动"><a href="#1-3-3启动" class="headerlink" title="1.3.3启动"></a>1.3.3启动</h3><p>​    ./activemq start   </p><p>出现下列提示表示成功！</p><p><img src="/2019/07/02/Active消息中间件/05.png" alt></p><p>假设服务器地址为192.168.25.135 ，打开浏览器输入地址</p><p><a href="http://192.168.25.129:8161/" target="_blank" rel="noopener">http://192.168.25.135:8161/</a> 即可进入ActiveMQ管理页面</p><p><img src="/2019/07/02/Active消息中间件/06.png" alt></p><p>点击进入管理页面</p><p><img src="/2019/07/02/Active消息中间件/07.png" alt></p><p>输入用户名和密码  均为 admin </p><p><img src="/2019/07/02/Active消息中间件/08.png" alt></p><p>进入主界面</p><p><img src="/2019/07/02/Active消息中间件/09.png" alt></p><p>点对点消息列表：</p><p><img src="/2019/07/02/Active消息中间件/10.png" alt></p><p>列表各列信息含义如下：</p><p><strong>Number Of Pending Messages</strong>  <strong>：</strong>等待消费的消息 这个是当前未出队列的数量。</p><p><strong>Number Of Consumers</strong>  <strong>：</strong>消费者 这个是消费者端的消费者数量</p><p><strong>Messages Enqueued</strong>  <strong>：</strong>进入队列的消息  进入队列的总数量,包括出队列的。</p><p><strong>Messages Dequeued</strong>  <strong>：</strong>出了队列的消息  可以理解为是消费这消费掉的数量。</p><h2 id="3-JMS入门小Demo"><a href="#3-JMS入门小Demo" class="headerlink" title="3.JMS入门小Demo"></a>3.JMS入门小Demo</h2><h3 id="3-1点对点Demo"><a href="#3-1点对点Demo" class="headerlink" title="3.1点对点Demo"></a>3.1点对点Demo</h3><p>点对点的模式主要建立在一个队列上面，当连接一个列队的时候，发送端不需要知道接收端是否正在接收，可以直接向ActiveMQ发送消息，发送的消息，将会先进入队列中，如果有接收端在监听，则会发向接收端，如果没有接收端接收，则会保存在ActiveMQ服务器，直到接收端接收消息，点对点的消息模式可以有多个发送端，多个接收端，但是一条消息，只会被一个接收端给接收到，哪个接收端先连上ActiveMQ，则会先接收到，而后来的接收端则接收不到那条消息。</p><h4 id="3-1-1添加依赖"><a href="#3-1-1添加依赖" class="headerlink" title="3.1.1添加依赖"></a>3.1.1添加依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.13.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-1-2生产者代码"><a href="#3-1-2生产者代码" class="headerlink" title="3.1.2生产者代码"></a>3.1.2生产者代码</h4><p>注意：</p><p>1)在地址中传输协议为tcp</p><p>2）在第四步骤中的参数说明</p><p>第一个参数：是否开启事务</p><p>第二个参数消息的确定模式</p><ul><li>AUTO_ACKNOWLEDGE = 1    自动确认</li><li>CLIENT_ACKNOWLEDGE = 2    客户端手动确认   </li><li>DUPS_OK_ACKNOWLEDGE = 3    自动批量确认</li><li>SESSION_TRANSACTED = 0    事务提交并确认</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//1.创建连接工厂</span></span><br><span class="line"><span class="comment">//说明：使用想对应的是厂商的连接工厂</span></span><br><span class="line">ConnectionFactory  connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://120.76.56.183:61616"</span>);</span><br><span class="line"><span class="comment">//2.创建连接</span></span><br><span class="line">Connection connection = connectionFactory.createConnection();</span><br><span class="line"><span class="comment">//3.启动连接</span></span><br><span class="line">connection.start();</span><br><span class="line"><span class="comment">//4.获取session</span></span><br><span class="line"><span class="comment">//参数说明：1.是否启用事务2.消息确认模式</span></span><br><span class="line">Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"><span class="comment">//5.创建消息队列 </span></span><br><span class="line"><span class="comment">//参数说明：队列的名称</span></span><br><span class="line">Queue queue = session.createQueue(<span class="string">"test-queue"</span>);</span><br><span class="line"><span class="comment">//6.创建生产者  参数说明：生产者使用那个消息对象</span></span><br><span class="line">MessageProducer producer = session.createProducer(queue);</span><br><span class="line"><span class="comment">//7.创建消息</span></span><br><span class="line">TextMessage message = session.createTextMessage(<span class="string">"你真是个大傻吊"</span>);</span><br><span class="line"><span class="comment">//8.发生消息</span></span><br><span class="line">producer.send(message);</span><br><span class="line"><span class="comment">//9.关闭资源</span></span><br><span class="line">producer.close();</span><br><span class="line">session.close();</span><br><span class="line">connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-3消费者代码"><a href="#3-1-3消费者代码" class="headerlink" title="3.1.3消费者代码"></a>3.1.3消费者代码</h4><p>注意：需要创建匿名内部类 Message Listener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//1.创建连接工厂</span></span><br><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://120.76.56.183:61616"</span>);</span><br><span class="line"><span class="comment">//2.创建连接</span></span><br><span class="line">Connection connection = connectionFactory.createConnection();</span><br><span class="line"><span class="comment">//3.启动连接</span></span><br><span class="line">connection.start();</span><br><span class="line"><span class="comment">//4.获取session</span></span><br><span class="line">Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"><span class="comment">//5.监听对应的消息队列</span></span><br><span class="line">Queue queue = session.createQueue(<span class="string">"test-queue"</span>);</span><br><span class="line"><span class="comment">//6.由会话，创建消息消费者</span></span><br><span class="line">MessageConsumer consumer = session.createConsumer(queue);</span><br><span class="line"><span class="comment">//7.监听消息</span></span><br><span class="line">consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">TextMessage textMessage = (TextMessage)message;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"监听到的消息"</span>+textMessage.getText());</span><br><span class="line">&#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//8.持续监听</span></span><br><span class="line">System.in.read();</span><br><span class="line"><span class="comment">//9.释放资源</span></span><br><span class="line">consumer.close();</span><br><span class="line">session.close();</span><br><span class="line">connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2发布-订阅Demo"><a href="#3-2发布-订阅Demo" class="headerlink" title="3.2发布/订阅Demo"></a>3.2发布/订阅Demo</h3><h4 id="3-2-1添加依赖"><a href="#3-2-1添加依赖" class="headerlink" title="3.2.1添加依赖"></a>3.2.1添加依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.13.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-2生产者代码"><a href="#3-2-2生产者代码" class="headerlink" title="3.2.2生产者代码"></a>3.2.2生产者代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//1.创建连接工厂</span></span><br><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://120.76.56.183:61616"</span>);</span><br><span class="line"><span class="comment">//2.获取连接</span></span><br><span class="line">Connection connection = connectionFactory.createConnection();</span><br><span class="line"><span class="comment">//3.开启连接</span></span><br><span class="line">connection.start();</span><br><span class="line"><span class="comment">//4.获取session</span></span><br><span class="line">Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"><span class="comment">//5.创建topic</span></span><br><span class="line">Topic topic = session.createTopic(<span class="string">"test-topic"</span>);</span><br><span class="line"><span class="comment">//6.创建消息生产者</span></span><br><span class="line">MessageProducer producer = session.createProducer(topic);</span><br><span class="line"><span class="comment">//7.创建消息 由session去创建消息</span></span><br><span class="line">TextMessage message = session.createTextMessage(<span class="string">"啊啊啊啊，你可以简单点么"</span>);</span><br><span class="line"><span class="comment">//8.发送消息</span></span><br><span class="line">producer.send(message);</span><br><span class="line"><span class="comment">//9.释放资源</span></span><br><span class="line">producer.close();</span><br><span class="line">session.close();</span><br><span class="line">connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-3消费者代码"><a href="#3-2-3消费者代码" class="headerlink" title="3.2.3消费者代码"></a>3.2.3消费者代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//1.创建工厂</span></span><br><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://120.76.56.183:61616"</span>);</span><br><span class="line"><span class="comment">//2.创建连接</span></span><br><span class="line">Connection connection = connectionFactory.createConnection();</span><br><span class="line"><span class="comment">//3.启动连接</span></span><br><span class="line">connection.start();</span><br><span class="line"><span class="comment">//4.获取session</span></span><br><span class="line">Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"><span class="comment">//5.获取Topic</span></span><br><span class="line">Topic topic = session.createTopic(<span class="string">"test-topic"</span>);</span><br><span class="line"><span class="comment">//6.获取topic消费者</span></span><br><span class="line">MessageConsumer consumer = session.createConsumer(topic);</span><br><span class="line"><span class="comment">//7.设置监听</span></span><br><span class="line">consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">TextMessage textMessage = (TextMessage) message;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"topic监听到了"</span>+textMessage.getText());</span><br><span class="line">&#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//8.持久监听</span></span><br><span class="line">System.in.read();</span><br><span class="line"><span class="comment">//9.关闭资源</span></span><br><span class="line">consumer.close();</span><br><span class="line">session.close();</span><br><span class="line">connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Spring整合ActiveMQ"><a href="#4-Spring整合ActiveMQ" class="headerlink" title="4.Spring整合ActiveMQ"></a>4.Spring整合ActiveMQ</h2><h3 id="4-1点对点Demo"><a href="#4-1点对点Demo" class="headerlink" title="4.1点对点Demo"></a>4.1点对点Demo</h3><h4 id="4-1-1生产者代码"><a href="#4-1-1生产者代码" class="headerlink" title="4.1.1生产者代码"></a>4.1.1生产者代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JMS模板 负责发送消息 接受消息</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JmsTemplate jmsTemplate ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//消息的目的地</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Destination queueTextDestination;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成者发生信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTextMessage</span><span class="params">(<span class="keyword">final</span> String text)</span> </span>&#123;</span><br><span class="line">jmsTemplate.send(queueTextDestination, <span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> session.createTextMessage(text);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2配置文件"><a href="#4-1-2配置文件" class="headerlink" title="4.1.2配置文件"></a>4.1.2配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:amq</span>=<span class="string">"http://activemq.apache.org/schema/core"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:jms</span>=<span class="string">"http://www.springframework.org/schema/jms"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans   </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context   </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.yuanxiong.producer"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span>     </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.ActiveMQConnectionFactory"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brokerURL"</span> <span class="attr">value</span>=<span class="string">"tcp://120.76.56.183:61616"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.connection.SingleConnectionFactory"</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">ref</span>=<span class="string">"targetConnectionFactory"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>      </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--这个是队列目的地，点对点的  文本信息--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"queueTextDestination"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 消息队列的值 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"queue_text"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--这个是订阅模式  文本信息 </span></span><br><span class="line"><span class="comment">&lt;bean id="topicTextDestination" class="org.apache.activemq.command.ActiveMQTopic"&gt;  </span></span><br><span class="line"><span class="comment">    &lt;constructor-arg value="topic_text"/&gt;  </span></span><br><span class="line"><span class="comment">&lt;/bean&gt;  </span></span><br><span class="line"><span class="comment">--&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-1-3消费者代码"><a href="#4-1-3消费者代码" class="headerlink" title="4.1.3消费者代码"></a>4.1.3消费者代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuanxiong.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.MessageListener;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">TextMessage textMessage = (TextMessage) message;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"queue监听到了"</span>+textMessage.getText());</span><br><span class="line">&#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-4配置文件"><a href="#4-1-4配置文件" class="headerlink" title="4.1.4配置文件"></a>4.1.4配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:amq</span>=<span class="string">"http://activemq.apache.org/schema/core"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:jms</span>=<span class="string">"http://www.springframework.org/schema/jms"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans   </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context   </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.ActiveMQConnectionFactory"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brokerURL"</span> <span class="attr">value</span>=<span class="string">"tcp://120.76.56.183:61616"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.connection.SingleConnectionFactory"</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">ref</span>=<span class="string">"targetConnectionFactory"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--这个是队列目的地，点对点的  文本信息--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"queueTextDestination"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"queue_text"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 我的监听类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.yuanxiong.consumer"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 消息监听容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destination"</span> <span class="attr">ref</span>=<span class="string">"queueTextDestination"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 我的监听类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageListener"</span> <span class="attr">ref</span>=<span class="string">"myMessageListener"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-2发布订阅Demo"><a href="#4-2发布订阅Demo" class="headerlink" title="4.2发布订阅Demo"></a>4.2发布订阅Demo</h3><h4 id="4-2-1生产者代码"><a href="#4-2-1生产者代码" class="headerlink" title="4.2.1生产者代码"></a>4.2.1生产者代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuanxiong.producer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.Destination;</span><br><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Session;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.MessageCreator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Destination topicTextDestination;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTextMessage</span><span class="params">(<span class="keyword">final</span> String string)</span> </span>&#123;</span><br><span class="line">jmsTemplate.send(topicTextDestination, <span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> session.createTextMessage(string);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2配置文件"><a href="#4-2-2配置文件" class="headerlink" title="4.2.2配置文件"></a>4.2.2配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:amq</span>=<span class="string">"http://activemq.apache.org/schema/core"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:jms</span>=<span class="string">"http://www.springframework.org/schema/jms"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans   </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context   </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.yuanxiong.producer"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span>     </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.ActiveMQConnectionFactory"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brokerURL"</span> <span class="attr">value</span>=<span class="string">"tcp://120.76.56.183:61616"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.connection.SingleConnectionFactory"</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">ref</span>=<span class="string">"targetConnectionFactory"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>        </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--这个是订阅模式  文本信息 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"topicTextDestination"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQTopic"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"topic_text"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3消费者代码"><a href="#4-2-3消费者代码" class="headerlink" title="4.2.3消费者代码"></a>4.2.3消费者代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuanxiong.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.MessageListener;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myTopicMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">TextMessage textMessage = (TextMessage)message;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"topic"</span>+textMessage.getText());</span><br><span class="line">&#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.2.4配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:amq</span>=<span class="string">"http://activemq.apache.org/schema/core"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:jms</span>=<span class="string">"http://www.springframework.org/schema/jms"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans   </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context   </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.ActiveMQConnectionFactory"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brokerURL"</span> <span class="attr">value</span>=<span class="string">"tcp://120.76.56.183:61616"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.connection.SingleConnectionFactory"</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">ref</span>=<span class="string">"targetConnectionFactory"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--这个是topic目的地，点对点的  文本信息--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"topicTextDestination"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQTopic"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"topic_text"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 消息监听容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destination"</span> <span class="attr">ref</span>=<span class="string">"topicTextDestination"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageListener"</span> <span class="attr">ref</span>=<span class="string">"myTopicMessageListener"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;消息中间件&quot;&gt;&lt;a href=&quot;#消息中间件&quot; class=&quot;headerlink&quot; title=&quot;消息中间件&quot;&gt;&lt;/a&gt;消息中间件&lt;/h1&gt;&lt;p&gt;当没有采用消息中间件的系统模块图,当运营商后台去调用搜索服务和页面生成服务的时候，不需要知道他们返回的结果，所以在这
      
    
    </summary>
    
      <category term="MQ" scheme="https://aaccompany.github.io/categories/MQ/"/>
    
    
      <category term="消息中间件" scheme="https://aaccompany.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>MQ知其然而不知其所然</title>
    <link href="https://aaccompany.github.io/2019/07/02/MQ%E7%9F%A5%E5%85%B6%E7%84%B6%E8%80%8C%E4%B8%8D%E7%9F%A5%E5%85%B6%E6%89%80%E7%84%B6/"/>
    <id>https://aaccompany.github.io/2019/07/02/MQ知其然而不知其所然/</id>
    <published>2019-07-02T02:13:52.000Z</published>
    <updated>2019-07-10T05:10:42.935Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MQ知其然而不知其所然"><a href="#MQ知其然而不知其所然" class="headerlink" title="MQ知其然而不知其所然"></a>MQ知其然而不知其所然</h1><h2 id="1-什么是MQ？"><a href="#1-什么是MQ？" class="headerlink" title="1.什么是MQ？"></a>1.什么是MQ？</h2><p>MQ：通俗的理解为消息队列。在分布式系统中，一个系统可以将一份数据存放在一个中间件上，然后其他系统需要这份数据的话，就可以从中间件上将这份数据取出。</p><p><strong>那么问题来了，为什么需要使用MQ？</strong></p><p>可以使用MQ做到系统的解耦、异步、削峰。</p><h2 id="2-MQ的优点"><a href="#2-MQ的优点" class="headerlink" title="2.MQ的优点"></a>2.MQ的优点</h2><h3 id="2-1-解耦"><a href="#2-1-解耦" class="headerlink" title="2.1.解耦"></a>2.1.解耦</h3><p><strong>业务：</strong>A系统需要发送数据到BCD系统中，在BCD系统中进行操作</p><h4 id="2-1-1-在不使用MQ下的系统耦合"><a href="#2-1-1-在不使用MQ下的系统耦合" class="headerlink" title="2.1.1.在不使用MQ下的系统耦合"></a>2.1.1.在不使用MQ下的系统耦合</h4><p><img src="/2019/07/02/MQ知其然而不知其所然/22.png" alt></p><p>坏处：</p><p>1.从图中可以知道，当A系统需要完成一个操作，需要BCD协同完成。当整个工程新增系统或者有系统不需要A传递的数据的话，那么就需要修改两方的数据。</p><p>2.因为A系统需要完成一个操作，需要依赖于BCD系统，那么如果其中一个出现了问题，那么整个系统就会出现异常。</p><p>3.如果A系统所依赖的系统访问超时该如何处理。</p><p>所以在这种模式容易出现许多问题，如何解决这些问题呢？</p><h4 id="2-1-2-系统使用MQ解耦"><a href="#2-1-2-系统使用MQ解耦" class="headerlink" title="2.1.2.系统使用MQ解耦"></a>2.1.2.系统使用MQ解耦</h4><p><img src="/2019/07/02/MQ知其然而不知其所然/23.png" alt></p><p>在使用了MQ情况下，A系统可以将需要传递数据发送到MQ中，这时候，A所依赖的系统（BCD）就可以从MQ中获取数据完成操作。这样的话就不需要考虑上面所提及的坏处。</p><h3 id="2-2-异步"><a href="#2-2-异步" class="headerlink" title="2.2.异步"></a>2.2.异步</h3><h4 id="2-2-1-在不使用MQ下系统是保持同步状态"><a href="#2-2-1-在不使用MQ下系统是保持同步状态" class="headerlink" title="2.2.1.在不使用MQ下系统是保持同步状态"></a>2.2.1.在不使用MQ下系统是保持同步状态</h4><p>如果系统采用是的同步设计，那么会给系统造成高延迟的现象</p><p><img src="/2019/07/02/MQ知其然而不知其所然/24.png" alt></p><p>由图中可以得到如果需要完成一个功能总共耗时为200 ms</p><h4 id="2-2-2-在使用MQ下系统可以修改为异步状态"><a href="#2-2-2-在使用MQ下系统可以修改为异步状态" class="headerlink" title="2.2.2.在使用MQ下系统可以修改为异步状态"></a>2.2.2.在使用MQ下系统可以修改为异步状态</h4><p>如果将系统修改为异步状态，那么系统就可以大大减少系统延迟现象。</p><p><img src="/2019/07/02/MQ知其然而不知其所然/25.png" alt></p><p>在使用了MQ的情况下，完成一个功能返回给用户的时间差只存在 50 ms + 5 ms = 55 ms。这样从同步系统到异步系统的时间比值为 40：11 接近省去了4倍的时间（在假设的情况下）。</p><blockquote><p>在互联网企业上一个请求的响应时间应该在200 ms之内，这样用户就很难感知。</p></blockquote><h3 id="2-3-削峰"><a href="#2-3-削峰" class="headerlink" title="2.3.削峰"></a>2.3.削峰</h3><h4 id="2-3-1-没有削峰的系统"><a href="#2-3-1-没有削峰的系统" class="headerlink" title="2.3.1.没有削峰的系统"></a>2.3.1.没有削峰的系统</h4><p><img src="/2019/07/02/MQ知其然而不知其所然/26.png" alt></p><h4 id="2-3-2-使用了MQ对系统进行削峰"><a href="#2-3-2-使用了MQ对系统进行削峰" class="headerlink" title="2.3.2.使用了MQ对系统进行削峰"></a>2.3.2.使用了MQ对系统进行削峰</h4><p><img src="/2019/07/02/MQ知其然而不知其所然/27.png" alt></p><h2 id="3-引入MQ出现的问题？"><a href="#3-引入MQ出现的问题？" class="headerlink" title="3.引入MQ出现的问题？"></a>3.引入MQ出现的问题？</h2><p><img src="/2019/07/02/MQ知其然而不知其所然/29.png" alt></p><p>虽然系统中引入了MQ组件，做到了系统的异步、削峰、解耦，但是因为系统中加入了MQ导致了系统出现了下面几种问题。</p><h3 id="3-1-系统的可用性降低"><a href="#3-1-系统的可用性降低" class="headerlink" title="3.1.系统的可用性降低"></a>3.1.系统的可用性降低</h3><p>引入了MQ，系统的消息转递需要依赖于MQ，但是当MQ宕机的话那么整个系统也会随之宕机。</p><h3 id="3-2-系统的复杂度提高"><a href="#3-2-系统的复杂度提高" class="headerlink" title="3.2.系统的复杂度提高"></a>3.2.系统的复杂度提高</h3><p>引入了MQ会导致系统的架构变得复杂。同时也需要考虑会出现的问题。</p><p>1）是否会往MQ中重复发送消息？</p><p>2）发送给MQ的消息是否会丢失？</p><p>3）发送给MQ的消息如果具有顺序，如何保证消息的顺序？</p><h3 id="3-3-系统一致性问题"><a href="#3-3-系统一致性问题" class="headerlink" title="3.3.系统一致性问题"></a>3.3.系统一致性问题</h3><p>当系统A发送消息给BCD的话，ABC都执行完并且无异常，但是D出现异常。那么A会告知用户执行完毕，这种情况该如何解决。</p><h2 id="如果做MQ的选型？"><a href="#如果做MQ的选型？" class="headerlink" title="如果做MQ的选型？"></a>如果做MQ的选型？</h2><p>1.社区活跃度</p><p>2.单机吞吐量</p><p>3.时效性</p><p>一般在中小型公司采用RabbitMQ（消息处理能力万级，但是语言采用的是erlang专门处理分布式的语言设计所有处理速度快），中大型公司有专门技术人员可以采用RockerMQ（消息处理能力十万级）。大数据采用kafka（消息处理能力十万级）。</p><p>一般现在不采用ActiveMQ（消息处理能力万级）作为MQ，因为社区活跃度开始下降。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MQ知其然而不知其所然&quot;&gt;&lt;a href=&quot;#MQ知其然而不知其所然&quot; class=&quot;headerlink&quot; title=&quot;MQ知其然而不知其所然&quot;&gt;&lt;/a&gt;MQ知其然而不知其所然&lt;/h1&gt;&lt;h2 id=&quot;1-什么是MQ？&quot;&gt;&lt;a href=&quot;#1-什么是MQ？&quot;
      
    
    </summary>
    
      <category term="MQ" scheme="https://aaccompany.github.io/categories/MQ/"/>
    
    
      <category term="消息中间件" scheme="https://aaccompany.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ消息中间件</title>
    <link href="https://aaccompany.github.io/2019/07/02/RabbitMQ%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://aaccompany.github.io/2019/07/02/RabbitMQ消息中间件/</id>
    <published>2019-07-02T02:13:52.000Z</published>
    <updated>2019-07-10T05:13:46.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ消息中间件"><a href="#RabbitMQ消息中间件" class="headerlink" title="RabbitMQ消息中间件"></a>RabbitMQ消息中间件</h1><h2 id="1-RabbitMQ简介"><a href="#1-RabbitMQ简介" class="headerlink" title="1.RabbitMQ简介"></a>1.RabbitMQ简介</h2><h3 id="1-1-消息队列简介"><a href="#1-1-消息队列简介" class="headerlink" title="1.1.消息队列简介"></a>1.1.消息队列简介</h3><p>消息中间件是分布式系统中的重要组件，主要解决了应用耦合，异步消息，流量削锋等问题，实现系统高性能，高可用，可伸缩性喝最终一致性【架构】使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka,MetaMQ,RocketMQ</p><h3 id="1-2-什么是RabbitMQ"><a href="#1-2-什么是RabbitMQ" class="headerlink" title="1.2.什么是RabbitMQ"></a>1.2.什么是RabbitMQ</h3><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。<br>AMQP ：Advanced Message Queue Protocol，高级消息队列协议。它是应用层协议的一个开放 标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，<strong>并不受产品、开发语言等条件的限制。</strong><br>RabbitMQ 初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：</p><p>1.可靠性（Reliability）<br>RabbitMQ 使用一些机制来保证可靠性，如持久化（当服务器挂掉的时候会不会丢失信息，而是会保存信息到硬盘）、传输确认、发布确认。</p><p>2.灵活的路由（Flexible Routing）<br>在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。</p><p>3.消息集群（Clustering）<br>多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</p><p> 4.高可用（Highly Available Queues）<br>队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</p><p>5.多种协议（Multi-protocol）<br>RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。</p><p>6.多语言客户端（Many Clients） RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。</p><p>7.管理界面（Management UI）<br>RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方 面。</p><p>8.跟踪机制（Tracing）<br>如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。</p><p> 9.插件机制（Plugin System）<br>RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。 </p><h3 id="1-3-架构图与主要概念"><a href="#1-3-架构图与主要概念" class="headerlink" title="1.3.架构图与主要概念"></a>1.3.架构图与主要概念</h3><h4 id="1-3-1-架构图"><a href="#1-3-1-架构图" class="headerlink" title="1.3.1.架构图"></a>1.3.1.架构图</h4><p><img src="/2019/07/02/RabbitMQ消息中间件/11.png" alt></p><h4 id="1-2-2-主要概念"><a href="#1-2-2-主要概念" class="headerlink" title="1.2.2.主要概念"></a>1.2.2.主要概念</h4><p>RabbitMQ Server： 也叫broker server，它是一种传输服务。 他的角色就是维护一条 从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。</p><p>Producer： 消息生产者，如图A、B、C，数据的发送方。消息生产者连接RabbitMQ服 务器然后将消息投递到Exchange。</p><p>Consumer：消息消费者，如图1、2、3，数据的接收方。消息消费者订阅队列， RabbitMQ将Queue中的消息发送到消息消费者。 Exchange：生产者将消息发送到Exchange（交换器），由Exchange将消息路由到一个 或多个Queue中（或者丢弃）。</p><p>Exchange并不存储消息。RabbitMQ中的Exchange有 direct、fanout、topic、headers四种类型，每种类型对应不同的路由规则。</p><p>Queue：（队列）是RabbitMQ的内部对象，用于存储消息。消息消费者就是通过订阅队列来获取消息的，RabbitMQ中的消息都只能存储在Queue中，生产者生产消息并终投递到Queue中，消费者可以从Queue中获取消息并消费。多个消费者可以订阅同一个 Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者 都收到所有的消息并处理。</p><p>RoutingKey：生产者在将消息发送给Exchange的时候，一般会指定一个routing key， 来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联 合使用才能终生效。在Exchange Type与binding key固定的情况下（在正常使用时一 般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过 指定routing key来决定消息流向哪里。RabbitMQ为routing key设定的长度限制为255 bytes。</p><p>Connection： （连接）：Producer和Consumer都是通过TCP连接到RabbitMQ Server 的。以后我们可以看到，程序的起始处就是建立这个TCP连接。</p><p>Channels： （信道）：它建立在上述的TCP连接中。数据流动都是在Channel中进行 的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。</p><p>VirtualHost：权限控制的基本单位，一个VirtualHost里面有若干Exchange和 MessageQueue，以及指定被哪些user使用 </p><h2 id="2-走进RabbitMQ"><a href="#2-走进RabbitMQ" class="headerlink" title="2.走进RabbitMQ"></a>2.走进RabbitMQ</h2><h3 id="2-1-RabbitMQ安装"><a href="#2-1-RabbitMQ安装" class="headerlink" title="2.1.RabbitMQ安装"></a>2.1.RabbitMQ安装</h3><p>（1）下载并安装 Eralng<br>配套软件中已提供otp_win64_20.2.exe   （以管理员身份运行安装） （2）下载并安装rabbitmq<br>配套软件中已提供rabbitmq-server-3.7.4.exe。双击安装，注意不要安装在包含中文和 空格的目录下！安装后window服务中就存在rabbitMQ了，并且是启动状态。</p><p>（3）安装管理界面（插件）<br>进入rabbitMQ安装目录的sbin目录，输入命令<br>rabbitmq‐plugins enable rabbitmq_management</p><p>（4）重新启动服务</p><p>（5）打开浏览器，地址栏输入<a href="http://127.0.0.1:15672" target="_blank" rel="noopener">http://127.0.0.1:15672</a>  ,即可看到管理界面的登陆页</p><p>输入用户名和密码，都为guest  进入主界面：</p><p>上侧的导航以此是：概览、连接、信道、交换器、队列、用户管理</p><h3 id="2-2-Docker环境下安装"><a href="#2-2-Docker环境下安装" class="headerlink" title="2.2.Docker环境下安装"></a>2.2.Docker环境下安装</h3><p><strong>1.下载镜像</strong></p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure><p><strong>2.创建RabbitMQ容器</strong></p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span> -di --name=tensqura_rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 15671:15671 -p 15672:15672 -p 25672:25672 rabbitmq:management</span><br></pre></td></tr></table></figure><p>15672 (if management plugin is enabled)</p><p>15671  management监听端口</p><p>5672, 5671 (AMQP 0-9-1 without and with TLS)</p><p> 4369 (epmd)   epmd  代表 Erlang 端口映射守护进程 </p><p>25672 (Erlang distribution)</p><p><strong>3.登入RabbitMQ管理界面</strong></p><p>访问地址：<a href="http://192.168.186.129:15672/" target="_blank" rel="noopener">http://192.168.186.129:15672</a></p><p>账号密码均为guest</p><h3 id="2-3-直接模式-Direct"><a href="#2-3-直接模式-Direct" class="headerlink" title="2.3.直接模式(Direct)"></a>2.3.直接模式(Direct)</h3><h4 id="2-3-1-什么是直接模式"><a href="#2-3-1-什么是直接模式" class="headerlink" title="2.3.1.什么是直接模式"></a>2.3.1.什么是直接模式</h4><p>将消息发给唯一一个节点时使用这种模式，这是简单的一种形式。</p><p><img src="/2019/07/02/RabbitMQ消息中间件/12.png" alt></p><p>任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue。<br>1.一般情况可以使用rabbitMQ自带的Exchange：””(该Exchange的名字为空字符串，下文称其为default Exchange)。</p><p>2.这种模式下不需要将Exchange进行任何绑定(binding)操作 3.消息传递时需要一个“RouteKey”，可以简单的理解为要发送到的队列名字。</p><p>4.如果vhost中不存在RouteKey中指定的队列名，则该消息会被<strong>抛弃</strong>。 </p><h4 id="2-3-2创建队列"><a href="#2-3-2创建队列" class="headerlink" title="2.3.2创建队列"></a>2.3.2创建队列</h4><p>Name:队列的名称</p><p>Durability:是否持久化</p><p>Auto Delete:是否自动删除</p><p><img src="/2019/07/02/RabbitMQ消息中间件/13.png" alt></p><h4 id="2-3-3-代码实现-消息生产者"><a href="#2-3-3-代码实现-消息生产者" class="headerlink" title="2.3.3.代码实现- 消息生产者"></a>2.3.3.代码实现- 消息生产者</h4><p><strong>1.引入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐boot‐starter‐parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>          </span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- rabbitMQ起步依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐boot‐starter‐amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐boot‐starter‐test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>              </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.配置文件信息</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>   </span><br><span class="line"><span class="attr">rabbitmq:</span>     </span><br><span class="line"><span class="attr">host:</span> <span class="number">192.168</span><span class="number">.192</span><span class="number">.129</span></span><br></pre></td></tr></table></figure><p><strong>3.编写启动类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span></span><br><span class="line"><span class="class"></span>&#123;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;         </span><br><span class="line">        SpringApplication.run(Application.class);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.编写测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class) </span><br><span class="line"><span class="meta">@SpringBootTest</span>(classes=Application.class) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSend</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"队列名称"</span>,<span class="string">"我要红包"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-4-代码实现-消息消费者"><a href="#2-3-4-代码实现-消息消费者" class="headerlink" title="2.3.4.代码实现-消息消费者"></a>2.3.4.代码实现-消息消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="meta">@RabbitListener</span>(queues=<span class="string">"itcast"</span> ) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span>     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">(String message)</span></span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"itcast接收到消息："</span>+message);     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-分裂模式（Fanout）"><a href="#2-4-分裂模式（Fanout）" class="headerlink" title="2.4.分裂模式（Fanout）"></a>2.4.分裂模式（Fanout）</h3><h4 id="2-4-1-什么是分裂模式（Fanout）"><a href="#2-4-1-什么是分裂模式（Fanout）" class="headerlink" title="2.4.1.什么是分裂模式（Fanout）"></a>2.4.1.什么是分裂模式（Fanout）</h4><p>消息传递个多个队列的时候就可以采用这种模式</p><p><img src="/2019/07/02/RabbitMQ消息中间件/14.png" alt></p><p>任何发送到Exchange的消息都会转发到绑定到该Exchange的队列中。</p><p>1.可以理解为路由表的模式</p><p>2.这种模式不需要RouteKey</p><p> 3.这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个 Queue，一个Queue可以同多个Exchange进行绑定。（多对多的关系）</p><p>4.如果接受到消息的Exchange没有与任何Queue绑定，则消息会被<strong>抛弃</strong>。 </p><h4 id="2-4-2-交换器绑定队列"><a href="#2-4-2-交换器绑定队列" class="headerlink" title="2.4.2.交换器绑定队列"></a>2.4.2.交换器绑定队列</h4><p><strong>1.创建交换器，类型选择为fanout</strong></p><p><img src="/2019/07/02/RabbitMQ消息中间件/15.png" alt></p><p><strong>2.创建队列</strong></p><p><img src="/2019/07/02/RabbitMQ消息中间件/16.png" alt></p><p><strong>3.交换器绑定队列</strong></p><p>选择对应的交换器，点击进去</p><p><img src="/2019/07/02/RabbitMQ消息中间件/17.png" alt></p><p>填写需要绑定的队列名称</p><p><img src="/2019/07/02/RabbitMQ消息中间件/18.png" alt></p><h4 id="2-4-3-代码实现-消息生产者"><a href="#2-4-3-代码实现-消息生产者" class="headerlink" title="2.4.3.代码实现-消息生产者"></a>2.4.3.代码实现-消息生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendFanout</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"chuanzhi"</span>,<span class="string">""</span>, <span class="string">"分列模式走起"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-4-代码实现-消息消费者"><a href="#2-4-4-代码实现-消息消费者" class="headerlink" title="2.4.4.代码实现-消息消费者"></a>2.4.4.代码实现-消息消费者</h4><p>创建一个类去监听对应的队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="meta">@RabbitListener</span>(queues=<span class="string">"需要监听的队列名称"</span> )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"itheima接收到消息："</span>+message);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-主题模式（Topic）"><a href="#2-5-主题模式（Topic）" class="headerlink" title="2.5.主题模式（Topic）"></a>2.5.主题模式（Topic）</h3><h4 id="2-5-1-什么是主题模式"><a href="#2-5-1-什么是主题模式" class="headerlink" title="2.5.1.什么是主题模式"></a>2.5.1.什么是主题模式</h4><p>任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue 上。可以说是分裂模式一种加强。</p><p><img src="/2019/07/02/RabbitMQ消息中间件/19.png" alt></p><p>在这个模式中出现了匹配规则</p><p>routing key：就是一个匹配队列的规则，可以给每个Exchange绑定的队列设置routing key ,当一个消息经过Exchange的时候，如果使用的是主题模式，会匹配routing key，然后分发到对象的队列中。</p><p>规则：</p><p><strong>.*</strong> 表示匹配一个点后面任意字符  </p><p><strong>.#</strong> 表示匹配一个点后面任意字符（但是这种允许后面有多个 .  例如 abc.ac.exc  能匹配 abc.#   但是不能匹配 abc.*）</p><p>这种模式与前面两种模式差不多，当经过Exchange和routing key的时候，没有可以转发的队列，那么就会丢弃这条消息。</p><h4 id="2-5-2-创建队列与绑定"><a href="#2-5-2-创建队列与绑定" class="headerlink" title="2.5.2.创建队列与绑定"></a>2.5.2.创建队列与绑定</h4><p><strong>1.创建队列，类型选择为topic</strong></p><p><img src="/2019/07/02/RabbitMQ消息中间件/20.png" alt></p><p><strong>2.创建队列</strong></p><p><img src="/2019/07/02/RabbitMQ消息中间件/16.png" alt></p><p><strong>3.绑定队列，并且设置routing key</strong></p><p><img src="/2019/07/02/RabbitMQ消息中间件/21.png" alt></p><h4 id="2-5-3-代码实现-消息生产者"><a href="#2-5-3-代码实现-消息生产者" class="headerlink" title="2.5.3.代码实现-消息生产者"></a>2.5.3.代码实现-消息生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>     </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendTopic1</span><span class="params">()</span></span>&#123;         rabbitTemplate.convertAndSend(<span class="string">"topictest"</span>,<span class="string">"goods.aaa"</span>,<span class="string">"主题模式"</span>);     &#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-4-代码实现-消息消费者"><a href="#2-5-4-代码实现-消息消费者" class="headerlink" title="2.5.4.代码实现-消息消费者"></a>2.5.4.代码实现-消息消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="meta">@RabbitListener</span>(queues=<span class="string">"需要监听的队列名称"</span> )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"itheima接收到消息："</span>+message);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RabbitMQ消息中间件&quot;&gt;&lt;a href=&quot;#RabbitMQ消息中间件&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ消息中间件&quot;&gt;&lt;/a&gt;RabbitMQ消息中间件&lt;/h1&gt;&lt;h2 id=&quot;1-RabbitMQ简介&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="MQ" scheme="https://aaccompany.github.io/categories/MQ/"/>
    
    
      <category term="消息中间件" scheme="https://aaccompany.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
</feed>
