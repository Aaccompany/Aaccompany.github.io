{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"https://aaccompany.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-07-08T05:37:11.090Z","updated":"2019-07-08T05:37:11.090Z","comments":false,"path":"/404.html","permalink":"https://aaccompany.github.io//404.html","excerpt":"","text":""},{"title":"分类","date":"2019-07-08T05:37:11.095Z","updated":"2019-07-08T05:37:11.095Z","comments":false,"path":"categories/index.html","permalink":"https://aaccompany.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-07-08T15:06:27.997Z","updated":"2019-07-08T15:06:27.997Z","comments":false,"path":"about/index.html","permalink":"https://aaccompany.github.io/about/index.html","excerpt":"","text":"1234567891011121314151617 ┏┓ ┏┓ ┏┛┻━━━┛┻┓ ┃ ┃ ┃ ━ ┃ ┃ ┳┛ ┗┳ ┃ ┃ ┃ ┃ ┻ ┃ ┃ ┃ ┗━┓ ┏━┛ ┃ ┃ ┃ ┃ ┃ ┗━━━┓ ┃ ┣┓ ┃ ┏┛ ┗┓┓┏━┳┓┏┛ ┃┫┫ ┃┫┫ ┗┻┛ ┗┻┛ 固步自封，停滞不前"},{"title":"Repositories","date":"2019-07-08T14:07:26.564Z","updated":"2019-07-08T14:07:26.564Z","comments":false,"path":"repository/index.html","permalink":"https://aaccompany.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-08T05:37:11.099Z","updated":"2019-07-08T05:37:11.099Z","comments":false,"path":"tags/index.html","permalink":"https://aaccompany.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"重走框架系列说明","slug":"重走框架系列说明","date":"2019-07-14T11:47:47.000Z","updated":"2019-07-14T12:02:48.813Z","comments":true,"path":"2019/07/14/重走框架系列说明/","link":"","permalink":"https://aaccompany.github.io/2019/07/14/重走框架系列说明/","excerpt":"","text":"重走框架系列说明自我反思由于思想觉悟出现了问题，总想着快点学习，却没有想到丢了芝麻也丢了西瓜。 自己的基础严重的不牢固，导致前进的十分缓慢。又看了许多大神的教学视频，感觉自己依旧十分的弟弟，所以觉得自己有点揠苗助长，故有了重走框架系列，希望自己能够在这次重新学习后端框架的时候能够不断发现自己的知识盲区，找到自己的不足。 在重走框架的道路上，希望能够借助自己做的项目中，仔细思考在项目中引入新的后端框架会对系统增加严重的BUG，以及对这些BUG如何去做到预防以及解决。 借用《劝学》 故不积跬步，无以至千里，不积小流，无以成江海。 望自己能够一直记住。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://aaccompany.github.io/categories/杂谈/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://aaccompany.github.io/tags/杂谈/"}]},{"title":"重走spring框架","slug":"重走spring框架","date":"2019-07-14T11:40:50.000Z","updated":"2019-07-14T14:51:42.651Z","comments":true,"path":"2019/07/14/重走spring框架/","link":"","permalink":"https://aaccompany.github.io/2019/07/14/重走spring框架/","excerpt":"","text":"Spring框架1.Spring到底是个什么妖魔鬼怪？1.1.Spring的自我介绍？1）Spring是分层的 Java SE/EE应用 full-stack （提供了全栈式的解决方案）轻量级开源框架 2）以 IoC（Inverse Of Control： 反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核 3）提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多 著名的第三方框架和类库 4）Java后端开发的标准 1.2.Spring的发展历程1997 年 IBM提出了EJB 的思想 1998 年，SUN制定开发标准规范 EJB1.0 1999 年，EJB1.1 发布 2001 年，EJB2.0 发布 2003 年，EJB2.1 发布 2006 年，EJB3.0 发布 Rod Johnson（spring之父） Expert One-to-One J2EE Design and Development(2002) 阐述了 J2EE 使用EJB 开发设计的优点及解决方案 Expert One-to-One J2EE Development without EJB(2004) 阐述了 J2EE 开发不使用 EJB的解决方式（Spring 雏形） 2017 年 9 月份发布了 spring 的最新版本 spring 5.0 通用版（GA） 1.3.为什么要使用Spring？1）方便解耦，简化开发 通过Spring提供的IOC（控制反转）容器，让Bean对象放入到Spring容器中，这样对象之间的依赖关系就可以由Spring去处理，避免硬编码造成程序耦合。也不需要注重Bean是设计成单例还是设计成多例的代码。可以花更多时间去注重上层代码 2）AOP支持(面向切面) 通过Spring提供的AOP支持，可以做到传统的OOP很难完成事情。 3）声明式事务的支持 可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理， 提高开发效率和质量。 4）方便程序的测试 可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可 做的事情 5）方便集合各种优秀的框架 可以很快的整合Mybatis、Spring MVC 、Struts等框架。 6）降低了Java EE的API使用难度 在Spring中，对Java EE（如 JDBC、JavaMail、远程调用等）进行了一层封装，能够通过更少的代码去使用这些技术。 7）代码编写的榜样 Spring采用的代码编写的技巧，设计都十分巧妙，结构清晰，注释完整。是十分值得学习的榜样。 1.4.Spring的体系结构在Spring的体系结构中也可以看出Spring是个full-stack型框架，提供了各层的解决方案。 其中重要的是Core Container中的部分，这是使用Spring必备部分，不可缺失。 2.IOC是个什么玩意？2.1.程序的耦合和解耦在说明IOC先知道什么是程序的耦合和耦合 2.1.1.程序的耦合？在软件工程中，耦合指的就是就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。划分模块的一个 准则就是高内聚低耦合。 它有如下分类： 模块耦合分为数据耦合、特征耦合、控制耦合、公共环境耦合、内容耦合。耦合程度由低到高。 1）数据耦合： 两个模块彼此间通过参数交换信息，而且交换的信息仅仅是数据（指的是单一的原子的数据片段），那么这种耦合称为数据耦合。数据耦合是低耦合。系统中至少必须存在这种耦合。这是不可避免的。 2）特征耦合 当把整个数据结构作为参数、局部变量或者返回值，而被调用的模块只需要使用其中一部分数据元素时，就出现了特征耦合。（意思为传递了一个数据结构，但是调用方没有将该数据结构中全部数据使用便为特征耦合） 比如判断一个人是否成年，只需要传递该人的出生日期即可，不必要把人传进去。 因此这种耦合，通常是可以通过修改参数、局部变量或者返回值，只使用必要的数据元素来避免。 3）控制耦合 传递的信息中有控制信息(尽管有时这种控制信息以数据的形式出现)，则这种耦合称为控制耦合。控制耦合是中等程度的耦合。 比如，传递的参数中包含一个枚举类型的参数，在方法的具体逻辑中判断该参数实现不同的功能。那么，完全可以通过将一个方法修改为多个方法改进这种耦合。 4）公共环境耦合 当两个或多个模块通过一个公共数据环境相互作用时，它们之间的耦合称为公共环境耦合。公共环境可以是全程变量、共享的通信区、内存的公共覆盖区、任何存储介质上的文件、物理设备等。公共环境耦合的复杂程度随耦合的模块个数而变化，当耦合的模块个数增加时复杂程度显著增加。 只有两个模块有公共环境，耦合有下面两种可能。 一个模块往公共环境送数据，另一个模块从公共环境取数据。这是数据耦合的一种形式，是比较松散的耦合。 两个模块都既往公共环境送数据又从里面取数据，这种耦合比较紧密，介于数据耦合和控制耦合之间。 限制范围，比如如果是依赖的是汇率，提供一个统一获汇率配置的方法，限制耦合范围。 5）内容耦合 最高程度的耦合是内容耦合。如果出现下列情况之一，两个模块间就发生了内容耦合。 一个模块访问另一个模块的内部数据。 一个模块不通过正常入口而转到另一个模块的内部。 两个模块有一部分程序代码重叠(只可能出现在汇编程序中)。 一个模块有多个入口(这意味着一个模块有几种功能)。 应该坚决避免使用内容耦合，重构吧。 耦合总结总之，耦合是影响软件复杂程度的一个重要因素。应该采取下述设计原则：尽量使用数据耦合，少用控制耦合和特征耦合，限制公共环境耦合的范围，完全不用内容耦合。","categories":[{"name":"后端框架","slug":"后端框架","permalink":"https://aaccompany.github.io/categories/后端框架/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://aaccompany.github.io/tags/spring/"},{"name":"重走系列","slug":"重走系列","permalink":"https://aaccompany.github.io/tags/重走系列/"}]},{"title":"MQ知其然而不知其所然","slug":"MQ知其然而不知其所然","date":"2019-07-02T02:13:52.000Z","updated":"2019-07-10T05:10:42.935Z","comments":true,"path":"2019/07/02/MQ知其然而不知其所然/","link":"","permalink":"https://aaccompany.github.io/2019/07/02/MQ知其然而不知其所然/","excerpt":"","text":"MQ知其然而不知其所然1.什么是MQ？MQ：通俗的理解为消息队列。在分布式系统中，一个系统可以将一份数据存放在一个中间件上，然后其他系统需要这份数据的话，就可以从中间件上将这份数据取出。 那么问题来了，为什么需要使用MQ？ 可以使用MQ做到系统的解耦、异步、削峰。 2.MQ的优点2.1.解耦业务：A系统需要发送数据到BCD系统中，在BCD系统中进行操作 2.1.1.在不使用MQ下的系统耦合 坏处： 1.从图中可以知道，当A系统需要完成一个操作，需要BCD协同完成。当整个工程新增系统或者有系统不需要A传递的数据的话，那么就需要修改两方的数据。 2.因为A系统需要完成一个操作，需要依赖于BCD系统，那么如果其中一个出现了问题，那么整个系统就会出现异常。 3.如果A系统所依赖的系统访问超时该如何处理。 所以在这种模式容易出现许多问题，如何解决这些问题呢？ 2.1.2.系统使用MQ解耦 在使用了MQ情况下，A系统可以将需要传递数据发送到MQ中，这时候，A所依赖的系统（BCD）就可以从MQ中获取数据完成操作。这样的话就不需要考虑上面所提及的坏处。 2.2.异步2.2.1.在不使用MQ下系统是保持同步状态如果系统采用是的同步设计，那么会给系统造成高延迟的现象 由图中可以得到如果需要完成一个功能总共耗时为200 ms 2.2.2.在使用MQ下系统可以修改为异步状态如果将系统修改为异步状态，那么系统就可以大大减少系统延迟现象。 在使用了MQ的情况下，完成一个功能返回给用户的时间差只存在 50 ms + 5 ms = 55 ms。这样从同步系统到异步系统的时间比值为 40：11 接近省去了4倍的时间（在假设的情况下）。 在互联网企业上一个请求的响应时间应该在200 ms之内，这样用户就很难感知。 2.3.削峰2.3.1.没有削峰的系统 2.3.2.使用了MQ对系统进行削峰 3.引入MQ出现的问题？ 虽然系统中引入了MQ组件，做到了系统的异步、削峰、解耦，但是因为系统中加入了MQ导致了系统出现了下面几种问题。 3.1.系统的可用性降低引入了MQ，系统的消息转递需要依赖于MQ，但是当MQ宕机的话那么整个系统也会随之宕机。 3.2.系统的复杂度提高引入了MQ会导致系统的架构变得复杂。同时也需要考虑会出现的问题。 1）是否会往MQ中重复发送消息？ 2）发送给MQ的消息是否会丢失？ 3）发送给MQ的消息如果具有顺序，如何保证消息的顺序？ 3.3.系统一致性问题当系统A发送消息给BCD的话，ABC都执行完并且无异常，但是D出现异常。那么A会告知用户执行完毕，这种情况该如何解决。 如果做MQ的选型？1.社区活跃度 2.单机吞吐量 3.时效性 一般在中小型公司采用RabbitMQ（消息处理能力万级，但是语言采用的是erlang专门处理分布式的语言设计所有处理速度快），中大型公司有专门技术人员可以采用RockerMQ（消息处理能力十万级）。大数据采用kafka（消息处理能力十万级）。 一般现在不采用ActiveMQ（消息处理能力万级）作为MQ，因为社区活跃度开始下降。","categories":[{"name":"MQ","slug":"MQ","permalink":"https://aaccompany.github.io/categories/MQ/"}],"tags":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://aaccompany.github.io/tags/消息中间件/"}]},{"title":"RabbitMQ消息中间件","slug":"RabbitMQ消息中间件","date":"2019-07-02T02:13:52.000Z","updated":"2019-07-10T05:13:46.284Z","comments":true,"path":"2019/07/02/RabbitMQ消息中间件/","link":"","permalink":"https://aaccompany.github.io/2019/07/02/RabbitMQ消息中间件/","excerpt":"","text":"RabbitMQ消息中间件1.RabbitMQ简介1.1.消息队列简介消息中间件是分布式系统中的重要组件，主要解决了应用耦合，异步消息，流量削锋等问题，实现系统高性能，高可用，可伸缩性喝最终一致性【架构】使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka,MetaMQ,RocketMQ 1.2.什么是RabbitMQRabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。AMQP ：Advanced Message Queue Protocol，高级消息队列协议。它是应用层协议的一个开放 标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。RabbitMQ 初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括： 1.可靠性（Reliability）RabbitMQ 使用一些机制来保证可靠性，如持久化（当服务器挂掉的时候会不会丢失信息，而是会保存信息到硬盘）、传输确认、发布确认。 2.灵活的路由（Flexible Routing）在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。 3.消息集群（Clustering）多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。 4.高可用（Highly Available Queues）队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。 5.多种协议（Multi-protocol）RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。 6.多语言客户端（Many Clients） RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。 7.管理界面（Management UI）RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方 面。 8.跟踪机制（Tracing）如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。 9.插件机制（Plugin System）RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。 1.3.架构图与主要概念1.3.1.架构图 1.2.2.主要概念RabbitMQ Server： 也叫broker server，它是一种传输服务。 他的角色就是维护一条 从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。 Producer： 消息生产者，如图A、B、C，数据的发送方。消息生产者连接RabbitMQ服 务器然后将消息投递到Exchange。 Consumer：消息消费者，如图1、2、3，数据的接收方。消息消费者订阅队列， RabbitMQ将Queue中的消息发送到消息消费者。 Exchange：生产者将消息发送到Exchange（交换器），由Exchange将消息路由到一个 或多个Queue中（或者丢弃）。 Exchange并不存储消息。RabbitMQ中的Exchange有 direct、fanout、topic、headers四种类型，每种类型对应不同的路由规则。 Queue：（队列）是RabbitMQ的内部对象，用于存储消息。消息消费者就是通过订阅队列来获取消息的，RabbitMQ中的消息都只能存储在Queue中，生产者生产消息并终投递到Queue中，消费者可以从Queue中获取消息并消费。多个消费者可以订阅同一个 Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者 都收到所有的消息并处理。 RoutingKey：生产者在将消息发送给Exchange的时候，一般会指定一个routing key， 来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联 合使用才能终生效。在Exchange Type与binding key固定的情况下（在正常使用时一 般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过 指定routing key来决定消息流向哪里。RabbitMQ为routing key设定的长度限制为255 bytes。 Connection： （连接）：Producer和Consumer都是通过TCP连接到RabbitMQ Server 的。以后我们可以看到，程序的起始处就是建立这个TCP连接。 Channels： （信道）：它建立在上述的TCP连接中。数据流动都是在Channel中进行 的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。 VirtualHost：权限控制的基本单位，一个VirtualHost里面有若干Exchange和 MessageQueue，以及指定被哪些user使用 2.走进RabbitMQ2.1.RabbitMQ安装（1）下载并安装 Eralng配套软件中已提供otp_win64_20.2.exe （以管理员身份运行安装） （2）下载并安装rabbitmq配套软件中已提供rabbitmq-server-3.7.4.exe。双击安装，注意不要安装在包含中文和 空格的目录下！安装后window服务中就存在rabbitMQ了，并且是启动状态。 （3）安装管理界面（插件）进入rabbitMQ安装目录的sbin目录，输入命令rabbitmq‐plugins enable rabbitmq_management （4）重新启动服务 （5）打开浏览器，地址栏输入http://127.0.0.1:15672 ,即可看到管理界面的登陆页 输入用户名和密码，都为guest 进入主界面： 上侧的导航以此是：概览、连接、信道、交换器、队列、用户管理 2.2.Docker环境下安装1.下载镜像 1docker pull rabbitmq:management 2.创建RabbitMQ容器 1docker run -di --name=tensqura_rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 15671:15671 -p 15672:15672 -p 25672:25672 rabbitmq:management 15672 (if management plugin is enabled) 15671 management监听端口 5672, 5671 (AMQP 0-9-1 without and with TLS) 4369 (epmd) epmd 代表 Erlang 端口映射守护进程 25672 (Erlang distribution) 3.登入RabbitMQ管理界面 访问地址：http://192.168.186.129:15672 账号密码均为guest 2.3.直接模式(Direct)2.3.1.什么是直接模式将消息发给唯一一个节点时使用这种模式，这是简单的一种形式。 任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue。1.一般情况可以使用rabbitMQ自带的Exchange：””(该Exchange的名字为空字符串，下文称其为default Exchange)。 2.这种模式下不需要将Exchange进行任何绑定(binding)操作 3.消息传递时需要一个“RouteKey”，可以简单的理解为要发送到的队列名字。 4.如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃。 2.3.2创建队列Name:队列的名称 Durability:是否持久化 Auto Delete:是否自动删除 2.3.3.代码实现- 消息生产者1.引入依赖 1234567891011121314151617181920212223&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐starter‐parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- rabbitMQ起步依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐starter‐amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐starter‐test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.配置文件信息 123spring: rabbitmq: host: 192.168.192.129 3.编写启动类 1234567@SpringBootApplication public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 4.编写测试类 12345678910@RunWith(SpringRunner.class) @SpringBootTest(classes=Application.class) public class MqTest &#123; @Autowired private RabbitTemplate rabbitTemplate; @Test public void testSend()&#123; rabbitTemplate.convertAndSend(\"队列名称\",\"我要红包\"); &#125; &#125; 2.3.4.代码实现-消息消费者12345678@Component @RabbitListener(queues=\"itcast\" ) public class Customer1 &#123; @RabbitHandler public void showMessage(String message)&#123; System.out.println(\"itcast接收到消息：\"+message); &#125; &#125; 2.4.分裂模式（Fanout）2.4.1.什么是分裂模式（Fanout）消息传递个多个队列的时候就可以采用这种模式 任何发送到Exchange的消息都会转发到绑定到该Exchange的队列中。 1.可以理解为路由表的模式 2.这种模式不需要RouteKey 3.这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个 Queue，一个Queue可以同多个Exchange进行绑定。（多对多的关系） 4.如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃。 2.4.2.交换器绑定队列1.创建交换器，类型选择为fanout 2.创建队列 3.交换器绑定队列 选择对应的交换器，点击进去 填写需要绑定的队列名称 2.4.3.代码实现-消息生产者1234@Testpublic void testSendFanout()&#123; rabbitTemplate.convertAndSend(\"chuanzhi\",\"\", \"分列模式走起\");&#125; 2.4.4.代码实现-消息消费者创建一个类去监听对应的队列 123456789@Component @RabbitListener(queues=\"需要监听的队列名称\" )public class Customer2&#123; @RabbitHandler public void showMessage(String message)&#123; System.out.println(\"itheima接收到消息：\"+message); &#125; &#125; 2.5.主题模式（Topic）2.5.1.什么是主题模式任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue 上。可以说是分裂模式一种加强。 在这个模式中出现了匹配规则 routing key：就是一个匹配队列的规则，可以给每个Exchange绑定的队列设置routing key ,当一个消息经过Exchange的时候，如果使用的是主题模式，会匹配routing key，然后分发到对象的队列中。 规则： .* 表示匹配一个点后面任意字符 .# 表示匹配一个点后面任意字符（但是这种允许后面有多个 . 例如 abc.ac.exc 能匹配 abc.# 但是不能匹配 abc.*） 这种模式与前面两种模式差不多，当经过Exchange和routing key的时候，没有可以转发的队列，那么就会丢弃这条消息。 2.5.2.创建队列与绑定1.创建队列，类型选择为topic 2.创建队列 3.绑定队列，并且设置routing key 2.5.3.代码实现-消息生产者12@Test public void testSendTopic1()&#123; rabbitTemplate.convertAndSend(\"topictest\",\"goods.aaa\",\"主题模式\"); &#125; 2.5.4.代码实现-消息消费者123456789@Component @RabbitListener(queues=\"需要监听的队列名称\" )public class Customer2&#123; @RabbitHandler public void showMessage(String message)&#123; System.out.println(\"itheima接收到消息：\"+message); &#125; &#125;","categories":[{"name":"MQ","slug":"MQ","permalink":"https://aaccompany.github.io/categories/MQ/"}],"tags":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://aaccompany.github.io/tags/消息中间件/"}]},{"title":"Active消息中间件","slug":"Active消息中间件","date":"2019-07-02T02:13:52.000Z","updated":"2019-07-10T05:08:29.951Z","comments":true,"path":"2019/07/02/Active消息中间件/","link":"","permalink":"https://aaccompany.github.io/2019/07/02/Active消息中间件/","excerpt":"","text":"消息中间件当没有采用消息中间件的系统模块图,当运营商后台去调用搜索服务和页面生成服务的时候，不需要知道他们返回的结果，所以在这里为了提高效率、降低系统耦合度可以采用消息中间件的解决方案。 当采用了消息中间件之后的系统模块图，中间去除了dubbo和减少了对搜索服务和页面生成服务的依赖，降低了系统耦合度 1.什么是消息中间件消息中间件利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。对于消息中间件，常见的角色大致也就有Producer（生产者）、Consumer（消费者） 1.1常见的消息中间件产品 JMS:JAVA MESSAGE SERVICE （1）ActiveMQ ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。 （2）RabbitMQ AMQP协议的领导实现，支持多种场景。淘宝的MySQL集群内部有使用它进行通讯，OpenStack开源云平台的通信组件，最先在金融行业得到运用。 （3）ZeroMQ 史上最快的消息队列系统 （4）Kafka Apache下的一个子项目 。特点：高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统。适合处理海量数据。 1.1.什么是JMSJMS（Java Messaging Service）是Java平台上有关面向消息中间件的技术规范，它便于消息系统中的Java应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发。 ​ JMS本身只定义了一系列的接口规范，是一种与厂商无关的 API，用来访问消息收发系统。它类似于 JDBC(java Database Connectivity)：这里，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。许多厂商目前都支持 JMS，包括 IBM 的 MQSeries、BEA的 Weblogic JMS service和 Progress 的 SonicMQ，这只是几个例子。 JMS 使您能够通过消息收发服务（有时称为消息中介程序或路由器）从一个 JMS 客户机向另一个 JML 客户机发送消息。消息是 JMS 中的一种类型对象，由两部分组成：报头和消息主体。报头由路由信息以及有关该消息的元数据组成。消息主体则携带着应用程序的数据或有效负载。 JMS 定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一 些不同形式的数据，提供现有消息格式的一些级别的兼容性。 · TextMessage–一个字符串对象 · MapMessage–一套名称-值对 · ObjectMessage–一个序列化的 Java 对象 · BytesMessage–一个字节的数据流 · StreamMessage – Java 原始值的数据流 1.2.JMS消息传递在消息传递存在两种类型： 1.2.1.点对点一个生产者会对应一个消费者，一个生成者发布的消息会存放在队列中，然后消费者不一定需要及时将队列的数据取出，而是可以不定时的去获取数据。当数据被取出的时候队列中的消息就会减少一条。 当存在多个消费者监听的队列是同一个的时候，谁先监听消息队列谁就先获取到数据。 1.2.2.发布/订阅一个生产者会对应多个消费者，当一个生产者发布了一条信息，会将数据存放在topic中，然后即时发生给每个在线的消费者，类似与广播的特性。 当有一个消费者没有上线的时候，会接受不到广播。 2.ActiveMQ安装（Linux）（1）将apache-activemq-5.12.0-bin.tar.gz 上传至服务器 （2）解压此文件 tar zxvf apache-activemq-5.12.0-bin.tar.gz （3）为apache-activemq-5.12.0目录赋权 chmod 777 apache-activemq-5.12.0 （4）进入apache-activemq-5.12.0\\bin目录 （5）赋与执行权限 12345678910111213141516 chmod 755 activemq -------------------------- **知识点小贴士**------------------------ linux 命令chmod 755的意思 chmod是 Linux 下设置文件权限的命令，后面的数字表示不同用户或用户组的权限。 一般是三个数字： 第一个数字表示文件所有者的权限 第二个数字表示与文件所有者同属一个用户组的其他用户的权限 第三个数字表示其它用户组的权限。 权限分为三种：读（r=4），写（w=2），执行（x=1） 。 综合起来还有可读可执行（rx=5=4+1）、可读可写（rw=6=4+2）、可读可写可执行(rwx=7=4+2+1)。 所以，chmod 755 设置用户的权限为： 1.文件所有者可读可写可执行 --7 2.与文件所有者同属一个用户组的其他用户可读可执行 --5 3.其它用户组可读可执行 --5 1.3.3启动​ ./activemq start 出现下列提示表示成功！ 假设服务器地址为192.168.25.135 ，打开浏览器输入地址 http://192.168.25.135:8161/ 即可进入ActiveMQ管理页面 点击进入管理页面 输入用户名和密码 均为 admin 进入主界面 点对点消息列表： 列表各列信息含义如下： Number Of Pending Messages ：等待消费的消息 这个是当前未出队列的数量。 Number Of Consumers ：消费者 这个是消费者端的消费者数量 Messages Enqueued ：进入队列的消息 进入队列的总数量,包括出队列的。 Messages Dequeued ：出了队列的消息 可以理解为是消费这消费掉的数量。 3.JMS入门小Demo3.1点对点Demo点对点的模式主要建立在一个队列上面，当连接一个列队的时候，发送端不需要知道接收端是否正在接收，可以直接向ActiveMQ发送消息，发送的消息，将会先进入队列中，如果有接收端在监听，则会发向接收端，如果没有接收端接收，则会保存在ActiveMQ服务器，直到接收端接收消息，点对点的消息模式可以有多个发送端，多个接收端，但是一条消息，只会被一个接收端给接收到，哪个接收端先连上ActiveMQ，则会先接收到，而后来的接收端则接收不到那条消息。 3.1.1添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-client&lt;/artifactId&gt; &lt;version&gt;5.13.4&lt;/version&gt; &lt;/dependency&gt; 3.1.2生产者代码注意： 1)在地址中传输协议为tcp 2）在第四步骤中的参数说明 第一个参数：是否开启事务 第二个参数消息的确定模式 AUTO_ACKNOWLEDGE = 1 自动确认 CLIENT_ACKNOWLEDGE = 2 客户端手动确认 DUPS_OK_ACKNOWLEDGE = 3 自动批量确认 SESSION_TRANSACTED = 0 事务提交并确认 12345678910111213141516171819202122232425public static void main(String[] args) throws Exception &#123; //1.创建连接工厂 //说明：使用想对应的是厂商的连接工厂 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://120.76.56.183:61616\"); //2.创建连接 Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.获取session //参数说明：1.是否启用事务2.消息确认模式 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建消息队列 //参数说明：队列的名称 Queue queue = session.createQueue(\"test-queue\"); //6.创建生产者 参数说明：生产者使用那个消息对象 MessageProducer producer = session.createProducer(queue); //7.创建消息 TextMessage message = session.createTextMessage(\"你真是个大傻吊\"); //8.发生消息 producer.send(message); //9.关闭资源 producer.close(); session.close(); connection.close(); &#125; 3.1.3消费者代码注意：需要创建匿名内部类 Message Listener 1234567891011121314151617181920212223242526272829303132public static void main(String[] args) throws Exception &#123; //1.创建连接工厂 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://120.76.56.183:61616\"); //2.创建连接 Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.获取session Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.监听对应的消息队列 Queue queue = session.createQueue(\"test-queue\"); //6.由会话，创建消息消费者 MessageConsumer consumer = session.createConsumer(queue); //7.监听消息 consumer.setMessageListener(new MessageListener() &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage)message; try &#123; System.out.println(\"监听到的消息\"+textMessage.getText()); &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;); //8.持续监听 System.in.read(); //9.释放资源 consumer.close(); session.close(); connection.close(); &#125; 3.2发布/订阅Demo3.2.1添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-client&lt;/artifactId&gt; &lt;version&gt;5.13.4&lt;/version&gt; &lt;/dependency&gt; 3.2.2生产者代码12345678910111213141516171819202122public static void main(String[] args) throws Exception &#123; //1.创建连接工厂 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://120.76.56.183:61616\"); //2.获取连接 Connection connection = connectionFactory.createConnection(); //3.开启连接 connection.start(); //4.获取session Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建topic Topic topic = session.createTopic(\"test-topic\"); //6.创建消息生产者 MessageProducer producer = session.createProducer(topic); //7.创建消息 由session去创建消息 TextMessage message = session.createTextMessage(\"啊啊啊啊，你可以简单点么\"); //8.发送消息 producer.send(message); //9.释放资源 producer.close(); session.close(); connection.close(); &#125; 3.2.3消费者代码1234567891011121314151617181920212223242526272829303132public static void main(String[] args) throws Exception &#123; //1.创建工厂 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://120.76.56.183:61616\"); //2.创建连接 Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.获取session Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.获取Topic Topic topic = session.createTopic(\"test-topic\"); //6.获取topic消费者 MessageConsumer consumer = session.createConsumer(topic); //7.设置监听 consumer.setMessageListener(new MessageListener() &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; System.out.println(\"topic监听到了\"+textMessage.getText()); &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;); //8.持久监听 System.in.read(); //9.关闭资源 consumer.close(); session.close(); connection.close(); &#125; 4.Spring整合ActiveMQ4.1点对点Demo4.1.1生产者代码123456789101112131415161718//JMS模板 负责发送消息 接受消息 @Autowired private JmsTemplate jmsTemplate ; //消息的目的地 @Autowired private Destination queueTextDestination; /** * 生成者发生信息 */ public void sendTextMessage(final String text) &#123; jmsTemplate.send(queueTextDestination, new MessageCreator() &#123; public Message createMessage(Session session) throws JMSException &#123; return session.createTextMessage(text); &#125; &#125;); &#125; 4.1.2配置文件1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:amq=\"http://activemq.apache.org/schema/core\" xmlns:jms=\"http://www.springframework.org/schema/jms\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"com.yuanxiong.producer\"&gt;&lt;/context:component-scan&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id=\"targetConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"&gt; &lt;property name=\"brokerURL\" value=\"tcp://120.76.56.183:61616\"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.SingleConnectionFactory\"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name=\"targetConnectionFactory\" ref=\"targetConnectionFactory\"/&gt; &lt;/bean&gt; &lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt; &lt;bean id=\"jmsTemplate\" class=\"org.springframework.jms.core.JmsTemplate\"&gt; &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 文本信息--&gt; &lt;bean id=\"queueTextDestination\" class=\"org.apache.activemq.command.ActiveMQQueue\"&gt; &lt;!-- 消息队列的值 --&gt; &lt;constructor-arg value=\"queue_text\"/&gt; &lt;/bean&gt; &lt;!--这个是订阅模式 文本信息 &lt;bean id=\"topicTextDestination\" class=\"org.apache.activemq.command.ActiveMQTopic\"&gt; &lt;constructor-arg value=\"topic_text\"/&gt; &lt;/bean&gt; --&gt; &lt;/beans&gt; 4.1.3消费者代码1234567891011121314151617181920212223package com.yuanxiong.consumer;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;import org.springframework.stereotype.Component;@Componentpublic class myMessageListener implements MessageListener &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; System.out.println(\"queue监听到了\"+textMessage.getText()); &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 4.1.4配置文件123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:amq=\"http://activemq.apache.org/schema/core\" xmlns:jms=\"http://www.springframework.org/schema/jms\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id=\"targetConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"&gt; &lt;property name=\"brokerURL\" value=\"tcp://120.76.56.183:61616\"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.SingleConnectionFactory\"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name=\"targetConnectionFactory\" ref=\"targetConnectionFactory\"/&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 文本信息--&gt; &lt;bean id=\"queueTextDestination\" class=\"org.apache.activemq.command.ActiveMQQueue\"&gt; &lt;constructor-arg value=\"queue_text\"/&gt; &lt;/bean&gt; &lt;!-- 我的监听类 --&gt; &lt;context:component-scan base-package=\"com.yuanxiong.consumer\"&gt;&lt;/context:component-scan&gt; &lt;!-- 消息监听容器 --&gt; &lt;bean class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\" /&gt; &lt;property name=\"destination\" ref=\"queueTextDestination\" /&gt; &lt;!-- 我的监听类 --&gt; &lt;property name=\"messageListener\" ref=\"myMessageListener\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 4.2发布订阅Demo4.2.1生产者代码123456789101112131415161718192021222324252627282930package com.yuanxiong.producer;import javax.jms.Destination;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.Session;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jms.core.JmsTemplate;import org.springframework.jms.core.MessageCreator;import org.springframework.stereotype.Component;@Componentpublic class TopicProducer &#123; @Autowired private JmsTemplate jmsTemplate; @Autowired private Destination topicTextDestination; public void sendTextMessage(final String string) &#123; jmsTemplate.send(topicTextDestination, new MessageCreator() &#123; public Message createMessage(Session session) throws JMSException &#123; return session.createTextMessage(string); &#125; &#125;); &#125;&#125; 4.2.2配置文件1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:amq=\"http://activemq.apache.org/schema/core\" xmlns:jms=\"http://www.springframework.org/schema/jms\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"com.yuanxiong.producer\"&gt;&lt;/context:component-scan&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id=\"targetConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"&gt; &lt;property name=\"brokerURL\" value=\"tcp://120.76.56.183:61616\"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.SingleConnectionFactory\"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name=\"targetConnectionFactory\" ref=\"targetConnectionFactory\"/&gt; &lt;/bean&gt; &lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt; &lt;bean id=\"jmsTemplate\" class=\"org.springframework.jms.core.JmsTemplate\"&gt; &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt; &lt;/bean&gt; &lt;!--这个是订阅模式 文本信息 --&gt; &lt;bean id=\"topicTextDestination\" class=\"org.apache.activemq.command.ActiveMQTopic\"&gt; &lt;constructor-arg value=\"topic_text\"/&gt; &lt;/bean&gt; &lt;/beans&gt; 4.2.3消费者代码1234567891011121314151617181920212223package com.yuanxiong.consumer;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;import org.springframework.stereotype.Component;@Componentpublic class myTopicMessageListener implements MessageListener &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage)message; try &#123; System.out.println(\"topic\"+textMessage.getText()); &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 4.2.4配置文件 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:amq=\"http://activemq.apache.org/schema/core\" xmlns:jms=\"http://www.springframework.org/schema/jms\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id=\"targetConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"&gt; &lt;property name=\"brokerURL\" value=\"tcp://120.76.56.183:61616\"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.SingleConnectionFactory\"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name=\"targetConnectionFactory\" ref=\"targetConnectionFactory\"/&gt; &lt;/bean&gt; &lt;!--这个是topic目的地，点对点的 文本信息--&gt; &lt;bean id=\"topicTextDestination\" class=\"org.apache.activemq.command.ActiveMQTopic\"&gt; &lt;constructor-arg value=\"topic_text\"/&gt; &lt;/bean&gt; &lt;!-- 消息监听容器 --&gt; &lt;bean class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\" /&gt; &lt;property name=\"destination\" ref=\"topicTextDestination\" /&gt; &lt;property name=\"messageListener\" ref=\"myTopicMessageListener\" /&gt; &lt;/bean&gt;&lt;/beans&gt;","categories":[{"name":"MQ","slug":"MQ","permalink":"https://aaccompany.github.io/categories/MQ/"}],"tags":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://aaccompany.github.io/tags/消息中间件/"}]}]}