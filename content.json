{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"https://aaccompany.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-07-08T05:37:11.090Z","updated":"2019-07-08T05:37:11.090Z","comments":false,"path":"/404.html","permalink":"https://aaccompany.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2019-07-08T15:06:27.997Z","updated":"2019-07-08T15:06:27.997Z","comments":false,"path":"about/index.html","permalink":"https://aaccompany.github.io/about/index.html","excerpt":"","text":"1234567891011121314151617 ┏┓ ┏┓ ┏┛┻━━━┛┻┓ ┃ ┃ ┃ ━ ┃ ┃ ┳┛ ┗┳ ┃ ┃ ┃ ┃ ┻ ┃ ┃ ┃ ┗━┓ ┏━┛ ┃ ┃ ┃ ┃ ┃ ┗━━━┓ ┃ ┣┓ ┃ ┏┛ ┗┓┓┏━┳┓┏┛ ┃┫┫ ┃┫┫ ┗┻┛ ┗┻┛ 固步自封，停滞不前"},{"title":"分类","date":"2019-07-08T05:37:11.095Z","updated":"2019-07-08T05:37:11.095Z","comments":false,"path":"categories/index.html","permalink":"https://aaccompany.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-07-08T14:07:26.564Z","updated":"2019-07-08T14:07:26.564Z","comments":false,"path":"repository/index.html","permalink":"https://aaccompany.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-08T05:37:11.099Z","updated":"2019-07-08T05:37:11.099Z","comments":false,"path":"tags/index.html","permalink":"https://aaccompany.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java中的线程池（第九章）","slug":"Java中的线程池","date":"2020-02-11T16:00:00.000Z","updated":"2020-02-12T10:34:29.273Z","comments":true,"path":"2020/02/12/Java中的线程池/","link":"","permalink":"https://aaccompany.github.io/2020/02/12/Java中的线程池/","excerpt":"","text":"Java中的线程池1.线程池好处Java线程池是运用场景最多的并发框架，几乎所有的需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理使用线程池能够带来3个好处 降低资源消耗：通过重复利用已创建的线程，降低线程创建和线程销毁造成的消耗 提高响应速度：当任务到达时，可以直接用线程池的空余线程执行，不需要等到线程创建再执行 提高线程的管理性：线程在系统中是稀缺资源，如果无限制的创建线程，不仅会消耗系统资源，还会降低系统的可用性，使用线程池可以进行统一分配、调优和监控 2.线程池的实现原理步骤1：如果当前运行线程少于corePoolSize，则创建新线程来执行任务（注意，执行这步骤需要获取全局锁） 步骤2：如果运行的线程等于或多余corePoolSize，则将任务加入到BlockingQueue(阻塞队列) 步骤3：如果无法将任务加入BlokingQueue，则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）也就是说，创建大于corePoolSize数量的线程，需要线程池线程等于corePoolSize和队列为满 步骤4：如果不断通过步骤3创建线程数大于maxmumPoolSize，将执行拒绝策略，也就是会调用RejectedExecutionHandler.rejectExecution()方法 ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会时 一个严重的可伸缩瓶颈）。在ThreadPoolExecutor完成预热后（预热：也就是当前运行线程数大于等于corePoolSize)，几乎所有的execute()方法都是执行步骤2，而步骤2不需要获取全局锁 2.1.线程池执行源码分析123456789101112131415161718192021//线程池中的执行任务的方法public void execute(Runnable command)&#123; if(command==null) throw new NullPointerException(); // 如果当前线程数小于基本线程数 ，则创建线程并且执行任务 if(poolSize&gt;=corePoolSize || !addIfUnderCorePoolSize(command))&#123; //如果创建新线程失败的话，线程池状态为RUNNING 则任务加入到工作队列中去 if(runState==RUNNING &amp;&amp; workQueue.offer(command))&#123; //如果处于停止状态，并且线程数量等于0 if(runState!=RUNNING || poolSize == 0) //确保处于队列的任务执行 ensureQueueTaskHandled(command); &#125; //上面执行完毕，说明线程池处于预热后的状态 //如果线程池不处于运行中或任务无法放进队列，并且当前线程数量小于最大允许的线程数量 //则创建一个线程执行任务 else if(!addIfUnderMaximumPoolSize(command)) //抛出RejectedExecutionException异常 reject(command); &#125;&#125; 工作线程：线程池创建线程时，会将线程封装成工作线程 Worker,Worker在执行完任务后，还会循环获取工作队列里来继续工作。下面为Worker中的run方法源码 123456789101112public void run()&#123; try&#123; Runnable task = firstTask; firstTask = null; while(task !=null || (task=getTask()) !=null )&#123; runTask(task); task = null; &#125; &#125;finally&#123; workerDone(this); &#125;&#125; 2.2. ThreadPoolExecutor执行任务流程步骤1：在execute方法中创建一个线程时，会用这个线程执行这个任务 步骤2：这个线程在执行完任务后，会重复从队列中获取任务并且执行 3.线程池的使用3.1.线程池的创建通过ThreadPoolExecutor来创建线程池 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 参数说明 corePoolSize：线程池基础大小，当一个任务提交到线程池的时候，线程池会创建一个线程来执行任务，即使线程池中存在空闲线程也会创建线程来执行任务，等到需要执行的任务数大于线程池的基本大小时就会不会继续创建，而是加入到队列中等待消费。 如果提前调用线程池的prestartAllCoreThreads()方法，线程池会提前创建好线程并且启动所有基本线程 maximumPoolSize：线程池的最大值，当队列满的时，再提交队列则会创建新的线程，然后执行任务，最大创建线程数会到达maximumPoolSize值 keepAliveTime：线程池的工作线程空闲时，保存存活的最长时间。如果任务量大，但是任务执行时间短，可以提高这个值，提高线程的利用率。 unit：时间单位，用于解释keepAliveTime的时间单位 workQueue：工作队列（使用阻塞队列），负责存储等待的任务阻塞队列，可以选择以下的阻塞队列 ArrayBlokingQueue：是一个基于数组结构有界阻塞队列，此队列按FIFO（先进先出）原则对元素进读取 LinkedBlokingQueue：是一个基于链表结构有界阻塞队列，此队列按FIFO（先进先出）原子对元素进行读取，吞吐量会大于ArrayBlokingQueue，静态工厂方法Executor.newFixedThreadPool()使用的就是这个阻塞队列 SysnchronizedQueue：一个不存储元素的阻塞队列。每个插入操作必须等待另外一个线程执行移除操作，否则插入操作将一直阻塞，吞吐量通常会大于LinkedBlokingQueue，静态工厂方法Executor.newCachedThreadPool使用了该队列 PriorityBlokingQueue：一个具有优先级的无界阻塞队列 threadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactorBuilder可以快速给线程池里的线程设置有意义的名字，代码如下。 1new ThreadFactorBuilder().setNameFormart(\"XX-task-%d\").build(); handler：饱和策略，当队列和线程都满了，说明线程池处于饱和状态，那么将必须采取一个策略处理新的提交的任务。线程池策略默认情况下为AbortPolicy，表示无法处理的时候将抛出异常。在JDK5中 Java线程池提供以下策略 AbortPolicy：直接抛出异常 CallerRunsPolicy：只用调用者所在线程来运行任务 DiscardOldestPolicy：丢弃队列里最近的一个任务，并且执行当前任务 DiscardPolicy：不处理，丢弃掉当前任务 3.2.向线程池提交任务线程池存在两个方法用来提交任务，分别是execute()和submit()方法 execute()方法用于提交不需要接受其返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可以发现执行的任务对象时Runnable类的实例 123456threadsPool.execute(new Runnable()&#123; @Override public void run()&#123; // TODO Auto-generated method stub &#125;&#125;) submit()方法用于提交有返回值的任务。线程池会返回一个Future类型的对象，通过这Future对象可以判断对象是否执行成功，并且通过future的get()方法来获取线程的返回值，get()方法会阻塞当前线程直到任务执行完成，而使用get(long timeout,TimeUnit unit)方法则会阻塞当前线程一段时间后立即返回，有时候这个线程还没有执行完毕。 1234567891011Future&lt;Object&gt; future = executor.submit(harReturnValueTask);try&#123; Object s = future.get();&#125;catch(InterruptedException e)&#123; //处理中断异常&#125;catch(ExecutionException e)&#123; //处理无法执行的异常&#125;finally&#123; //关闭线程池 executor.shutdown();&#125; 3.3.关闭线程池可以使用shutdwon()和shutdownNow()方法来关闭线程池。 他们的原理是遍历线程池中所有工作线程，然后逐个调用线程的interrupt()方法来中断线程，所以无法响应中断任务将可能永远无法终止。 shutdownNow()：首先将线程池的状态设置为STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行执行任务列表 shutdown()：将线程池状态设置为SHUTDOWN，然后中断所有没有正在执行任务的线程 只要调用这两个方法中的任意一个，isShutdown()方法就会返回true。当所有任务都已经关闭后，才表示线程池关闭成功，这时候调用isTerminaed()方法就会返回true 通常使用shutdown方法来停止线程池，如果不需要等待任务执行完毕的话，可以调用shutdownNow()方法来停止线程 3.4.合理地配置线程池要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。 任务的性质：CPU密集任务、IO密集型任务和混合型任务 任务的优先级：高、中和低 任务的执行时间：长、中和短 任务的依赖性：是否依赖其他系统资源，如数据库连接 3.4.1.根据不同任务性质配置线程池性质不同的任务可以用不同规模的线程池分开处理。 CPU密集型任务：应分配尽可能小的线程，如配置N(CPU)+1个线程的线程池，这样可以避免大量的线程上下文切换 IO密集型任务：这类型并非一直在执行任务，可能在等待IO，这种任务就需要配置尽可能多的线程，如配置2*N(CPU) 混合型任务：如果任务可以拆分，则将其拆分为CPU密集型任务和IO密集型任务，只要这两个任务执行的时间相差并不大，那么分解后交友不同的线程池执行，那么在分解后执行的吞吐量将高于串行执行的吞吐量。但是如果拆分后两个小任务的执行时间相差很大的话就不适合采用这种模式，因为一个小任务等待另外一个小任务会消耗大量时间 可以通过Runtime.getRuntime().availableProcessors()来获取当前设置的CPU个数 优先级不同的任务可以使用优先级队列PriorityBlokingQueue来处理，它可以让高优先级的任务先执行，但是低优先级的任务可能将永远不能执行 执行时间不同的任务可以交给不同规模的线程池来执行，或者使用优先级队列，优先执行执行时间短的任务 依赖数据库连接的任务因为线程在提交SQL后需要等待数据库返回结果，等待的时间越长，则CPU的空闲时间越长，那么针对这种任务可以适当的提高线程池的数量，这样就能更好的利用CPU资源 3.4.2.使用有界队列使用有界队列能够增加系统稳定性和预警能力，可以根据需要设置大一点，比如几千。 案例：在后台系统任务线程池队列和线程都满了，不断抛出抛弃任务的异常，通过排查发现是数据库出现问题，导致执行SQL变得非常缓慢，因为后台任务线程池中全都是需要向数据库插入数据和查询数据，所以导致线程池里的工作线程全部阻塞，任务会挤压在线程池里。如果设置为无界队列的话，队列会不断的膨胀，最后会导致内存爆炸，导致整个系统不可用，而不只是后台任务出问题。 3.5.线程池的监控如果系统中使用了大量的线程池，则十分有必要对线程池进行监控，方便在出现问题的时候根据线程池的状况快速定位问题。而我们可以使用线程池提供的参数进行监控，在监控线程池的时候可以使用以下的属性 taskCount：线程池需要执行的任务的数量 completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount largeestPoolSize：线程池里曾经创建过的最大线程数，通过这个数字可以判断线程池是否满过。如果这个数值等于线程池的最大值，则表示线程池曾经满过。 getPoolSize：线程池的线程数量。如果线程池不销毁话，线程池里的线程不会销毁，所以这个大小自增不减 getActiveCount：获取活动的线程数 4.手写一个线程池由上面的知识可以大致的写出下面的简单线程池实现 4.1.线程池接口1234567891011121314public interface ThreadPool &#123; //执行一个任务 void execute(Runnable command); //关闭线程池 void shutdown(); //增加工作线程 void addWorker(int mun); //移除工作线程 void removeWorker(int mun); //获取正在工作的线程数 int getActiveCount(); //获取线程池中的全部线程大小 int getPoolSize();&#125; 4.2.线程池的实现类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128public class ThreadPoolTest implements ThreadPool &#123; public ThreadPoolTest(int corePoolSize) &#123; workerQueue = new LinkedBlockingQueue&lt;&gt;(); threads = new ArrayList&lt;&gt;(); addWorker(corePoolSize); &#125; /** * 存储任务队列 * 线程安全 */ LinkedBlockingQueue&lt;Runnable&gt; workerQueue; /** * 存储工作线程 */ List&lt;Worker&gt; threads; /** * 工作线程 */ class Worker extends Thread &#123; private Runnable command; private int runState; public Worker(String name, int runState) &#123; super(name); this.runState = runState; &#125; @Override public void run() &#123; while (!Thread.currentThread().isInterrupted() &amp;&amp; (command = getWork()) != null) &#123; try &#123; setState(1); command.run(); &#125; finally &#123; setState(0); &#125; &#125; &#125; /** * 获取任务 */ public Runnable getWork() &#123; Runnable work = null; try &#123; work = workerQueue.take(); &#125; catch (InterruptedException e) &#123; System.out.println(\"线程响应中断===》停止获取任务\"); &#125; return work; &#125; /** * 获取工作线程的状态 * 1：表示运行 * 0：表示停止 */ public int getRunState() &#123; return runState; &#125; /** * 设置工作线程的状态 */ private void setState(int state) &#123; this.runState = state; &#125; &#125; @Override public void execute(Runnable command) &#123; //任务添加到任务队列 boolean isSuccess = workerQueue.offer(command); if (!isSuccess) &#123; throw new RuntimeException(\"提交任务失败\"); &#125; &#125; @Override public void shutdown() &#123; for (Thread thread : threads) &#123; thread.interrupt(); &#125; &#125; @Override public void addWorker(int mun) &#123; for (int i = 0; i &lt; mun; i++) &#123; Worker worker = new Worker(\"Thread-\" + threads.size(), 0); worker.start(); threads.add(worker); &#125; &#125; @Override public void removeWorker(int mun) &#123; if (mun&gt;threads.size())&#123; throw new RuntimeException(\"移除线程数超过最大值\"); &#125; int count = 0; Iterator&lt;Worker&gt; iterator = threads.iterator(); while (iterator.hasNext())&#123; Worker worker = iterator.next(); worker.interrupt(); iterator.remove(); count++; if (count==mun)&#123; break; &#125; &#125; &#125; @Override public int getActiveCount() &#123; int count = 0; for (Worker worker : threads) &#123; count = worker.getRunState()==1?count+1:count; &#125; return count; &#125; @Override public int getPoolSize() &#123; return threads.size(); &#125;&#125;","categories":[{"name":"多线程编程系列","slug":"多线程编程系列","permalink":"https://aaccompany.github.io/categories/多线程编程系列/"}],"tags":[{"name":"多线程编程","slug":"多线程编程","permalink":"https://aaccompany.github.io/tags/多线程编程/"}]},{"title":"HashMap 解析","slug":"HashMap解析","date":"2020-02-04T16:00:00.000Z","updated":"2020-02-06T10:48:46.551Z","comments":true,"path":"2020/02/05/HashMap解析/","link":"","permalink":"https://aaccompany.github.io/2020/02/05/HashMap解析/","excerpt":"","text":"浅析HashMap问题HashMap的数据结构HashMap数据结构是由数组和链表构成，具体可以表示为下图。 每个数组存储的位置的数据结构为key-value，这个结构在JDK7中称之为Entity在JDK8中称之为节点 put(&#39;key&#39;,value)执行步骤 通过内置Hash函数计算Key值然后取模于数组长度得出存储位置 然后将key-value存储到对应数组位置上 put方法执行过程待解决问题 用hash函数对Key进行计算并且取模于数组长度是有可能出现计算值重复，导致插入到数组的同一个位置。 在数组中有限的长度，如果插入大量的数据会使得HashMap与list没有区别了，并且也无法解决hash值计算重复的问题 根据以上的问题，也可以发现为什么HashMap要引入链表结构了 HashMap链表结构 每个节点会存在指向下一个节点的指针 链表如何插入？JDK7之前新值是替换原有值，然后原有值添加到链表中，也就是头插法 JDK8开始时改为尾插入新节点 HashMap是如何扩容？ HashMap的扩容机制 因为采用的是数组链表机制，数组容量有限，并且链表长到一定长度的话会降低访问效率，所以需要存在扩容机制 什么时候扩容（resize）？内部存在两个元素会影响扩容 1）Capacity : HashMap的容器大小 2）LoadFactor : 负载因子，默认为0.75f 什么是负载因子？有什么用？ 负载因子是告诉HashMap什么时候可以扩容 例如：负载因子0.75f , Capacity为100，当容器存储元素到达了75个再插入第76个的时候就会出发扩容机制 如何扩容？ 1）创建新的Entity数组，大小为原来的两倍 2）遍历全部元素重新计算Hash值，然后添加到新的数组中 为什么不直接将数据复制过去 而是重新计算Hash值呢？ 因为数据长度发生变化了，Hash的公式---&gt; index = HashCode（Key） &amp; （Length - 1） ，这就会导致存储的位置不对了，最后想要通过Key去获取value也会失败 为什么到JDK8链表便从头插换到尾插？put流程重要代码 1）首先hashmap进行元素的插入，在元素个数达到阀值时： 2) addEntry对判断桶有没有达到阀值，达到阀值就会走resize方法： 3) resize方法里调用transfer方法转移元素： 4) 将每个节点数据转移到新的数组中，而HashMap中出现死循环问题也是下面的代码逻辑上不合理 单线程环境 resize会重新计算Hash值并且添加回新的Table数组中，resize会将之前的链表顺序逆转，并且不会出现安全问题 多线程环境 环境：系统中存在两个线程同时插入元素并且同时使HashMap发生扩容 线程A：执行到了下图状态 线程B：对HashMap扩容完成 线程A继续执行代码，则会出现下图 这时候在内存中就会出现环状链表，后面进行get()的时候就会出现死循环，所以这也是头插入在多线程中出现的问题。 为什么采用尾插入，能够解决多线程扩容发生死循环问题（不能解决多线程数据安全问题） ​ 如果使用链表使用尾插入则在扩容的时候不会发生逆序的现象，自然也不会出现多线程环境下成环的情况 为什么HashMap默认初始化大小为16？1234/** * The default initial capacity - MUST be a power of two. */ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 阿里巴巴开发手册中也提到了，HashMap的初始长度最好设置为2的整数幂，哪怕传递非2的整数幂在内部也会向下取值，那么这么做的好处是什么 之前提到过，再每次调用put方法的时候，需要计算key的哈希值然后插入到对应位置上。 Hash的公式---&gt; index = HashCode（Key） &amp; （Length - 1） 假设Length= 16那么Length-1=15转化为二进制就是1111当一个Hash值与 1111做运算的时候，就等于Hash值的低四位。那么只需要保证哈希函数能够平均分配，那么计算出来的index值也是平均分配。 所以采用Length等于2的整数幂值就能够实现均匀分配","categories":[{"name":"Java集合类","slug":"Java集合类","permalink":"https://aaccompany.github.io/categories/Java集合类/"}],"tags":[{"name":"Map集合","slug":"Map集合","permalink":"https://aaccompany.github.io/tags/Map集合/"}]},{"title":"Java并发容器和框架（第六章）","slug":"Java并发容器和框架","date":"2020-02-02T16:00:00.000Z","updated":"2020-02-08T15:59:19.062Z","comments":true,"path":"2020/02/03/Java并发容器和框架/","link":"","permalink":"https://aaccompany.github.io/2020/02/03/Java并发容器和框架/","excerpt":"","text":"Java并发容器和框架1.ConcurrentHashMap的实现原理与使用ConcurrentHashMap是线程安全集合类，那么它是如何实现的呢？ 1.1.为什么要使用ConcurrentHashMap? 线程不安全的HashMap 多线程环境下使用HashMap，在JDK7HashMap扩容（resize）因为采用链表头插导致链表成环，遍历链表的时候就会出现死循环，导致CPU到达100%。在JDK8在扩容时采用链表尾插，就不会存在链表成环的现象，但是在多线程环境下put方法和get方法仍然时不安全的。 线程安全但效率低下的HashTable 线程安全的实现方式是方法锁，在使用调用一个方法的时候，其他全部方法都将阻塞，所以在线程竞争激烈的场景下效率会越来越慢 ConcurrentHashMap锁分段技术可有效提高访问率 HashTable因为多线程在争夺一把锁导致效率低下，而ConcurrentHashMap是为了避免多线程争夺一把锁引入了分段式锁的概念，每一把锁用于锁住容器中一部分数据，当多线程访问容器中不同数据段的时候便不会出现锁竞争现象，从而提高可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的分段技术。 首先将数据分成一段一段地存储，然后给每一段数据分配一把锁，当一个线程占用锁访问一段数据的时候，其他段的数据也能访问 1.2.ConcurrentHashMap的结构通过ConcurrentHashMap的类图来分析ConcurrentHashMap的结构 1.3.ConcurrentHashMap的初始化ConcurrentHashMap初始化方法是通过initialCapacity、loadFactor和concurrencyLevel等几个参数初始化segment数组、段偏移量segmentShift、段掩码segmentMask和每个segment中的HashEntity数组 1.3.1.初始化segment数组1234567891011if(concurrencyLevel&gt;MAX_SEGMENTS) concurrentLevel = MAX_SEGMENTS;int sshift = 0;int sszie = 1;while(ssize&lt;concurrencyLevel)&#123; ++sshift; ssize&lt;&lt;1;&#125;segmentShift = 32 - sshift;segmentShift = ssize -1;this.segments = Segment.newArray(ssize); 由上方代码可以发现，segment数组的长度是由concurrencyLevel计算得出。为了能通过按位与的散列算法来定位segment数组的索引，必须保证数组长度为2的N次方（power-of-two size)，所以必须计算出一个大于或等于concurrencyLevel的值做为数组长度。 假如concurrencyLevel为14、15、16最后数组长度也会为16 concurrentcyLevel的最大值为65535，说明了segment数组的长度最大值65536，对应的二进制是16位1 1.3.2.初始化segmentShift和segmentMask这两个全局变量需要在定位segment时的散列算法里使用，sshift等于ssize从1向左移动的次数，在默认情况下concurrencyLevel等于16，1需要向左移位4次，所以sshift等于4。 segmentShift用于定位参与散列运算的位数，segmentShift等于32减去sshift，所以等于28，这里之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数位32的。 segmentMask是散列运算的掩码，等于ssize减1，即15掩码的二进制各个位的值都是1。 因为ssize的最大长度是65536，所以segmentShift最大值是16（因为最大移动次数为16次，segmentShift = 32 - ssshift），segmentMask最大值是65535，对应的二进制是16位，每位都为1。 1.3.3.初始化每个segment输出参数initialCapacity是ConcurrentHashMap的初始容量，localfactor是每个segment的负载因子，在构造方法里需要通过这两个参数来初始化segment数组中的每个元素 123456789101112131415if(initialCapacity&gt;MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY;// c 的值为每个Segment中存放多少个元素int c = initialCapacity / ssize;// 避免没有整除向下取值，做加一操作if(c * ssize &lt; initialCapacity) ++c;// cap为具体存放多少个元素，取等于或大于c的2的次数幂int cap = 1;while(cap &lt; c)&#123; cap &lt;&lt;=1;&#125;for(int i = 0; i &lt; this.segments.length;i++) //初始化segment this.segments[i] = new Segment&lt;K,V&gt;(cap,loadFactor); 上面代码中的变量cap就是segment里HashEntity数组的长度，它等于initialCapacity除以ssize的倍数c，如果c大于1，则cap就会大于等于c的2的N次方值，所以cap的值不是1就是2的N次方。segment的容量threshold =(int) cap * loadFactor，默认情况下initialCapacity等于16，loadFactor等于0.75，带入运算cap等于1，threshold等于0 1.3.4.定位Segment既然ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素的时候，必须先通过散列算法定位到具体的segment。可以看到ConcurrentHashMap会首先使用Wang/Jenkins hash的变种算法对元素的hashCode再进行一次散列（也就是获取到key的HashCode然后再进行hash计算） 12345678private static int hash(int h)&#123; h += (h&lt;&lt;15) ^ 0xffffcd7d; h ^= (h&gt;&gt;&gt;10); h += (h&lt;&lt;3); h ^= (h&gt;&gt;&gt;6); h += (h&lt;&lt;2) + (h&lt;&lt;14); return h^ (h&gt;&gt;&gt;16)&#125; 之所以需要再散列，目的是为了减少散列冲突，使元素能够均匀地分布再不同的segment上，从而提高容器的存取效率。假如散列的质量差到极点，那么所有的元素都将在同一个segment中，不仅存取效率慢，同时会不断的扩容分布锁也将失去了意义。 123final Segment&lt;K,V&gt; segmentFor(int hash)&#123; return segemnts[ (hash&gt;&gt;segmentShift) &amp; segmentMask]&#125; 默认情况下segmentShift为28，segmentMask为15，再散列后的数最大值是32位二进制数据，向右无符号移动28位，意思是让高4位参与散列运算中（hash&gt;&gt;segmentShift)&amp;segmentMask的运算结果。就可以降低散列值冲突情况 1.4.ConcurrentHashMap的操作1.4.1.get操作Segment的get操作实现非常简单和高效。先经过一次散列后再进行散列，然后使用这个散列值通过散列运算定位到具体的Segment，再通过散列算法定位到元素，代码如下。 123456public V get(Object key)&#123; // 先获取key的hash值然后再进行散列 int hash = hash(key.HashCode()); // 先获取对应的Segment然后再获取对应的HashEntity return SegmentFor(hash).get(key,hash);&#125; get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空才会加锁重读。 HashTable容器的get方法是加锁的，那么ConcurrentHashMap的get操作是如何做到不加锁的呢？ 因为在ConcurrentHashMap中get方法所使用的共享变量都被volatile修饰，如用于统计当前Segment大小的count字段和用于存储值的HashEntity的value。这就保证了这些变量在多线程之间的可见性，能够被多线程同时读，并且保证不会读取到过期的值，但是只能被单个线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在get操作只需要读不需要写共享变量count和value，所以可以不用加锁。之所以不会读到过期的值，是因为根据Java内存模型happen before原则，对volatile字段的写操作先于读操作，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值。这就是用volatile替换锁的经典应用场景。 12transient volatile int count;volatile V value; 定位元素的代码可以发现，定位HashEntity和定位Segment的散列算法虽然医院，都在数组的长度减去1再相“与”的值不一样，定位Segment使用的是元素hashcode通过再散列后得到的值的高位，而定位HashEntity直接使用的是再散列后的值。其目的是为了避免两次散列后的值一样，虽然元素再Segment里散开了，但是却没有再HashEntity里散列开 12hash&gt;&gt;&gt; segmentShift ) &amp; segmentMask //定位Segment所使用的hash算法int index = hash &amp; (tab.length - 1) //定位HashEntity所使用的hash算法 1.4.2.put操作由于put方法里需要对共享变量进行写入操作，所以为了线程安全，在操作共享变量时必须加锁。put方法首先定位到Segment，然后在Segment里进行操作插入操作。 第一步：判断是否需要对Segment里的HashEntity数进行扩容 是否需要扩容 在插入元素前会先判断Segment里的HashEntity数据是否超过容量(threshold)，如果超过阈值，则对数组进行扩容。值得一提的是，Segment的扩容判断比HashMap更加合理，因为HashMap是在插入元素后判断是否到达容量的，如果到达了就进行扩容，但是很有可能扩容没有新元素插入，这时HashMap就进行了一次无用的扩容 如何扩容 在扩容的时候，首先会创建一个容量是原来容量的两倍的数组，然后将原数组里的元素进行再散列后插入到新数组里。为了高效，ConcurrentHashMap不会对整个容器进行扩容，而是只对某个segment进行扩容 第二步：定位需要添加元素的位置，然后将其放在HashEntity数组里 1.4.3.size操作如果要统计整个ConcurrentHashMap里元素的大小，就必须统计所有Segment元素的大小后求和。Segment里的全局变量count是一个volatile变量，那么在多线程环境下对全部Segment里的count相加是否就是ConcurrentHashMap的大小呢？ 然而并不是这样做就可以得到容器的大小，因为在多线程环境下，容器的大小会变化，导致了计算不精准。但是如果对全部Segment进行加锁，然后进行计算容器大小会导致效率低下。 在累加count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式统计各个Segment大小。如果统计的过程中，容器的count发生变化，则再采用加锁的方式来统计所有Segment大小。 ConcurrentHashMap是如何判断容器再进行计算大小的时候是否发生变化？使用modCount变量，在put、remove和clear方法里操作元素前都会将modCount变量加1，那么在统计size前后比较modCount是否发生变化，从而得知容器大小是否发生变化（也就是安全失败机制 fail-fast机制） 参考资料： 方腾飞：《Java并发编程的艺术》","categories":[{"name":"多线程编程系列","slug":"多线程编程系列","permalink":"https://aaccompany.github.io/categories/多线程编程系列/"}],"tags":[{"name":"多线程编程","slug":"多线程编程","permalink":"https://aaccompany.github.io/tags/多线程编程/"}]},{"title":"Java并发机制的底层实现原理（第二章）","slug":"Java并发机制的底层实现原理","date":"2020-02-02T16:00:00.000Z","updated":"2020-02-04T07:53:28.759Z","comments":true,"path":"2020/02/03/Java并发机制的底层实现原理/","link":"","permalink":"https://aaccompany.github.io/2020/02/03/Java并发机制的底层实现原理/","excerpt":"","text":"Java并发机制的底层实现原理1. Java运行过程 Java中所使用的并发机制依赖于JVM的实现和CPU指令，所以需要研究的地方便为这两处 2.多线程重要概念2.1.现代CPU模型一个CPU中会存在多核心，每个核心都会有多个缓存，这么做解决了CPU和主存速度不匹配的问题 CPU在运算的时候会先从高速缓存1-&gt;高速缓存2-&gt;…-&gt;主存获取数据，如果有一处命中则不会继续向下获取数据 2.2.多线程三大特性多线程编程中如果这三个性质没有得到保证就容易出现安全问题 123可见性：一个线程中修改了某个值，在其他线程可以察觉最新值原子性：一个操作或者多个操作，要么一起执行要么都不执行，原子性就像数据库事务一样像一个团队共同生死有序性：程序执行的顺序于代码顺序一致 2.2. CPU术语的定义 术语 英文单词 术语描述 内存屏障 memory barriers 一组处理器指令，用于实现对内存操作的顺序限制（顺序性） 缓冲行 cache line CPU高速缓存中可以分配的最小存储单位。处理器在填写缓存行时，会加载整个缓存行。现代CPU需要执行几百次CPU指令 原子操作 atomic operations 不可中断的一个或一系列操作 缓冲行填充 cache line fill 当处理器识别到从内存中去读操作数是可缓存的处理器读取整个高速缓存行到适应的缓存（L1、L2、L3到所有） 缓存命中 cache hit 如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时处理器从缓存中获取数据而不是从主存中获取数据 写命中 write hit 当处理器将操作数写回到一个内存缓存区域时，它首先回检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存而不是写回到内存，这个操作被称为写命中 写缺失 write misses the cache 一个有效的缓存行被写入到了不存在的内存区域 比较并交换 compare and swap CAS操作需要输入两个数值，一个是旧值（期望操作前的值）和一个新值在操作期间先比较旧值有没有发生变化，如果没有发生变化则更新成功或者失败 CPU流水线 CPU pipeline 指令的执行，需要取址、执行、IO等，这三个操作分别在不同CPU内部结构中执行但是为了提高CPU的吞吐量，会将这些操作异步执行 内存顺序冲突 Memory order violation 内存顺序冲突一般是由假共享起因的，假共享是指多个CPU同一时刻修改同一个缓存的不同部分当出现了这个冲突的时候CPU必须清空CPU流水线 3. Volatile多线程编程中Volatile和Synchronized都是常见修饰符 1234567891011121314例子：环境： 存在两个线程A、B分别在不同的核心中运行 存在一个共享变量var线程A 线程B - 读取var -修改var - 进行操作 - 读取var 问题：线程A再第二次读取var的变量并不是最新的值，而是脏数据因为线程B再修改完数据之后只是将数据写入到了CPU的高速缓存中，并没有写到主存线程A再读取值的时候也只会读取到高速缓存的值导致线程A读取到的值是脏数据 Volatile修饰符可以保证在多处理器环境下变量可见性 3.1. volatile的定义与实现原理Java编程语言允许线程访问共享变量，为了确保共享变量能够被准确和一直地更新，线程应该采用排他锁单独获取这个变量 是不是能够通过这个原理联想到在分布式环境下双缓冲的问题? Java语言提供了volatile在一些情况下会比加锁效果好，如果一个字段被修饰为volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的 有volatile修饰的变量在进行写操作的时候，会在汇编指令中加入lock的标识，当多核处理器发现lock标识会做两件事情 将当前处理器缓存行写入到主存中 上面的写入操作会使在其他处理器核心中缓存该内存地址的数据无效 为了解决CPU与主存的速度不匹配造成的处理速度低下的问题，处理器将不直接与主存进行通信，而是通过高速缓存。 这就会在多核处理器中出现脏数据，因为每个核心都会有数据备份，当有一个核心修改了数据，其他核心数据并未读取最新的数据造成。 为了保证各个缓存数据一致性，会实现缓存一致性协议MESI，每个处理器通过嗅探在总线上传播的数据来检查自己缓存是否已经过期，如果发现缓存过期，那么就会标识当前处理器的缓存为无效状态，当处理再次获取该缓存的时候会跳过缓存从主存获取最新值，并且修改缓存值。 3.2. volatile的两条实现原则 Lock前缀指令会引起处理器将数据写回主存 一个处理器在将缓存写回主存，会导致其他处理器对应内存地址的缓存失效 3.3. volatile优化从3.2中可以发现volatile 在写的过程中会导致其他处理器对应内存地址的缓存失效 所有多线程编程大师Doug Lea在LinkedTransferQueue类中，对头节点和尾节点进行字节填充 1234567891011//队列头节点private transient final PaddedAtomicReference&lt;QNode&gt; head;//队列尾节点private transient final PaddedAtomicReference&lt;QNode&gt; tail;static final class PaddedAtomicReference&lt;T&gt; extends AtomicReference&#123; //使用15个四节点的对象填充 Object p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pa,pb,pc,pd,pe; PaddedAtomicReference(T r)&#123; super(r); &#125;&#125; 为什么在对象中追加字节能够优化性能？ 在LinkedTransferQueue中，内部类PaddedAtomicReference扩展到了(15+1)*4字节也就是64字节 现代CPU中高速缓存的缓存行是64字节宽，不支持部分填充缓存行，这意味着，如果队列的头节点和尾节点都不足64字节，处理器会将他们读取到同一个缓存行中，在多个处理器核心都会缓存这个head、tail。如果其中一个处理器核心修改head的话，根据缓存一致性协议，其他处理器核心的该缓存行将失效，导致无法在高速缓存中获取尾节点数据，需要从主存中获取大大的降低了操作速度。 在队列中，入列和出列操作都很频繁，这就导致在多线程环境下会存在很多高速缓存失效的情况，所以Doug lea使用追加头节点和尾节点到64字节方式来填充高速缓存，避免头节点和尾节点填充到同一个高速缓存行，使头、尾节点在修改时不会相互锁定，这将大大提高在多线程环境下入列出列操作速度。 3.3.1.是不是什么时候都可以采用追加字节提高volatile效率？并不是在所有的场合都适用追加字节来提高volatile的效率，在一下两个场景时不能使用 缓存行为32字节宽的处理器：如P6系列和奔腾处理器，它们的高速缓存行为32字节宽 共享变量并不会被频繁的写：使用追加字节的方式采用空间换时间，如果不经常写的变量一般是不会被锁住的，所以也没有必要进行字节追加 在JDK7以上追加字节的方式会无效，因为JVM会智能淘汰或重新排列无用字段，所以需要使用其他方式来进行字段追加 4. Synchronized4.1. 什么是Synchronized？synchronized在1.6之前被称为重量级锁，性能低下。 1.6之后synchronized涅槃重生，进行了大量优化。提高了锁在释放和获取的效率 进行锁优化，例如自旋锁、适应自旋锁、锁消除、锁粗化 例如引入无锁、偏向锁、轻量级锁 ，重量级锁。增加锁升级的机制 4.2.锁优化观察下面的锁优化其实可以很容易发现，主要目的减少线程上下文切换次数，提高系统运行速度 4.2.1.自旋锁线程在获取锁的过程中，并不会获取不到锁就直接将当前线程加入同步队列，而是会在获取锁处循环获取。 因为在一般的同步代码块中，任务量少，执行时间很快，没有必要将线程加入同步队列，而是在锁处循环获取锁，其他线程能够很快的将锁释放。（默认自旋次数为10次） 好处：因为同步代码块任务量少，执行时间短，能够很快释放锁，其他线程也不需要加入到同步队列，减少了线程上下文切换，加快了线程运行时间 坏处：循环获取锁的弊端很明显，就是需要占用CPU运算资源，做无用的循环获取锁，如果获取不到则一直循环，浪费运输资源。所以同步代码块任务量大时使用自旋锁将降低系统运行效率 4.2.2.自适应自旋锁自适应自旋锁在自旋锁的基础上做了增强。 在Java 6 中加入了自适应自旋锁，该锁不同于自旋锁的地方为，该锁并非采用固定的自旋次数，而是会自动感知上次自旋时间以及锁的拥有者的状态来做。如果上次再很短的时间自旋获取锁，那么可以认为这次也能够在很短时间的获取到锁，那么就会允许它增加自旋次数。相反如果上次自旋没有获取到锁或者是很长时间才获取到锁，那么再下次获取锁的时候就会放弃自旋或者降低自旋次数 这样做的好处是避免因为自旋而浪费CPU的运算资源 4.2.3.锁消除多线程编程中，JVM会感知是否存在锁竞争的现象，如果不存在锁竞争的现象，那么将会撤销锁 锁消除的依据是逃逸分析的数据支持。如果不存在竞争，那么为什么还需要加锁，所以锁消除能够去掉没有必要请求锁和释放锁的时间。 但是多线程编程不是程序员编写的么？那为什么会出现不存在锁竞争但是还加锁的操作呢？是程序员有问题么？ 系统开发的过程中，不是说我们这样写就不会出现这个现象，它可能会因为我们不小心调用了JDK内置类或者第三方类库的时候出现的加锁操作 例如String Buffer、Vector、Hash Table等等，他们在一些方法上都会存在加锁操作，但是如果在单线程，或者变量未逸出的时候，这些加锁操作是否有必要？ 12345678public void vectorTest()&#123; Vector&lt;String&gt; vector = new Vector&lt;String&gt;(); for(int i = 0 ; i &lt; 10 ; i++)&#123; vector.add(i + \"\"); &#125; System.out.println(vector); &#125; 观察一下上方代码可以发现，vector变量一直在方法内，并没有逸出操作。所以它是不会出现安全问题，但是vector.add()会出现加锁操作，JVM检查到没有变量逸出，这时候就会锁消除 4.2.4.锁粗化多线程编程中，加锁操作一般都是在涉及到共享变量的时候才存在，而且在编程的过程中也会刻意的将同步代码块范围弄的小点，但是如果在代码中连续获取同一把锁，那么JVM会将锁的范围扩大，避免刚释放锁没有过多久又要申请锁的问题。 4.3. Synchronized以什么做为锁？在Java中所有对象都可以作为锁对象，具体表现为3类 对于普通同步方法，锁对象为当前实例对象 对于静态同步方法，锁对象为当前实例的类对象 对于同步方法块，synchronized(lockObject)锁对象为配置的对象 4.4. Synchronized在JVM如何体现？JVM基于进入和退出 Monitor对象来实现方法同步和代码块同步，但是两者具体实现不一样。代码块的同步实现是通过monitorenter和monitorexit来实现。方法同步时使用另外一种方式实现，但是JVM规范中没有详细说明。但是同步方法也可以使用两个指令来实现同步。 monitorenter：在代码编译后由JVM插入到同步方法前 monitorexit：在同步方法结束处和在异常结束处添加该指令。在异常处添加指令是为了避免无法释放锁，所以查看生成字节码文件会发现存在两个monitorexit指令 4.5. Synchronized同步过程每个对象在对象头都会有monitor的标识，当执行到同步方法的时候，当前线程会尝试获取对应对象的monitor，当获取到了则执行同步代码，否则将进入同步队列 4.5.1.对象头synchronized使用的锁是存在Java对象头的。如果Java对象为数组则虚拟机用3个字宽（Word）存储对象头，如果Java对象为非数组则用2个字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32 bit Java对象对数据结构 长度 内容 说明 32/64 bit Mark Word 存储对象的HashCode和锁信息等 32/64 bit Class Metadata Address 存储对象的类对象指针 32/64 bit Array Length 数组的长度（对象为数组时） Java对象头Mark Word存储结构以及变化过程 锁状态 25 bit 4 bit 1 bit 是否为偏向锁 2 bit 锁标志 无锁状态 对象的HashCode 对象的分代年龄（最大15岁） 0 01 偏向锁 线程ID( 占两部分Epoch Epoch)对象分代年龄 1 01 轻量级锁 指向栈中锁记录指针 指向栈中锁记录指针 指向栈中锁记录指针 00 重量级锁 执行互斥量的指针 执行互斥量的指针 执行互斥量的指针 10 GC标记 空 空 空 11 这个时候观察表格可以发现，为什么需要1 bit来描述是否为偏向锁，因为对象头的状态有5种，但是锁标记位只有2 bit导致不够描述，所以添加多一个bit作为说明 4.6.锁的升级与对比锁会锁着锁的竞争激烈程度进行升级，但是不能降级，这样做的目的是为了提高获取锁和释放锁的效率 4.6.1.偏向锁偏向锁顾名思义，偏向锁会偏向一个线程。 在大多数情况下，锁不仅不存在多线程竞争，而且总是同一个线程进入同步代码块，如果不断的进行获取锁释放锁效率将降低很多 所以偏向锁会记录第一次获取锁的线程ID，并且在这个线程再次进入的时候，直接放行，加快了进入同步代码块的速度 4.6.1.1.偏向锁的获取 4.6.1.2.偏向锁的释放偏向锁采用了一种等到出现多线程竞争的情况才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。 偏向锁的撤销，需要等待全局安全点（也就是GC点）。 偏向锁的过程 暂停拥有偏向锁的线程 检查拥有偏向锁的线程是否存活，如果该线程不处于活动状态，则将该对象头设置成无锁状态 如果线程处于活动状态，拥有偏向锁的线程栈会被执行，遍历变相对象的锁记录，栈中的锁记录和对象头的Mark Word 要么重新偏向其他线程，要么恢复到无锁状态或标记对象不适合作为偏向锁，最后唤醒暂停的线程 4.6.1.3.偏向锁流程图 4.6.1.4.关闭偏向锁如果系统存在很明显的锁竞争关系，那么可以关闭偏向锁，提高系统的允许速度。减少锁升级的过程 Java 6后默认开启偏向锁，但是它是存在启动延迟，也就是说在系统启动后X秒才开启偏向锁，如果又必要的话可以调整延迟时间，-XX:BiasedLockingStartupDelay=0。 如果系统对锁都存在竞争关系，那么可以关闭偏向锁-XX:-UseBiasedLocking=flase，那么系统将直接进入轻量级锁状态 4.6.2.轻量级锁会使用锁优化中的自适应锁自旋 4.6.2.1.轻量级锁的获取 线程栈中创建存储锁记录空间 将对象头中的Mark Word复制到锁记录空间（这个过程官方称之为Displaced Mark Word) 使用CAS替换对象头中Mark Word指向线程栈中锁记录，成功则获取锁，失败则自旋 4.6.2.2.轻量级锁的释放 使用CAS将锁记录中的Displaced Mark Word复制回对象头中Mark Word 如果成功则说明释放锁成功 失败则说明发生锁竞争，升级为重量级锁 4.6.2.3.轻量级锁膨胀流程图因为自旋会消耗CPU的运算资源，为了避免无用的自旋，一旦升级为重量级锁，则不会降级了。当锁处于这个重量级锁的状态，其他线程试图获取锁时都会阻塞，当持有锁的线程释放锁之后会唤醒所有被阻塞的线程，接下来则会进行锁竞争的过程。 4.6.3.不同锁的对比 锁 优点 缺点 使用场景 偏向锁 加锁和解锁不需要额外的消耗和非同步方法仅仅存在纳秒级的差距 如果线程间存在锁竞争会带来额外的锁撤销消耗 适用于只有一个线程访问同步代码块没有过多的锁竞争 轻量级锁 竞争的线程不会阻塞提高了程序响应速度 始终得不到锁的线程将不断地自旋浪费CPU运算 追求响应时间同步代码块执行时间很快适用于存在少量锁竞争场景 重量级锁 线程不会自旋，减少CPU的浪费 不断的进行请求锁和释放锁存在大量的线程上下文切换的消耗 执行速度最慢，因为相比于轻量级锁多了很多线程上下文切换的时间适用于锁竞争激烈的场景 5.原子操作的实现原理原子（atomic）本意是“不可进一步分割的最小粒子”，而原子操作（atomic operation)意为“不可以被中断的一个或一系列的操作” 5.1.处理器如何实现原子操作 解决方案有两种： 总线加锁：对总线加锁，在写的过程中，其他CPU都无法访问主存 缓存加锁：对缓存行加锁，在写的过程中会锁住该缓存行，在其他CPU中该缓存行失效，重新从主存获取 处理器会自动保证基本的内存操作的原子性 两种情况下处理器不会适用缓存行锁定 数据跨多个缓存行，CPU会采用锁总线操作；数据不能被加载进高速缓存 处理器不支持锁缓存行 5.2.Java如何实现原子操作Java中很多操作都非原子操作，例如最常见的i++就是一个非原子的操作 Java中可以采用CAS和加锁操作来完成原子操作 5.2.1.使用循环CAS实现原子操作JVM中的CAS操作是底层使用了处理器提供的CMPXCHG指令实现。 自旋CAS实现的基本思路循环CAS操作直到完成为止 从JDK1.5开始，Java提供的并发包提供了一些类来支撑某些原子操作，如AtomicBoolean(用原子方式更新Boolean)，AtomicInteger（用原子操作更新int值）等等 下面操作即为实现CAS线程安全的计数器方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Counter &#123; private AtomicInteger atomicI = new AtomicInteger(0); private int i = 0; public static void main(String[] args) throws InterruptedException &#123; final Counter counter = new Counter(); List&lt;Thread&gt; threadList = new ArrayList&lt;&gt;(100); long start = System.currentTimeMillis(); //创建100个线程 每个线程任务为计数自增1000次 for (int i = 0; i &lt; 100; i++) &#123; Thread t = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i1 = 0; i1 &lt; 1000; i1++) &#123; counter.safeCount(); counter.count(); &#125; &#125; &#125;); threadList.add(t); &#125; //开启100个线程 for (Thread thread : threadList) &#123; thread.start(); &#125; //main线程等待100个线程执行完毕 for (Thread thread : threadList) &#123; thread.join(); &#125; System.out.println(\"线程安全计数器:\"+counter.atomicI.get()); System.out.println(\"非线程安全计数器:\"+counter.i); System.out.println(\"执行耗时:\"+(System.currentTimeMillis()-start)); &#125; /** * 使用CAS的线程安全计数器 */ private void safeCount()&#123; //自旋CAS操作，减少线程上下文切换 for (;;)&#123; //获取最新值 int i = atomicI.get(); //使用CAS替换值，如果生成则退出 boolean suc = atomicI.compareAndSet(i, i + 1); if (suc)&#123; break; &#125; &#125; &#125; /** * 非线程安全计数器 */ private void count()&#123; i++; &#125;&#125; 5.2.2.使用CAS实现原子操作的三大问题 ABA问题 在CAS的原理上，是检查旧值和内存中的值是否一样，如果一样就替换为新值。这就会出现一个BUG，如果在更新的过程中有人修改了值，最后又变成了旧值，那么它在检查的时候CAS会发现值未发现改变，然后替换。 这个概念可能会很抽象，并且不好理解有啥危害。个人理解，简单的说就是狸猫换太子 举个例子： 小A有一个满的水，小A离开了房间 小B看到房间有杯水，喝完了然后倒回去 小A回来看到水还是水，然后继续喝了 解决方案： 每次修改都添加版本号，就像1A-&gt;2B-&gt;3A，这样就能够避免出现ABA的问题 在Java中提供了AtomicStampedReference类来实现 循环时间长开销大 通过5.2.1的代码可以发现有个for(;;)操作，不断的循环，做无用的运算 只能保证一个变量进行原子操作 如果有多个变量需要进行CAS原子操作，可以将多个变量合成一个Java对象，Java提供了AtomicReference来实现对象的原子操作 5.3.Java使用锁机制来完成原子操作锁机制保证了只有获取锁的线程才能进入同步代码块。JVM内部实现了很多锁机制，有偏向锁、轻量级锁、重量级锁（互斥锁），JVM中锁机制都是通过CAS来完成获取锁和释放锁 参考资料： 方腾飞：《Java并发编程的艺术》","categories":[{"name":"多线程编程系列","slug":"多线程编程系列","permalink":"https://aaccompany.github.io/categories/多线程编程系列/"}],"tags":[{"name":"多线程编程","slug":"多线程编程","permalink":"https://aaccompany.github.io/tags/多线程编程/"}]},{"title":"并发编程的挑战（第一章）","slug":"并发编程的挑战","date":"2020-01-30T16:00:00.000Z","updated":"2020-02-03T06:02:20.963Z","comments":true,"path":"2020/01/31/并发编程的挑战/","link":"","permalink":"https://aaccompany.github.io/2020/01/31/并发编程的挑战/","excerpt":"","text":"并发编程的挑战1.什么是多线程？1.1.为什么要使用多线程？并发编程的好处是为了提高系统运行速度 并不是启动越多的线程系统的运行速度就能越快，因为在多线程编程中会存在各种坑。例如：死锁、线程的上下文切换、硬件、软件。 如果没有理解好这些各种各样的坑的话，那么写出来的多线程程序并不能提高系统运行速度，反而会降低系统的运行速度 1.2.什么是线程的上下文切换CPU（单核）在某个时刻只能有一个线程执行，那系统中存在那么多的线程该如何执行呢？ CPU通过给每个线程分配时间片来实现多线程的执行。（时间片：CPU将时间划分为一个个小的时间段，每个时间段处理一个线程）在一个时间片之后如果该线程没有执行完毕，那么就会保存该线程当前状态，并且加入下个待执行线程的状态，执行 CPU保存当前线程状态–&gt;加载下一个线程状态 ：这个过程为线程的上下文切换 CPU线程的上下文切换会导致系统的运行速度低下 1.3.如何查看上下文切换次数和时长 Lmbench3可以测量上下文切换的时长 Linux命令vmstat可以测量上下文切换次数 1.4.如何减少线程上下文切换减少上下文切换的方法有无锁编程、CAS算法、使用最少线程和使用协程 无锁并发编程：多线程竞争锁的时候，会引发频繁的上下文切换，所以在多线程处理数据的时，可以采用一些方法避免使用锁，例如将数据的ID进行Hash算法取模分段，不同的线程处理不同数据段 CAS算法：Java的Atomic包下有许多类可以保证对单个变量的修改具有原子性，同时不会存在线程上下文切换，因为使用了自旋的模式来完成修改 使用最少线程：避免创建不需要的线程，比如系统任务量很少，但是线程数很多，导致会出现无用的线程上下文切换，所以在使用线程池的时候，并不是说将线程数设置越大越好，而是需要按需设置 协程：进程-&gt;线程-&gt;协程（上下级关系都为一对多），协程目前的多线程模型的最小单位，协程不由操作系统系统，而是由程序控制，减少了线程的上下文切换，因为根本不存在多线程。 2.锁2.1.什么是锁？旅游的时候会出现一个现象，许许多多的人在厕所门口排队上厕所，而上厕所的步骤就是等待上个人开门出来-&gt;下个人进入锁门 每个不同的人可以理解为不同的线程 厕所坑可以理解为临界资源 厕所坑一次只能有一个人蹲，所以人在上厕所的可以将门锁起来，让别人不能进来一起蹲 所以锁的作用可以理解为让满足条件的线程对临界资源访问 但是并不是说锁只能由一个线程持有，在读写锁ReentrantReadWriteLock，读锁和写锁互斥，读锁和读锁是共享。也就是说读锁和写锁在一个时刻中只用有一个持有锁，但是读锁和读锁能够同时持有锁 2.2.死锁 一个线程一直持有锁并且不释放锁，导致后面的线程无法执行 多个线程对多个资源获取顺序不一致导致相互等待对方释放资源，陷入死锁。例如 1234567线程： t1 t2资源： A B资源： B A这就会出现t1在等待B资源，但是B资源被t2持有t2在等待A资源，但是A资源被t1持有t1 t2 陷入相互等待的状态，这种状态也就是死锁 2.2.1.如何避免死锁 避免一个线程持有多个锁 一定要在finally代码块中释放锁 避免在一段代码中使用多个锁，尽量做到一个代码块占用一个锁 尝试使用定时锁，避免重复等待锁资源lock.tryLock(timeout) 对于数据库锁，加锁和解锁必须在同一个Connection中，否则会失效、并且会因为无法释放锁导致出现死锁 3.多线程编程与资源限制3.1.什么是资源限制多线程程序的运行速度并不是线程数多变快，而会受制于计算机的硬件资源和软件资源 例如：服务器下载速度2M/S，客户端单线程下载某资源的速度是1M/S，这时候并不会因为开启10个线程而让客户端的下载速度达到10M/S（因为服务器最大下载速度是2M/S，所以客户端最大只能开启两个线程让下载速度到达2M/S) 所以在多线程编程中需要考虑资源限制这个问题。 硬件资源：网络带宽、硬盘读写速度、CPU的处理速度 软件资源：数据库的最大连接数、socket的连接数 3.2.资源限制引发的问题客户端如果是单核CPU，强行将代码由串行修改为并行，那么会因为客户端的单核CPU导致预计中的并行执行仍然在串行执行，这样会造成多余的线程上下文切换时间消耗。 所以多线程编程中需要考虑资源限制引发的问题（并未提高效率，反倒于效率下降） 3.3.如何解决资源限制的问题解决资源限制的方法，就要从为什么会出现资源限制中解决。 发生资源限制是因为 硬件限制、软件限制 那么解决这两个限制，就可从根本上解决问题 解决硬件限制：单机处理速度跟不上，可以追加服务器数量，让运算在多机器上并发的执行 解决软件限制：合理提高连接池数量、socket连接数量、代码质量 参考资料： 方腾飞：《Java并发编程的艺术》","categories":[{"name":"多线程编程系列","slug":"多线程编程系列","permalink":"https://aaccompany.github.io/categories/多线程编程系列/"}],"tags":[{"name":"多线程编程","slug":"多线程编程","permalink":"https://aaccompany.github.io/tags/多线程编程/"}]},{"title":"重走框架系列说明","slug":"重走框架系列说明","date":"2019-07-14T11:47:47.000Z","updated":"2019-07-14T12:02:48.813Z","comments":true,"path":"2019/07/14/重走框架系列说明/","link":"","permalink":"https://aaccompany.github.io/2019/07/14/重走框架系列说明/","excerpt":"","text":"重走框架系列说明自我反思由于思想觉悟出现了问题，总想着快点学习，却没有想到丢了芝麻也丢了西瓜。 自己的基础严重的不牢固，导致前进的十分缓慢。又看了许多大神的教学视频，感觉自己依旧十分的弟弟，所以觉得自己有点揠苗助长，故有了重走框架系列，希望自己能够在这次重新学习后端框架的时候能够不断发现自己的知识盲区，找到自己的不足。 在重走框架的道路上，希望能够借助自己做的项目中，仔细思考在项目中引入新的后端框架会对系统增加严重的BUG，以及对这些BUG如何去做到预防以及解决。 借用《劝学》 故不积跬步，无以至千里，不积小流，无以成江海。 望自己能够一直记住。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://aaccompany.github.io/categories/杂谈/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://aaccompany.github.io/tags/杂谈/"}]},{"title":"重走spring框架 AOP部分","slug":"重走Spring框架(AOP部分)","date":"2019-07-14T11:40:50.000Z","updated":"2020-02-01T11:11:32.419Z","comments":true,"path":"2019/07/14/重走Spring框架(AOP部分)/","link":"","permalink":"https://aaccompany.github.io/2019/07/14/重走Spring框架(AOP部分)/","excerpt":"","text":"重走Spring框架（AOP部分）1.分析银行转账流程1.1.银行转账出现的问题 从代码的角度上分析 本次代码架构为：spring + dbutils + c3p0 从下图代码可以分析出，如果某个流程出现了异常，那么就会出现数据不匹配的现象，即可能出现转账没有进入目标账户。 发生原因： queryRunner对象在系统中采用的是多例模式，并且queryRunner在每次创建的时候会DataSource.getConnection意味着每次都是获取了新的连接对象，并且QeuryRunner对象在执行完语句后就会让内置的connection自动提交，将QeuryRunner对象中内置的Connection对象提取到service层便能在该层进行事务控制了。 解决方案： 将事务控制从dao层迁移到service层，让service具有commit rallback的权利 ThreadLoad数据和线程绑定？ ThreadLocal是什么？ 这是一个与单个线程绑定的类，这个类会开在内存中开辟一个空间，专门存储这个线程专属数据，做到线程隔离。 ThreadLocal如何实现的？ 每个线程都会去维护一个ThreadLocalMap，在这个特殊的Map中，key指的是线程本身，而value是存储的值，所以能够实现一个独属单个线程的数据存储，做到线程隔离。 ThreadLocal存储的数据会一直存在吗？ 在ThreadLocal的值不会一直存在，当线程死亡的时候，存储的值的空间也会被归还，但是需要用到JVM的垃圾处理机制，但是如果我们能够确定什么时候使用完毕，那么我们可以自行删除数据，调用ThreadLocal.remove()便可以做到数据与线程解绑，加快垃圾回收。 1.1.1.第一次改良 找到问题所在，将Connection与ThreadLocal线程绑定，保证在执行一次业务操作的时候使用的是同一个Connection同时在这个Connection中开启事务 流程图 第一步，创建ConnectionUtils：将原本注入到QueryRunner中的线程池取出来，改为由自己从DataSource获取Connection，将获取到的Connection与ThreadLocal进行线程绑定 1234567891011121314151617181920212223242526272829303132333435363738/** * @author Accompany * 获取当前线程的Connection */public class ConnectionUtils &#123; private DataSource dataSource; private ThreadLocal&lt;Connection&gt; threadLocal = new ThreadLocal&lt;&gt;(); public void setDataSource(DataSource dataSource) &#123; this.dataSource = dataSource; &#125; /** * 获取一个连接对象 * @return Connection对象 */ public Connection getThreadLocalConnection() &#123; try &#123; Connection connection = threadLocal.get(); if (connection == null) &#123; //表示当前线程没有连接对象 connection = dataSource.getConnection(); threadLocal.set(connection); &#125; return connection; &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException(\"出现未知异常\"); &#125; &#125; /** * 解除线程与Connection的绑定关系 */ public void removeConnection()&#123; threadLocal.remove(); &#125;&#125; 第二步，在Service层中开启事务：将ConnectionUtils注入到Service层中，获取到当前线程的Connection，然后开启线程并且传递到dao层中 123456789101112131415161718192021222324252627282930313233343536373839404142@Override public void transfer(String resourceId, String targetId, float money) &#123; //1.获取到当前线程的Connection对象 Connection connection = connectionUtils.getThreadLocalConnection(); try &#123; //2.开启事务管理 connection.setAutoCommit(false); //3.获取账户信息 Optional&lt;Account&gt; resourceOptional = accountDao.findById(resourceId); Optional&lt;Account&gt; targetOptional = accountDao.findById(targetId); if (!resourceOptional.isPresent() || !targetOptional.isPresent())&#123; throw new IllegalArgumentException(\"用户不存在\"); &#125; Account resourceAccount = resourceOptional.get(); Account targetAccount = targetOptional.get(); //3.修改余额 float resourceMoney = resourceAccount.getMoney() - money; if (resourceMoney&lt;0)&#123; throw new IllegalStateException(\"转账失败:余额不足\"); &#125; resourceAccount.setMoney(resourceMoney); targetAccount.setMoney(targetAccount.getMoney() + money); //4.执行更新 accountDao.update(resourceAccount); int a = 1/0; accountDao.update(targetAccount); //5.提交更新 connection.commit(); //6.将连接放回资源池 connection.close(); //7.解除线程与Connection的绑定关系 connectionUtils.removeConnection(); &#125;catch (Exception e)&#123; e.printStackTrace(); //8.发生异常回滚 try &#123; connection.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; &#125; 第三步：在Dao层获取当前线程的Connection对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @author Accompany * 账户Dao层 */public class AccountDaoImpl implements AccountDao &#123; private QueryRunner runner; public void setRunner(QueryRunner runner) &#123; this.runner = runner; &#125; private ConnectionUtils connectionUtils; public void setConnectionUtils(ConnectionUtils connectionUtils) &#123; this.connectionUtils = connectionUtils; &#125; @Override public void save(Account account) &#123; try &#123; String sql = \"insert into account values(?,?)\"; runner.update(connectionUtils.getThreadLocalConnection(),sql,account.getId(),account.getMoney()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; @Override public Optional&lt;Account&gt; findById(String id) &#123; Account account = null; try &#123; String sql = \"select * from account where id = ?\"; account = runner.query(connectionUtils.getThreadLocalConnection(),sql,new BeanHandler&lt;&gt;(Account.class),id); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return Optional.ofNullable(account); &#125; @Override public void update(Account account) &#123; try &#123; String sql = \"update account set money = ? where id = ?\"; runner.update(connectionUtils.getThreadLocalConnection(),sql,account.getMoney(),account.getId()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1.1.2.第二次改良 从第一次改良中可以发现，在service层中出现了try-catch已经其嵌套，同时也导致了代码量变长了，可以适当的封装，让其客观性更好。 流程图： 第一步，新增事务控制器：由于事务操作在需要的业务操作中都会存在，可以适当进行抽取，以达到代码重用性高，客观性强的目的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * @author Accompany * 事务管理器 */public class TransactionManager &#123; private ConnectionUtils connectionUtils; public void setConnectionUtils(ConnectionUtils connectionUtils) &#123; this.connectionUtils = connectionUtils; &#125; /** * 开启事务 */ public void beginTransaction() &#123; try &#123; connectionUtils.getThreadLocalConnection().setAutoCommit(false); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 提交事务 */ public void commit() &#123; try &#123; connectionUtils.getThreadLocalConnection().commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 回滚 */ public void rollback() &#123; try &#123; connectionUtils.getThreadLocalConnection().rollback(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 释放资源 */ public void release() &#123; try &#123; //将Connection放回连接池 connectionUtils.getThreadLocalConnection().close(); //将Connection与线程解绑 connectionUtils.removeConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 第二步，修改Service：因为新增了事务管理器TransactionManager所以就不需要在Service中引用Connection来控制事务，而是将事务管理权交给了事务管理器。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @author Accompany * 账户业务层 */public class AccountServiceImpl implements AccountService &#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; private TransactionManager transactionManager; public void setTransactionManager(TransactionManager transactionManager) &#123; this.transactionManager = transactionManager; &#125; @Override public void transfer(String resourceId, String targetId, float money) &#123; try &#123; //1.开启事务管理 transactionManager.beginTransaction(); //3.获取账户信息 Optional&lt;Account&gt; resourceOptional = accountDao.findById(resourceId); Optional&lt;Account&gt; targetOptional = accountDao.findById(targetId); if (!resourceOptional.isPresent() || !targetOptional.isPresent()) &#123; throw new IllegalArgumentException(\"用户不存在\"); &#125; Account resourceAccount = resourceOptional.get(); Account targetAccount = targetOptional.get(); //3.修改余额 float resourceMoney = resourceAccount.getMoney() - money; if (resourceMoney &lt; 0) &#123; throw new IllegalStateException(\"转账失败:余额不足\"); &#125; resourceAccount.setMoney(resourceMoney); targetAccount.setMoney(targetAccount.getMoney() + money); //4.执行更新 accountDao.update(resourceAccount); int a = 1 / 0; accountDao.update(targetAccount); //5.提交更新 transactionManager.commit(); //6.释放资源 transactionManager.release(); &#125;catch (Exception e)&#123; e.printStackTrace(); transactionManager.rollback(); &#125; &#125;&#125; 1.1.3.第三次改良 从第二次改良中可以发现，针对一个业务如果需要进行事务控制增加了不少的代码，但是如果是针对很多个业务的话就会出现代码重复，并且也不能让程序员更加专注的处理业务需求（因为需要关注事务管理）。所以可以加入动态代理，去增强原本的Servicec层。 什么是动态代理？ 动态代理是在，","categories":[{"name":"后端框架","slug":"后端框架","permalink":"https://aaccompany.github.io/categories/后端框架/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://aaccompany.github.io/tags/spring/"},{"name":"重走系列","slug":"重走系列","permalink":"https://aaccompany.github.io/tags/重走系列/"}]},{"title":"重走spring框架 IOC部分","slug":"重走spring框架(IOC部分)","date":"2019-07-14T11:40:50.000Z","updated":"2019-09-20T16:15:22.598Z","comments":true,"path":"2019/07/14/重走spring框架(IOC部分)/","link":"","permalink":"https://aaccompany.github.io/2019/07/14/重走spring框架(IOC部分)/","excerpt":"","text":"Spring框架学习过程中的问题： 为什么在使用JDBC使用的是Class.forName(&quot;DriverName&quot;) 而不是 DriverManager.register(new Driver)？ 工厂模式的好处是什么？ 工厂模式下创建的Bean对象应该为多例还是单例？ 什么时候用多例什么时候用单例？ Spring是如何做到立即加载的？ Spring核心容器下两个顶级接口的区别是什么？（BeanFactory/ApplicationContext） 为什么使用XML配置Bean需要给属性设置set/get方法才能注入，而使用注解配置Bean不需要设置set/get方法就能注入？ 配置注解类就取代掉配置文件，那么配置文件还有存在的意义吗？ 1.Spring到底是个什么妖魔鬼怪？1.1.Spring的自我介绍？1）Spring是分层的 Java SE/EE应用 full-stack （提供了全栈式的解决方案）轻量级开源框架 2）以 IoC（Inverse Of Control： 反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核 3）提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多 著名的第三方框架和类库 4）Java后端开发的标准 1.2. Spring的发展历程1997 年 IBM提出了EJB 的思想 1998 年，SUN制定开发标准规范 EJB1.0 1999 年，EJB1.1 发布 2001 年，EJB2.0 发布 2003 年，EJB2.1 发布 2006 年，EJB3.0 发布 Rod Johnson（spring之父） Expert One-to-One J2EE Design and Development(2002) 阐述了 J2EE 使用EJB 开发设计的优点及解决方案 Expert One-to-One J2EE Development without EJB(2004) 阐述了 J2EE 开发不使用 EJB的解决方式（Spring 雏形） 2017 年 9 月份发布了 spring 的最新版本 spring 5.0 通用版（GA） 1.3.为什么要使用Spring？1）方便解耦，简化开发 通过Spring提供的IOC（控制反转）容器，让Bean对象放入到Spring容器中，这样对象之间的依赖关系就可以由Spring去处理，避免硬编码造成程序耦合。也不需要注重Bean是设计成单例还是设计成多例的代码。可以花更多时间去注重上层代码 2）AOP支持(面向切面) 通过Spring提供的AOP支持，可以做到传统的OOP很难完成事情。 3）声明式事务的支持 可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理， 提高开发效率和质量。 4）方便程序的测试 可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可 做的事情 5）方便集合各种优秀的框架 可以很快的整合Mybatis、Spring MVC 、Struts等框架。 6）降低了Java EE的API使用难度 在Spring中，对Java EE（如 JDBC、JavaMail、远程调用等）进行了一层封装，能够通过更少的代码去使用这些技术。 7）代码编写的榜样 Spring采用的代码编写的技巧，设计都十分巧妙，结构清晰，注释完整。是十分值得学习的榜样。 1.4.Spring的体系结构在Spring的体系结构中也可以看出Spring是个full-stack型框架，提供了各层的解决方案。 其中重要的是Core Container中的部分，这是使用Spring必备部分，不可缺失。 2.如何做到程序解耦？（IOC部分）2.1.程序的耦合和解耦在说明IOC先知道什么是程序的耦合和耦合 2.1.1.程序的耦合？在软件工程中，耦合指的就是就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。划分模块的一个 准则就是高内聚低耦合。 它有如下分类： 模块耦合分为数据耦合、特征耦合、控制耦合、公共环境耦合、内容耦合。耦合程度由低到高。 1）数据耦合： 两个模块彼此间通过参数交换信息，而且交换的信息仅仅是数据（指的是单一的原子的数据片段），那么这种耦合称为数据耦合。数据耦合是低耦合。系统中至少必须存在这种耦合。这是不可避免的。 2）特征耦合 当把整个数据结构作为参数、局部变量或者返回值，而被调用的模块只需要使用其中一部分数据元素时，就出现了特征耦合。（意思为传递了一个数据结构，但是调用方没有将该数据结构中全部数据使用便为特征耦合） 比如判断一个人是否成年，只需要传递该人的出生日期即可，不必要把人传进去。 因此这种耦合，通常是可以通过修改参数、局部变量或者返回值，只使用必要的数据元素来避免。 3）控制耦合 传递的信息中有控制信息(尽管有时这种控制信息以数据的形式出现)，则这种耦合称为控制耦合。控制耦合是中等程度的耦合。 比如，传递的参数中包含一个枚举类型的参数，在方法的具体逻辑中判断该参数实现不同的功能。那么，完全可以通过将一个方法修改为多个方法改进这种耦合。 4）公共环境耦合 当两个或多个模块通过一个公共数据环境相互作用时，它们之间的耦合称为公共环境耦合。公共环境可以是全程变量、共享的通信区、内存的公共覆盖区、任何存储介质上的文件、物理设备等。公共环境耦合的复杂程度随耦合的模块个数而变化，当耦合的模块个数增加时复杂程度显著增加。 只有两个模块有公共环境，耦合有下面两种可能。 一个模块往公共环境送数据，另一个模块从公共环境取数据。这是数据耦合的一种形式，是比较松散的耦合。 两个模块都既往公共环境送数据又从里面取数据，这种耦合比较紧密，介于数据耦合和控制耦合之间。 限制范围，比如如果是依赖的是汇率，提供一个统一获汇率配置的方法，限制耦合范围。 5）内容耦合 最高程度的耦合是内容耦合。如果出现下列情况之一，两个模块间就发生了内容耦合。 一个模块访问另一个模块的内部数据。 一个模块不通过正常入口而转到另一个模块的内部。 两个模块有一部分程序代码重叠(只可能出现在汇编程序中)。 一个模块有多个入口(这意味着一个模块有几种功能)。 应该坚决避免使用内容耦合，重构吧。 2.1.4.解决jdbc代码耦合思考1：为什么在使用JDBC使用的是Class.forName(&quot;DriverName&quot;) 而不是 DriverManager.register(new Driver)？ 第一：使用DriverManager.register 会出现强依赖的现象 第一步出现了依赖现象，如果在Maven中没有导入jdbc的包则会在编译期出现错误。 12345678910111213141516171819//1.注册驱动 在这一步因为需要new 一个Driver对象，出现了强依赖 DriverManager.registerDriver(new com.mysql.jdbc.Driver()); //2.创建连接 Connection con = DriverManager.getConnection(\"url\",\"username\",\"password\"); //3.使用连接，创建sql预处理对象 String sql = \"select * from department\"; PreparedStatement ps = con.prepareStatement(sql); //4.执行查询对象 ResultSet resultSet = ps.executeQuery(); //5.遍历数据 while (resultSet.next())&#123; System.out.print(resultSet.getString(\"id\")); System.out.print(resultSet.getString(\"name\")); System.out.println(); &#125; //6.释放资源 resultSet.close(); ps.close(); con.close(); 第二：如果使用的是DriverManager.register的方式去注册，那么驱动会被注册两次 第一次：从翻看源码中可以发现一旦 com.mysql.Driver 被加载，则会调用静态构造函数从而执行java.sql.DriverManager.registerDriver(new Driver());完成驱动注册 第二次：为自己在代码中手动注册了注册 123456789101112131415161718192021222324//该mysql连接包的版本为5.1.46 在6.0+的版本中，就不使用com.mysql.Driver的类了//而是使用com.mysql.cj.jdbc.Driver去完成注册操作public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; // // Register ourselves with the DriverManager // static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException(\"Can't register driver!\"); &#125; &#125; /** * Construct a new driver and register it with DriverManager * * @throws SQLException * if a database error occurs. */ public Driver() throws SQLException &#123; // Required for Class.forName().newInstance() &#125;&#125; 使用Class.forName(String driverName)的好处 使用了这种方式传递的是字符串，所以并不会在编译期出现错误。从而减少了耦合度 1234567891011121314151617181920212223//1.注册驱动 在这一步因为需要new 一个Driver对象，出现了强依赖 //DriverManager.registerDriver(new com.mysql.jdbc.Driver()); //在5.0的驱动版本中使用的是 //Class.forName(\"com.mysql.jdbc.Driver()\"); // 在6.0+的驱动版本中使用的是 Class.forName(\"com.mysql.cj.jdbc.Driver\"); //2.创建连接 Connection con = DriverManager.getConnection(\"jdbc:mysql://120.76.56.183:33306/qingzhai_base\",\"root\",\"root\"); //3.使用连接，创建sql预处理对象 String sql = \"select * from department\"; PreparedStatement ps = con.prepareStatement(sql); //4.执行查询对象 ResultSet resultSet = ps.executeQuery(); //5.遍历数据 while (resultSet.next())&#123; System.out.print(resultSet.getString(\"id\")); System.out.print(resultSet.getString(\"name\")); System.out.println(); &#125; //6.释放资源 resultSet.close(); ps.close(); con.close(); 2.1.3耦合总结总之，耦合是影响软件复杂程度的一个重要因素。应该采取下述设计原则：尽量使用数据耦合，少用控制耦合和特征耦合，限制公共环境耦合的范围，完全不用内容耦合。 ps: 编译器不依赖，运行期才依赖 2.2.如何更加通用的方式解决程序耦合问题？通过在2.1.4.中发现了可以使用字符串的方式减少了 new 关键字的出现，便减少程序的耦合度。由此可以进一步挖掘，是否在之后的new 对象的过程省略，而是使用字符串去完成对象的创建，这样便进一步的解决了系统的耦合度。 这时候就可以想到使用Java的反射，创建一个配置文件，在配置文件中，设置类的关键字映射到对应类的全路径上，通过反射完成对象的创建。 2.2.1.使用工厂模式解耦2.2.1.1.什么是工厂模式个人理解：将创建的类的过程交由工厂去解决，工厂负责封装具体创建类的过程，只对外提供对应的方法，客户端只需要调用对应的接口便可以获取到对应的类。 好处：通过工厂模式可以进一步解除系统耦合。 图解： 在未使用工厂模式下客户端直接获取资源(也就是new 对象)，这就造成了高耦合度，不易于扩展 当使用了工厂模式情况下，客户端需要通过工厂去获取对象，而具体的实现过程被工厂隐藏，工厂读取配置文件，通过反射实例化对象，系统便具有了高扩展性。 2.2.1.2.简单使用工厂模式创建类简单使用：通过BeanName创建对象，减少耦合程度 123456789101112131415161718192021222324252627282930313233343536/** * @author : Accompany * @date : 2019/09/10 * 实现类对象的创建 */public class BeanFactory &#123; private static Properties properties; //加载配置文件信息 static &#123; try &#123; //通过类加载器读取配置文件 InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(\"application.properties\"); properties = new Properties(); properties.load(in); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static Object getBean(String beanName)&#123; //获取到类路径 String beanPath = properties.getProperty(beanName); //创建类对象 try &#123; return Class.forName(beanPath).newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 2.2.1.3.完善工厂模式问题1：单例和多例的区别是什么？好处是什么？ 区别： 单例：多次通过工厂模式创建同一个对象只会在内存中存在一个实例。 使用场景：在类中有共享数据或没有成员变量（例如 dao层 service层 ） 好处：因为只创建了一个实例，节省内存和JVM垃圾回收造成的性能浪费、可以存放共享数据（但是会存在线程安全问题）、效率会比多例模式快 坏处：因为是单例的所以会出现线程安全问题 多例：每次通过工厂模式去创建同一个对象都会在内存中创建一个新的实例 使用场景：当一个类只需要临时使用、每次都需要读最新的配置文件的时候可以使用。 好处：防止并发错误，如果在多线程的情况下，使用的是单例，假如修改了状态值，那么整个请求就会发生异常。 坏处：因为是不断的创建对象，就会占用大量的内存，同时也会导致GC的活动频繁导致性能下降。 问题2：创建Bean应该为多例还是单例？ 具体问题需要具体分析 像dao层和service层，没有了成员变量，在线程安全问题上就降低很多，可以使用单例模式 像controller层，在struts2中使用的是多例，但是在spring mvc中使用的是单例。 当对象含有可改变状态时（更精确的说，在实际的应用中该状态会发生改变），使用多例，否则单例 修改代码：同时这也是spring的设计思想，当bean为单例的时候，会将对象在容器初始化的时候创建并且存进Map集合中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class BeanFactory &#123; private static Map&lt;String,Object&gt; objectMap; //加载配置文件信息 static &#123; try &#123; //通过类加载器读取配置文件 InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(\"application.properties\"); Properties properties = new Properties(); objectMap = new HashMap&lt;String, Object&gt;(); properties.load(in); //将配置文件中全部的对象映射地址创建成对象封装到map集合中 Enumeration&lt;Object&gt; keys = properties.keys(); while (keys.hasMoreElements())&#123; //读取某个对象路径地址 String objKey = (String) keys.nextElement(); String objPath = properties.getProperty(objKey); Object object = Class.forName(objPath).newInstance(); objectMap.put(objKey,object); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static Object getBean(String beanName) throws ClassNotFoundException &#123; /* 未修改前 //获取到类路径 String beanPath = properties.getProperty(beanName); //创建类对象 try &#123; return Class.forName(beanPath).newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return null; */ if (!objectMap.containsKey(beanName))&#123; throw new ClassNotFoundException(\"类不存在\"); &#125; return objectMap.get(beanName); &#125;&#125; 2.3. IOC是个啥玩意？IOC ：inversion of control （控制反转），这是一种思想理念，并不是只有Spring独有的，在Spring中使用DI去实现了这种思想。 在Spring中的解释为将Bean的创建权、管理权转交由Spring去管理，这样程序员就不必过多的关注Bean的生命周期的问题了，可以更加关注于业务处理。 2.3.1. Spring中IOC 1）在工程的POM文件中导入Spring-Context的基本坐标,便具备了Spring IOC功能 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; 当导入文件会发现会多了很多依赖，对应1.4中Spring的体系结构，可以看出点端倪 自动加入了spring-apo包，说明了Spring的基础功能需要依赖spring-aop spring中对apache.logging日志处理系统进行封装（spring-jcl包）这就需要注意，如果导入其他框架，该框架也有日志系统的话，那么就会出现冲突问题，这时候就需要解决了。 2）在resources目录下创建配置文件（*.xml）文件，该文件的作用为，阐述类的信息和类之间依赖关系 配置文件信息 根据前面的如何自定义手动解耦的思想，那么可以知道，在配置文件中最起码需要具备 一个标识符、标识符指向的类的全路径 所以在Spring的配置文件中便会出现Beans的大标签下有Bean的小标签代表着一个个的bean对象。 id便是标识符、class便是指向类的全路径 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean class=\"com.accompany.spring.demo1.service.impl.studentServiceImpl\" id=\"studentService\"&gt; &lt;/bean&gt;&lt;/beans&gt; 3）在简单使用 在ui中读取配置文件，并且将存储在spring IOC容器的对象取出 12345678public static void main(String[] args) &#123; //读取配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(\"application.xml\"); //将对象从IOC容器中取出 studentService studentService = (studentService) context.getBean(\"studentService\"); //调用方法 studentService.findAll(); &#125; 2.3.2. Spring 的 BeanFactory 是什么？BeanFactory是spring的工厂模式的顶级接口。同时可以从图中看出该接口具体很多实现类，到那时具体使用的只有三个。 AnnotationConfigApplicationContext：是有关于注解配置 ClassPathXMLApplicationContext：读取src目录下的配置文件，也就是存放在resources下的配置文件 FileSystemXmlApplicationContext：读取系统中绝对路径下XML文件文件（不推荐使用） 2.3.3. BeanFacotry与ApplicationContext的区别BeanFacotry是一个顶级接口，而ApplicationContext是继承了BeanFactory下的HierarchicalBeanFactory也就是说，间接的继承了BeanFactory。 BeanFacotry与ApplicaitonContext区别 他们在创建Bean对象的时间点不同， BeanFacotry（实现类XMLBeanFactory已经弃用的对象）采用的策略是懒加载策略： 懒加载：在Bean对象被使用的时候才被加载，容器初始化的时候不会被加载 ApplicaitonContext采用的策略是立即加载 立即加载：在容器初始化的时候就被加载放进了Map集合 思考：什么时候使用懒加载什么时候使用立即加载呢？ 单例模式使用立即加载 多例模式使用懒加载（因为多例模式最好是在需要的时候在去创建是最节省空间的） 2.3.4. IOC中Bean标签和管理对象细节2.3.4.1. Bean标签bean标签存在的位置：在spring的配置文件中出现 作用：将对象的管理权交由spring管理 属性： id：指向全路径类的标识符（通常写成类名/接口名） class：类的全路径信息 scope：指定类对象的作用范围 singleton：默认值 单例 prototyoe：多例 request：WEB项目中，将该对象创建放进request域中 session：WEB项目中，将该对象创建放进session域中 global session：WEB项目中，应用在分布式环境下，将对象创建放进全局session中，如果不是分布式环境下，那么该配置相当于session 2.3.4.2实例化Bean的三种方式 第一种：通过构造函数去实例化Bean 在无参构造函数下实例化 参数说明： bean：声明一个交由Spring IOC管理的Bean对象 id：指向全路径类的标识符（通常写成类名/接口名） class：类的全路径信息 这种方式创建的对象是针对无参构造函数的，当存在有参构造函数的时候会出现错误 12&lt;bean id=\"studentService\" class=\"com.accompany.spring.demo1.service.impl.studentServiceImpl\" &gt;&lt;/bean&gt; 在有参构造函数下实例化 参数说明 constructor-arg：阐述构造函数参数的信息 name：表示参数的名称 value：插入基本数据类型和String类型 ref：插入对象类型数据（该对象类型数据必须交由Spring管理才能注入） 1234567&lt;bean id=\"Student\" class=\"com.accompany.spring.demo1.bean.Student\"&gt; &lt;constructor-arg name=\"name\" value=\"张三\"/&gt; &lt;constructor-arg name=\"age\" value=\"15\"/&gt; &lt;constructor-arg name=\"birthday\" ref=\"date\"/&gt;&lt;/bean&gt;&lt;bean id=\"date\" class=\"java.util.Date\"&gt;&lt;/bean&gt; 第二种：通过静态工厂模式实例化 该模式是当存在一个工厂，该工厂具有一个静态方法可以获取到一个对象，那么可以通过该方法获取到返回的对象直接放入spring容器中，无须将工厂注入也可以完成。（这种适用于框架整合，同时该方法必须为静态方法） 工厂对象： 123456789public class StaticFacotry &#123; private static Student student = new Student(); public static Student createStudent()&#123; student.setName(\"梨花\"); student.setAge(11); student.setBirthday(new Date()); return student; &#125;&#125; 配置文件： 需要注意 class 写的是工厂类的全路径，factory-method 写的是从工厂获取到类的方法 不需要提供需要实例化的对象的全路径 如果方法中需要传值，那么就需要在实例化的对象中加入构造传值 1&lt;bean id=\"StaticStudent\" class=\"com.accompany.spring.demo1.Factory.StaticFacotry\" factory-method=\"createStudent\" /&gt; 第三种：通过非静态工厂实例化 该模式是当存在一个工厂，该工厂具有一个非方法可以获取到一个对象，需要将工厂注入到Spring容器，再通过具体需要实例化的类去调用注入的工厂的方法完成实例化（这种适用于框架整合，这个工厂方法为非静态方法） 工厂对象 123456789public class Factory &#123; private static Student student = new Student(); public Student createStudent()&#123; student.setName(\"张三丰\"); student.setAge(100); student.setBirthday(new Date()); return student; &#125;&#125; 配置文件 需要注意：在使用非静态工厂方法的时候 1.先将工厂对象交由spring管理 2.在需要实例化的对象中加入 factory-bean：指向spring中工厂类 3.factory-method：为工厂类中提供对象的方法 4.在需要实例化的对象中不需要添加实例化对象的全路径 5.如果方法中需要传值，那么就需要在实例化的对象中加入构造传值 1234&lt;bean id=\"factory\" class=\"com.accompany.spring.demo1.Factory.Factory\"/&gt;&lt;bean id=\"student\" factory-bean=\"factory\" factory-method=\"createStudent\"&gt; &lt;constructor-arg name=\"string\" value=\"yyx\"/&gt;&lt;/bean&gt; 2.3.4.3. Bean对象的生命周期不同的Bean对象作用范围，生命周期不同。 生命周期方法：在bean标签中 init-method：Bean被初始化时调用 destory-method：Bean被销毁时调用 scope=”singleton”：单例对象 在整个应用中只会存在一个对象 生命周期 对象初始化：当Spring 容器加载的时候，对象就开始初始化（前提是该对象为立即加载） 对象存活：只要容器在，那么对象就会存活 对象死亡：当容器死亡那么对象就死亡 scope=”prototype”：多例对象 每次get都会创建新的对象 生命周期 对象初始化：当调用了getBean的方法的时候开始完成对象的初始化 对象存活：只要对象任然在使用中，那么对象就一直存活 对象死亡：当对象没有被使用，等待GC回收，然后释放所占用的内存（需要注意，由于Spring不知道对象什么时候死亡，所以destroy-method 的方法是无法执行的） 2.3.5. DI（依赖注入）是个什么玩意？2.3.5.1. DI自述DI ：Dependency injection 也称为依赖注入，它是Spring框架IOC的具体实现 DI在Spring中的作用是，当容器运行时，能够将对象依赖的数据注入到对象中，比如通过构造方法注入属性，SET方法注入属性。 2.3.5.2.为什么叫依赖注入呢？例子：就像是 service层 需要依赖dao层 ，在交给Spring容器管理的时候， 就需要在service层中说明依赖了那个dao层接口，这样service层就可以使用dao层方法了。 好处：通过将对象注入到对象，维护了类之间依赖关系。这种方式相比于传统模式下更加好，因为减少了硬编码，不需要在代码中写出具体的实现类是什么，而是通过在Bean工厂中获取到对应的实现类，这种方式减少耦合度，增加了系统的可扩展性。 传统模式下的实现方式 DI方式下的实现方式 2.3.5.3. 构造函数注入解释：在实例化Bean对象的时候，容器读取配置文件，通过构造函数去实例化对象。 好处：强制要求Bean对象在初始化一定要传递什么值。 坏处：不够灵活，如果有些值不必要传递那么就需要强硬的传值。 参数说明 constructor-arg：阐述构造函数参数的信息 name：表示参数的名称 value：插入基本数据类型和String类型 ref：插入对象类型数据（该对象类型数据必须交由Spring管理才能注入） 1234567&lt;bean id=\"Student\" class=\"com.accompany.spring.demo1.bean.Student\"&gt; &lt;constructor-arg name=\"name\" value=\"张三\"/&gt; &lt;constructor-arg name=\"age\" value=\"15\"/&gt; &lt;constructor-arg name=\"birthday\" ref=\"date\"/&gt;&lt;/bean&gt;&lt;bean id=\"date\" class=\"java.util.Date\"&gt;&lt;/bean&gt; 2.3.5.4. Set 方法注入解释：通过给属性设置set方法，容器底层调用set方法将配置文件中对应属性的值注入到对象中。（属性值必须具有Set方法才能使用） 好处：能够很灵活的给Bean对象注入属性值 坏处：有些属性必须赋值缺做不到，所以需要通过构造函数注入加上Set注入完成最佳化 参数说明 property：阐述构造函数参数的信息 name：set方法名，去掉set， 第一个字母小写 value：插入基本数据类型和String类型 ref：插入对象类型数据（该对象类型数据必须交由Spring管理才能注入） 12345&lt;bean id=\"student1\" class=\"com.accompany.spring.demo1.bean.Student\"&gt; &lt;property name=\"age\" value=\"200\" /&gt; &lt;property name=\"name\" value=\"请勿打扰\" /&gt; &lt;property name=\"birthday\" ref=\"date\"/&gt;&lt;/bean&gt; 2.3.5.5. p标签注入解释：这种方式底层还是使用set方法注入，需要在引入约束头中加入p空间约束才能使用 好处：更加简单使用set方法注入属性 坏处：需要在约束头中加入p空间约束才能使用 步骤： 1.现在约束中加入p空间约束(在第二行) 1234&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; 2.在bean标签中使用P空间 格式： 调用set方法名：set方法名，去掉set， 第一个字母小写 基础数据类型/String数据类型：p: 调用set方法名= “属性值” 对象数据类型：p: 调用set方法名-ref = “属性值” 123&lt;bean id=\"student2\" class=\"com.accompany.spring.demo1.bean.Student\" p:age=\"250\" p:name=\"我真帅\" p:birthday-ref=\"date\"&gt;&lt;/bean&gt; 2.3.5.6.注入集合属性数据Spring的DI可以给对象注入 数组，List，Set, Map, Properties的数据,同时也存在着一定的规律 规律： 数组,List,Set是同类型的数据结构，在声明数据结构的时候可以混用 Map,properties是同类型的数据结构，在声明数据结构的时候可以混用 给对象注入数组类型（array | list | set）推荐使用 &lt;list&gt; &lt;value&gt;20&lt;/value&gt; &lt;/list&gt; 1234567891011121314151617181920212223&lt;bean id=\"student3\" class=\"com.accompany.spring.demo1.bean.Student\"&gt; &lt;property name=\"arr\"&gt; &lt;array&gt; &lt;value&gt;5&lt;/value&gt; &lt;value&gt;10&lt;/value&gt; &lt;value&gt;15&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;20&lt;/value&gt; &lt;value&gt;25&lt;/value&gt; &lt;value&gt;30&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"set\"&gt; &lt;list&gt; &lt;value&gt;100&lt;/value&gt; &lt;value&gt;200&lt;/value&gt; &lt;value&gt;300&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 键值对类型 （map | properties） 推荐使用&lt;map&gt; &lt;entry key=&quot;aa&quot; value=&quot;AA&quot;/&gt; &lt;/map&gt; 123456789101112131415&lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"aa\" value=\"AA\"/&gt; &lt;entry key=\"bb\" value=\"BB\"/&gt; &lt;entry key=\"cc\"&gt; &lt;value&gt;CC&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt;&lt;/property&gt;&lt;property name=\"properties\"&gt; &lt;props&gt; &lt;prop key=\"qq\" &gt;QQ&lt;/prop&gt; &lt;prop key=\"ww\" &gt;WW&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt; 2.4. IOC注解部分2.4.1. 在Spring如何开启注解？i.在Spring中，由于注解都是在类上的，又没有告知spring，所以可以知道，要开启注解需要告知spring 在哪里扫描类上的注解。 ii.在告知spring的时候 需要在命名空间加上有关于context 的约束 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package=\"com.accompany.spring.demo1\" /&gt;&lt;/beans&gt; 2.4.2. IOC注解在Spring中的分类2.4.2.1.用于创建对象 这类型标签相当于在XML文件中加入了&lt;bean&gt;标签 注解：作用在具体的的实现类上 @Component：声明将该类交由spring管理 @Service：声明该类为服务层对象，同时交由spring管理 @Repository：声明该类为数据持久层对象，同时交由spring管理 @Controller：声明该类为控制层对象，同时交由spring管理 从源码的角度上分析，对于上面四种注解，@Service、@Repository、@Controller 都是由@Component衍生出来的。无论是@Service、@Repository、@Controller，在注解类上都会存在@Component注解，同时在属性上，也指向了Component的value 123456789101112131415@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Repository &#123; /** * The value may indicate a suggestion for a logical component name, * to be turned into a Spring bean in case of an autodetected component. * @return the suggested component name, if any (or empty String otherwise) */ @AliasFor(annotation = Component.class) String value() default \"\";&#125; 2.4.2.2.用于数据注入 相当于在XML配置文件的&lt;bean&gt;标签中的&lt;property&gt;标签一致。 缺点：无法给对象注入数组/集合类型数据 问题？：为什么使用XML配置Bean需要给属性设置set/get方法才能注入，而使用注解配置Bean不需要设置set/get方法就能注入？ 分析原因：是否走了set方法？ 给属性加入set方法进行标记，然后通过注解注入，最后发现并没有走自定义的set方法，说明了并不是使用set方法对属性值进行注入 网上查询：读取类文件，通过反射暴力访问私有属性并且对其赋值，大致方法如下 1234567891011121314//1.获取class对象 （有三种方法） //i.通过类名称获取 类名.class; //ii.通过对象获取 对象名.getClass() //iii.通过类的全路径获取 Class.forName(\"classPath\") Class&lt;StudentServiceImpl2&gt; c = StudentServiceImpl2.class; //2.通过反射实例化对象 StudentServiceImpl2 rs = c.newInstance(); //3.类的属性字段 Field field = c.getDeclaredField(\"s1\"); //4.设置属性字段允许暴力访问 field.setAccessible(true); //5.设置字段值 field.set(rs,\"yyx你真帅\"); rs.print(); 注解：作用在属性上 注入对象数据类型 @Autowired：从IOC容器中找到类型唯一且一致的对象注入。需要注意，当IOC存在多个类型一致的对象，那么在注入的时候，会先找到一批类型一致的对象，在找到属性名称与存储在IOC容器属性名称一致的对象注入。 图解 @Qualifier：与@Autowired配合使用，通过@Qualifier(value=”bean Name”)指定在IOC容器中对应Bean的KEY值，解决了找不到唯一对象注入的问题 @Resource(name=”bean Name”)：在IOC容器中找到同数据类型相同且名称等于bean Name的对象注入 注入基础数据类型/String数据类型 @Value(value=”xx “)：将xx的值直接注入到属性上 2.4.2.3.用于改变作用范围 相当于在XML配置文件的&lt;bean&gt;标签中加入了Scope=&quot;singleton/prototype...&quot; 注解：作用在类上 @Scope(“singleton/prototype…”) 2.4.2.4.和生命周期相关 相当于在XML配置文件的&lt;bean&gt;标签中加入了init-method=&quot;&quot; destroy-method=&quot;&quot; 注解：作用在方法上 @PostConstruct：类加载时运行（单例模式执行一次，多例模式获取一次执行一次） @PreDestroy：类销毁时运行（单例：容器关闭执行，多例不执行） 2.4.3. 配置信息类注解2.4.3.1.配置信息类有什么用？2.4.3.2.用于声明该类为配置类 相当于XML配置文件本身 使用说明：跟XML配置差不多，在启动的时候使用ApplicationContext context = new AnnotationConfigApplicationContext(xxx.class...)需要告知主配置类的位置。当使用new 然后传递配置类的时候，可以不用在类上标记注解。同时也可以认为这个类是主配置类。 注解：作用在类上 @Configuration：在某些情况下可以不加此注解 @Import(xxx.class...)在配置类上导入其他配置类，一般放在主配置类上，导入其他配置类（被导入的配置类可以不用加入@Configuration注解） 2.4.3.3.包扫描 相当于在XML配置文件中加入了&lt;context:component-scan base-package=&quot;xx&quot; /&gt; 注解： @ComponentScan(&quot;pakeage Path&quot;)：配置单个扫描包 @ComponentScan({&quot;xx&quot;,&quot;yy&quot;})：配置多个扫描包 注解源码：可以看出 value 和 basePackages 相互指向，所以在传参时，用那个都行。 123456789101112131415161718/** * Alias for &#123;@link #basePackages&#125;. * &lt;p&gt;Allows for more concise annotation declarations if no other attributes * are needed &amp;mdash; for example, &#123;@code @ComponentScan(\"org.my.pkg\")&#125; * instead of &#123;@code @ComponentScan(basePackages = \"org.my.pkg\")&#125;. */ @AliasFor(\"basePackages\") String[] value() default &#123;&#125;; /** * Base packages to scan for annotated components. * &lt;p&gt;&#123;@link #value&#125; is an alias for (and mutually exclusive with) this * attribute. * &lt;p&gt;Use &#123;@link #basePackageClasses&#125; for a type-safe alternative to * String-based package names. */ @AliasFor(\"value\") String[] basePackages() default &#123;&#125;; 2.4.3.4.用于将方法返回的对象放进容器 相当于在XML加入了&lt;bean&gt;标签，不过和@Component不同的是，@Bean作用在方法上而@Component作用在类上 问题： 1.如果返回值不是对象，而是基本数据类型，那么是会报错还是会发生什么？ 根据测试得知，是不会报错，而是会将基本数据类型存进容器，id为方法名（觉得自己很蠢，万物皆对象啊！！！！） 2.如果方法中有参数，如何给参数传递值？ 当Spring读取到被@Bean控制方法时，参数注入形式是与@Autowired一致，所以根据这个可知，可以与@Qualifier一同使用达到根据id获取到具体Bean对象。 注解：可以与@Scope注解配合使用，控制作用范围 @Bean(name=&quot;id&quot;)：name=”id” 属性值 可加可不加，当不加入的时候，id为方法名。 2.4.3.5.用于读取配置文件 相当于再XML加入了&lt;context:property-placeholder location=``&quot;classpath:conf/*.properties&quot; `file-encoding=&quot;UTF-8&quot;/&gt; 注意：无法读取yml文件 注解：classpath是定义在注解里面特殊字符，表示在类路径找文件，默认采用的是UTF-8解码 @PropertyScource(&quot;classpath:xxx&quot;) 3.4.4.问题 配置注解类就取代掉配置文件，那么配置文件还有存在的意义吗？ 全注解开发： 好处：不用写XML配置文件，更简单的配置Bean对象，完成注入等一系列问题。 坏处：由于注解都是写在类上，当类的数量多了起来，那么在后期维护的时候找起来也是一个问题。 纯XML配置开发： 好处：在XML配置文件中配置可以很广泛的知道在系统中配置了多个Bean，以及注入信息是什么，作用范围是什么。 坏处：XML配置是繁琐的，厚重的。 半注解半配置开发： 好处：在一定程度上结合了全注解开发以及纯XML配置开发的好处。 什么时候用？：当开发自定义类的时候可以使用注解开发，当配置其他框架的类的时候可以使用XML配置模式开发。 3.有关于整合 Junit3.1.分析问题在测试类中，如果是spring项目测试，就永远离不开IOC容器，但是Junit是不知道是否使用spring，以及配置文件在何处（或主配置类）在何处。 所以也就离不开两句话，同时也不支持注入到测试类中。 1234//读取XML配置或去读配置类ApplicationContext context = new AnnotationConfigApplicationContext(ApplicationConfig.class);//获取对应的对象Object a = context.getBean(\"a\"); 3.2.解决问题思路需要让Junit在启动的时候就运行Spring，这样就可以完成在测试中加入注入属性，而不是通过context去获取，但是如何去做？就需要做到替换Junit的启动器Runner成spring自定义的启动器。 3.3.代码实现 1.导入有关于测试对应的坐标 12345678910111213&lt;!-- spring与junit整合包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--junit --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 2.在测试类上加入注解 @Runwith(SpringJUnit4ClassRunner.class)：表示使用Spring-Test提供的Runner启动器 @ContextConfiguration()：表示配置文件位置或者配置类的位置 属性值： value=&quot;classpath: &quot;：表示使用XML配置文件，同时在类路径下查找文件 classes=&quot;xxx.class...&quot;：表示使用注解类 123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = ApplicationConfig.class)public class myTest &#123; @Autowired private int a; @Test public void method1()&#123; System.out.println(\"a:\"+a); &#125;&#125;","categories":[{"name":"后端框架","slug":"后端框架","permalink":"https://aaccompany.github.io/categories/后端框架/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://aaccompany.github.io/tags/spring/"},{"name":"重走系列","slug":"重走系列","permalink":"https://aaccompany.github.io/tags/重走系列/"}]},{"title":"Active消息中间件","slug":"Active消息中间件","date":"2019-07-02T02:13:52.000Z","updated":"2019-07-10T05:08:29.951Z","comments":true,"path":"2019/07/02/Active消息中间件/","link":"","permalink":"https://aaccompany.github.io/2019/07/02/Active消息中间件/","excerpt":"","text":"消息中间件当没有采用消息中间件的系统模块图,当运营商后台去调用搜索服务和页面生成服务的时候，不需要知道他们返回的结果，所以在这里为了提高效率、降低系统耦合度可以采用消息中间件的解决方案。 当采用了消息中间件之后的系统模块图，中间去除了dubbo和减少了对搜索服务和页面生成服务的依赖，降低了系统耦合度 1.什么是消息中间件消息中间件利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。对于消息中间件，常见的角色大致也就有Producer（生产者）、Consumer（消费者） 1.1常见的消息中间件产品 JMS:JAVA MESSAGE SERVICE （1）ActiveMQ ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。 （2）RabbitMQ AMQP协议的领导实现，支持多种场景。淘宝的MySQL集群内部有使用它进行通讯，OpenStack开源云平台的通信组件，最先在金融行业得到运用。 （3）ZeroMQ 史上最快的消息队列系统 （4）Kafka Apache下的一个子项目 。特点：高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统。适合处理海量数据。 1.1.什么是JMSJMS（Java Messaging Service）是Java平台上有关面向消息中间件的技术规范，它便于消息系统中的Java应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发。 ​ JMS本身只定义了一系列的接口规范，是一种与厂商无关的 API，用来访问消息收发系统。它类似于 JDBC(java Database Connectivity)：这里，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。许多厂商目前都支持 JMS，包括 IBM 的 MQSeries、BEA的 Weblogic JMS service和 Progress 的 SonicMQ，这只是几个例子。 JMS 使您能够通过消息收发服务（有时称为消息中介程序或路由器）从一个 JMS 客户机向另一个 JML 客户机发送消息。消息是 JMS 中的一种类型对象，由两部分组成：报头和消息主体。报头由路由信息以及有关该消息的元数据组成。消息主体则携带着应用程序的数据或有效负载。 JMS 定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一 些不同形式的数据，提供现有消息格式的一些级别的兼容性。 · TextMessage–一个字符串对象 · MapMessage–一套名称-值对 · ObjectMessage–一个序列化的 Java 对象 · BytesMessage–一个字节的数据流 · StreamMessage – Java 原始值的数据流 1.2.JMS消息传递在消息传递存在两种类型： 1.2.1.点对点一个生产者会对应一个消费者，一个生成者发布的消息会存放在队列中，然后消费者不一定需要及时将队列的数据取出，而是可以不定时的去获取数据。当数据被取出的时候队列中的消息就会减少一条。 当存在多个消费者监听的队列是同一个的时候，谁先监听消息队列谁就先获取到数据。 1.2.2.发布/订阅一个生产者会对应多个消费者，当一个生产者发布了一条信息，会将数据存放在topic中，然后即时发生给每个在线的消费者，类似与广播的特性。 当有一个消费者没有上线的时候，会接受不到广播。 2.ActiveMQ安装（Linux）（1）将apache-activemq-5.12.0-bin.tar.gz 上传至服务器 （2）解压此文件 tar zxvf apache-activemq-5.12.0-bin.tar.gz （3）为apache-activemq-5.12.0目录赋权 chmod 777 apache-activemq-5.12.0 （4）进入apache-activemq-5.12.0\\bin目录 （5）赋与执行权限 12345678910111213141516 chmod 755 activemq -------------------------- **知识点小贴士**------------------------ linux 命令chmod 755的意思 chmod是 Linux 下设置文件权限的命令，后面的数字表示不同用户或用户组的权限。 一般是三个数字： 第一个数字表示文件所有者的权限 第二个数字表示与文件所有者同属一个用户组的其他用户的权限 第三个数字表示其它用户组的权限。 权限分为三种：读（r=4），写（w=2），执行（x=1） 。 综合起来还有可读可执行（rx=5=4+1）、可读可写（rw=6=4+2）、可读可写可执行(rwx=7=4+2+1)。 所以，chmod 755 设置用户的权限为： 1.文件所有者可读可写可执行 --7 2.与文件所有者同属一个用户组的其他用户可读可执行 --5 3.其它用户组可读可执行 --5 1.3.3启动​ ./activemq start 出现下列提示表示成功！ 假设服务器地址为192.168.25.135 ，打开浏览器输入地址 http://192.168.25.135:8161/ 即可进入ActiveMQ管理页面 点击进入管理页面 输入用户名和密码 均为 admin 进入主界面 点对点消息列表： 列表各列信息含义如下： Number Of Pending Messages ：等待消费的消息 这个是当前未出队列的数量。 Number Of Consumers ：消费者 这个是消费者端的消费者数量 Messages Enqueued ：进入队列的消息 进入队列的总数量,包括出队列的。 Messages Dequeued ：出了队列的消息 可以理解为是消费这消费掉的数量。 3.JMS入门小Demo3.1点对点Demo点对点的模式主要建立在一个队列上面，当连接一个列队的时候，发送端不需要知道接收端是否正在接收，可以直接向ActiveMQ发送消息，发送的消息，将会先进入队列中，如果有接收端在监听，则会发向接收端，如果没有接收端接收，则会保存在ActiveMQ服务器，直到接收端接收消息，点对点的消息模式可以有多个发送端，多个接收端，但是一条消息，只会被一个接收端给接收到，哪个接收端先连上ActiveMQ，则会先接收到，而后来的接收端则接收不到那条消息。 3.1.1添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-client&lt;/artifactId&gt; &lt;version&gt;5.13.4&lt;/version&gt; &lt;/dependency&gt; 3.1.2生产者代码注意： 1)在地址中传输协议为tcp 2）在第四步骤中的参数说明 第一个参数：是否开启事务 第二个参数消息的确定模式 AUTO_ACKNOWLEDGE = 1 自动确认 CLIENT_ACKNOWLEDGE = 2 客户端手动确认 DUPS_OK_ACKNOWLEDGE = 3 自动批量确认 SESSION_TRANSACTED = 0 事务提交并确认 12345678910111213141516171819202122232425public static void main(String[] args) throws Exception &#123; //1.创建连接工厂 //说明：使用想对应的是厂商的连接工厂 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://120.76.56.183:61616\"); //2.创建连接 Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.获取session //参数说明：1.是否启用事务2.消息确认模式 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建消息队列 //参数说明：队列的名称 Queue queue = session.createQueue(\"test-queue\"); //6.创建生产者 参数说明：生产者使用那个消息对象 MessageProducer producer = session.createProducer(queue); //7.创建消息 TextMessage message = session.createTextMessage(\"你真是个大傻吊\"); //8.发生消息 producer.send(message); //9.关闭资源 producer.close(); session.close(); connection.close(); &#125; 3.1.3消费者代码注意：需要创建匿名内部类 Message Listener 1234567891011121314151617181920212223242526272829303132public static void main(String[] args) throws Exception &#123; //1.创建连接工厂 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://120.76.56.183:61616\"); //2.创建连接 Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.获取session Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.监听对应的消息队列 Queue queue = session.createQueue(\"test-queue\"); //6.由会话，创建消息消费者 MessageConsumer consumer = session.createConsumer(queue); //7.监听消息 consumer.setMessageListener(new MessageListener() &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage)message; try &#123; System.out.println(\"监听到的消息\"+textMessage.getText()); &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;); //8.持续监听 System.in.read(); //9.释放资源 consumer.close(); session.close(); connection.close(); &#125; 3.2发布/订阅Demo3.2.1添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-client&lt;/artifactId&gt; &lt;version&gt;5.13.4&lt;/version&gt; &lt;/dependency&gt; 3.2.2生产者代码12345678910111213141516171819202122public static void main(String[] args) throws Exception &#123; //1.创建连接工厂 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://120.76.56.183:61616\"); //2.获取连接 Connection connection = connectionFactory.createConnection(); //3.开启连接 connection.start(); //4.获取session Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建topic Topic topic = session.createTopic(\"test-topic\"); //6.创建消息生产者 MessageProducer producer = session.createProducer(topic); //7.创建消息 由session去创建消息 TextMessage message = session.createTextMessage(\"啊啊啊啊，你可以简单点么\"); //8.发送消息 producer.send(message); //9.释放资源 producer.close(); session.close(); connection.close(); &#125; 3.2.3消费者代码1234567891011121314151617181920212223242526272829303132public static void main(String[] args) throws Exception &#123; //1.创建工厂 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://120.76.56.183:61616\"); //2.创建连接 Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.获取session Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.获取Topic Topic topic = session.createTopic(\"test-topic\"); //6.获取topic消费者 MessageConsumer consumer = session.createConsumer(topic); //7.设置监听 consumer.setMessageListener(new MessageListener() &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; System.out.println(\"topic监听到了\"+textMessage.getText()); &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;); //8.持久监听 System.in.read(); //9.关闭资源 consumer.close(); session.close(); connection.close(); &#125; 4.Spring整合ActiveMQ4.1点对点Demo4.1.1生产者代码123456789101112131415161718//JMS模板 负责发送消息 接受消息 @Autowired private JmsTemplate jmsTemplate ; //消息的目的地 @Autowired private Destination queueTextDestination; /** * 生成者发生信息 */ public void sendTextMessage(final String text) &#123; jmsTemplate.send(queueTextDestination, new MessageCreator() &#123; public Message createMessage(Session session) throws JMSException &#123; return session.createTextMessage(text); &#125; &#125;); &#125; 4.1.2配置文件1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:amq=\"http://activemq.apache.org/schema/core\" xmlns:jms=\"http://www.springframework.org/schema/jms\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"com.yuanxiong.producer\"&gt;&lt;/context:component-scan&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id=\"targetConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"&gt; &lt;property name=\"brokerURL\" value=\"tcp://120.76.56.183:61616\"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.SingleConnectionFactory\"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name=\"targetConnectionFactory\" ref=\"targetConnectionFactory\"/&gt; &lt;/bean&gt; &lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt; &lt;bean id=\"jmsTemplate\" class=\"org.springframework.jms.core.JmsTemplate\"&gt; &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 文本信息--&gt; &lt;bean id=\"queueTextDestination\" class=\"org.apache.activemq.command.ActiveMQQueue\"&gt; &lt;!-- 消息队列的值 --&gt; &lt;constructor-arg value=\"queue_text\"/&gt; &lt;/bean&gt; &lt;!--这个是订阅模式 文本信息 &lt;bean id=\"topicTextDestination\" class=\"org.apache.activemq.command.ActiveMQTopic\"&gt; &lt;constructor-arg value=\"topic_text\"/&gt; &lt;/bean&gt; --&gt; &lt;/beans&gt; 4.1.3消费者代码1234567891011121314151617181920212223package com.yuanxiong.consumer;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;import org.springframework.stereotype.Component;@Componentpublic class myMessageListener implements MessageListener &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; System.out.println(\"queue监听到了\"+textMessage.getText()); &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 4.1.4配置文件123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:amq=\"http://activemq.apache.org/schema/core\" xmlns:jms=\"http://www.springframework.org/schema/jms\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id=\"targetConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"&gt; &lt;property name=\"brokerURL\" value=\"tcp://120.76.56.183:61616\"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.SingleConnectionFactory\"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name=\"targetConnectionFactory\" ref=\"targetConnectionFactory\"/&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 文本信息--&gt; &lt;bean id=\"queueTextDestination\" class=\"org.apache.activemq.command.ActiveMQQueue\"&gt; &lt;constructor-arg value=\"queue_text\"/&gt; &lt;/bean&gt; &lt;!-- 我的监听类 --&gt; &lt;context:component-scan base-package=\"com.yuanxiong.consumer\"&gt;&lt;/context:component-scan&gt; &lt;!-- 消息监听容器 --&gt; &lt;bean class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\" /&gt; &lt;property name=\"destination\" ref=\"queueTextDestination\" /&gt; &lt;!-- 我的监听类 --&gt; &lt;property name=\"messageListener\" ref=\"myMessageListener\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 4.2发布订阅Demo4.2.1生产者代码123456789101112131415161718192021222324252627282930package com.yuanxiong.producer;import javax.jms.Destination;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.Session;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jms.core.JmsTemplate;import org.springframework.jms.core.MessageCreator;import org.springframework.stereotype.Component;@Componentpublic class TopicProducer &#123; @Autowired private JmsTemplate jmsTemplate; @Autowired private Destination topicTextDestination; public void sendTextMessage(final String string) &#123; jmsTemplate.send(topicTextDestination, new MessageCreator() &#123; public Message createMessage(Session session) throws JMSException &#123; return session.createTextMessage(string); &#125; &#125;); &#125;&#125; 4.2.2配置文件1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:amq=\"http://activemq.apache.org/schema/core\" xmlns:jms=\"http://www.springframework.org/schema/jms\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"com.yuanxiong.producer\"&gt;&lt;/context:component-scan&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id=\"targetConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"&gt; &lt;property name=\"brokerURL\" value=\"tcp://120.76.56.183:61616\"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.SingleConnectionFactory\"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name=\"targetConnectionFactory\" ref=\"targetConnectionFactory\"/&gt; &lt;/bean&gt; &lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt; &lt;bean id=\"jmsTemplate\" class=\"org.springframework.jms.core.JmsTemplate\"&gt; &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt; &lt;/bean&gt; &lt;!--这个是订阅模式 文本信息 --&gt; &lt;bean id=\"topicTextDestination\" class=\"org.apache.activemq.command.ActiveMQTopic\"&gt; &lt;constructor-arg value=\"topic_text\"/&gt; &lt;/bean&gt; &lt;/beans&gt; 4.2.3消费者代码1234567891011121314151617181920212223package com.yuanxiong.consumer;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;import org.springframework.stereotype.Component;@Componentpublic class myTopicMessageListener implements MessageListener &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage)message; try &#123; System.out.println(\"topic\"+textMessage.getText()); &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 4.2.4配置文件 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:amq=\"http://activemq.apache.org/schema/core\" xmlns:jms=\"http://www.springframework.org/schema/jms\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id=\"targetConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"&gt; &lt;property name=\"brokerURL\" value=\"tcp://120.76.56.183:61616\"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.SingleConnectionFactory\"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name=\"targetConnectionFactory\" ref=\"targetConnectionFactory\"/&gt; &lt;/bean&gt; &lt;!--这个是topic目的地，点对点的 文本信息--&gt; &lt;bean id=\"topicTextDestination\" class=\"org.apache.activemq.command.ActiveMQTopic\"&gt; &lt;constructor-arg value=\"topic_text\"/&gt; &lt;/bean&gt; &lt;!-- 消息监听容器 --&gt; &lt;bean class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\" /&gt; &lt;property name=\"destination\" ref=\"topicTextDestination\" /&gt; &lt;property name=\"messageListener\" ref=\"myTopicMessageListener\" /&gt; &lt;/bean&gt;&lt;/beans&gt;","categories":[{"name":"MQ","slug":"MQ","permalink":"https://aaccompany.github.io/categories/MQ/"}],"tags":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://aaccompany.github.io/tags/消息中间件/"}]},{"title":"MQ知其然而不知其所然","slug":"MQ知其然而不知其所然","date":"2019-07-02T02:13:52.000Z","updated":"2019-07-10T05:10:42.935Z","comments":true,"path":"2019/07/02/MQ知其然而不知其所然/","link":"","permalink":"https://aaccompany.github.io/2019/07/02/MQ知其然而不知其所然/","excerpt":"","text":"MQ知其然而不知其所然1.什么是MQ？MQ：通俗的理解为消息队列。在分布式系统中，一个系统可以将一份数据存放在一个中间件上，然后其他系统需要这份数据的话，就可以从中间件上将这份数据取出。 那么问题来了，为什么需要使用MQ？ 可以使用MQ做到系统的解耦、异步、削峰。 2.MQ的优点2.1.解耦业务：A系统需要发送数据到BCD系统中，在BCD系统中进行操作 2.1.1.在不使用MQ下的系统耦合 坏处： 1.从图中可以知道，当A系统需要完成一个操作，需要BCD协同完成。当整个工程新增系统或者有系统不需要A传递的数据的话，那么就需要修改两方的数据。 2.因为A系统需要完成一个操作，需要依赖于BCD系统，那么如果其中一个出现了问题，那么整个系统就会出现异常。 3.如果A系统所依赖的系统访问超时该如何处理。 所以在这种模式容易出现许多问题，如何解决这些问题呢？ 2.1.2.系统使用MQ解耦 在使用了MQ情况下，A系统可以将需要传递数据发送到MQ中，这时候，A所依赖的系统（BCD）就可以从MQ中获取数据完成操作。这样的话就不需要考虑上面所提及的坏处。 2.2.异步2.2.1.在不使用MQ下系统是保持同步状态如果系统采用是的同步设计，那么会给系统造成高延迟的现象 由图中可以得到如果需要完成一个功能总共耗时为200 ms 2.2.2.在使用MQ下系统可以修改为异步状态如果将系统修改为异步状态，那么系统就可以大大减少系统延迟现象。 在使用了MQ的情况下，完成一个功能返回给用户的时间差只存在 50 ms + 5 ms = 55 ms。这样从同步系统到异步系统的时间比值为 40：11 接近省去了4倍的时间（在假设的情况下）。 在互联网企业上一个请求的响应时间应该在200 ms之内，这样用户就很难感知。 2.3.削峰2.3.1.没有削峰的系统 2.3.2.使用了MQ对系统进行削峰 3.引入MQ出现的问题？ 虽然系统中引入了MQ组件，做到了系统的异步、削峰、解耦，但是因为系统中加入了MQ导致了系统出现了下面几种问题。 3.1.系统的可用性降低引入了MQ，系统的消息转递需要依赖于MQ，但是当MQ宕机的话那么整个系统也会随之宕机。 3.2.系统的复杂度提高引入了MQ会导致系统的架构变得复杂。同时也需要考虑会出现的问题。 1）是否会往MQ中重复发送消息？ 2）发送给MQ的消息是否会丢失？ 3）发送给MQ的消息如果具有顺序，如何保证消息的顺序？ 3.3.系统一致性问题当系统A发送消息给BCD的话，ABC都执行完并且无异常，但是D出现异常。那么A会告知用户执行完毕，这种情况该如何解决。 如果做MQ的选型？1.社区活跃度 2.单机吞吐量 3.时效性 一般在中小型公司采用RabbitMQ（消息处理能力万级，但是语言采用的是erlang专门处理分布式的语言设计所有处理速度快），中大型公司有专门技术人员可以采用RockerMQ（消息处理能力十万级）。大数据采用kafka（消息处理能力十万级）。 一般现在不采用ActiveMQ（消息处理能力万级）作为MQ，因为社区活跃度开始下降。","categories":[{"name":"MQ","slug":"MQ","permalink":"https://aaccompany.github.io/categories/MQ/"}],"tags":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://aaccompany.github.io/tags/消息中间件/"}]},{"title":"RabbitMQ消息中间件","slug":"RabbitMQ消息中间件","date":"2019-07-02T02:13:52.000Z","updated":"2019-07-10T05:13:46.284Z","comments":true,"path":"2019/07/02/RabbitMQ消息中间件/","link":"","permalink":"https://aaccompany.github.io/2019/07/02/RabbitMQ消息中间件/","excerpt":"","text":"RabbitMQ消息中间件1.RabbitMQ简介1.1.消息队列简介消息中间件是分布式系统中的重要组件，主要解决了应用耦合，异步消息，流量削锋等问题，实现系统高性能，高可用，可伸缩性喝最终一致性【架构】使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka,MetaMQ,RocketMQ 1.2.什么是RabbitMQRabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。AMQP ：Advanced Message Queue Protocol，高级消息队列协议。它是应用层协议的一个开放 标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。RabbitMQ 初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括： 1.可靠性（Reliability）RabbitMQ 使用一些机制来保证可靠性，如持久化（当服务器挂掉的时候会不会丢失信息，而是会保存信息到硬盘）、传输确认、发布确认。 2.灵活的路由（Flexible Routing）在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。 3.消息集群（Clustering）多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。 4.高可用（Highly Available Queues）队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。 5.多种协议（Multi-protocol）RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。 6.多语言客户端（Many Clients） RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。 7.管理界面（Management UI）RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方 面。 8.跟踪机制（Tracing）如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。 9.插件机制（Plugin System）RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。 1.3.架构图与主要概念1.3.1.架构图 1.2.2.主要概念RabbitMQ Server： 也叫broker server，它是一种传输服务。 他的角色就是维护一条 从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。 Producer： 消息生产者，如图A、B、C，数据的发送方。消息生产者连接RabbitMQ服 务器然后将消息投递到Exchange。 Consumer：消息消费者，如图1、2、3，数据的接收方。消息消费者订阅队列， RabbitMQ将Queue中的消息发送到消息消费者。 Exchange：生产者将消息发送到Exchange（交换器），由Exchange将消息路由到一个 或多个Queue中（或者丢弃）。 Exchange并不存储消息。RabbitMQ中的Exchange有 direct、fanout、topic、headers四种类型，每种类型对应不同的路由规则。 Queue：（队列）是RabbitMQ的内部对象，用于存储消息。消息消费者就是通过订阅队列来获取消息的，RabbitMQ中的消息都只能存储在Queue中，生产者生产消息并终投递到Queue中，消费者可以从Queue中获取消息并消费。多个消费者可以订阅同一个 Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者 都收到所有的消息并处理。 RoutingKey：生产者在将消息发送给Exchange的时候，一般会指定一个routing key， 来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联 合使用才能终生效。在Exchange Type与binding key固定的情况下（在正常使用时一 般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过 指定routing key来决定消息流向哪里。RabbitMQ为routing key设定的长度限制为255 bytes。 Connection： （连接）：Producer和Consumer都是通过TCP连接到RabbitMQ Server 的。以后我们可以看到，程序的起始处就是建立这个TCP连接。 Channels： （信道）：它建立在上述的TCP连接中。数据流动都是在Channel中进行 的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。 VirtualHost：权限控制的基本单位，一个VirtualHost里面有若干Exchange和 MessageQueue，以及指定被哪些user使用 2.走进RabbitMQ2.1.RabbitMQ安装（1）下载并安装 Eralng配套软件中已提供otp_win64_20.2.exe （以管理员身份运行安装） （2）下载并安装rabbitmq配套软件中已提供rabbitmq-server-3.7.4.exe。双击安装，注意不要安装在包含中文和 空格的目录下！安装后window服务中就存在rabbitMQ了，并且是启动状态。 （3）安装管理界面（插件）进入rabbitMQ安装目录的sbin目录，输入命令rabbitmq‐plugins enable rabbitmq_management （4）重新启动服务 （5）打开浏览器，地址栏输入http://127.0.0.1:15672 ,即可看到管理界面的登陆页 输入用户名和密码，都为guest 进入主界面： 上侧的导航以此是：概览、连接、信道、交换器、队列、用户管理 2.2.Docker环境下安装1.下载镜像 1docker pull rabbitmq:management 2.创建RabbitMQ容器 1docker run -di --name=tensqura_rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 15671:15671 -p 15672:15672 -p 25672:25672 rabbitmq:management 15672 (if management plugin is enabled) 15671 management监听端口 5672, 5671 (AMQP 0-9-1 without and with TLS) 4369 (epmd) epmd 代表 Erlang 端口映射守护进程 25672 (Erlang distribution) 3.登入RabbitMQ管理界面 访问地址：http://192.168.186.129:15672 账号密码均为guest 2.3.直接模式(Direct)2.3.1.什么是直接模式将消息发给唯一一个节点时使用这种模式，这是简单的一种形式。 任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue。1.一般情况可以使用rabbitMQ自带的Exchange：””(该Exchange的名字为空字符串，下文称其为default Exchange)。 2.这种模式下不需要将Exchange进行任何绑定(binding)操作 3.消息传递时需要一个“RouteKey”，可以简单的理解为要发送到的队列名字。 4.如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃。 2.3.2创建队列Name:队列的名称 Durability:是否持久化 Auto Delete:是否自动删除 2.3.3.代码实现- 消息生产者1.引入依赖 1234567891011121314151617181920212223&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐starter‐parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- rabbitMQ起步依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐starter‐amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐starter‐test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.配置文件信息 123spring: rabbitmq: host: 192.168.192.129 3.编写启动类 1234567@SpringBootApplication public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 4.编写测试类 12345678910@RunWith(SpringRunner.class) @SpringBootTest(classes=Application.class) public class MqTest &#123; @Autowired private RabbitTemplate rabbitTemplate; @Test public void testSend()&#123; rabbitTemplate.convertAndSend(\"队列名称\",\"我要红包\"); &#125; &#125; 2.3.4.代码实现-消息消费者12345678@Component @RabbitListener(queues=\"itcast\" ) public class Customer1 &#123; @RabbitHandler public void showMessage(String message)&#123; System.out.println(\"itcast接收到消息：\"+message); &#125; &#125; 2.4.分裂模式（Fanout）2.4.1.什么是分裂模式（Fanout）消息传递个多个队列的时候就可以采用这种模式 任何发送到Exchange的消息都会转发到绑定到该Exchange的队列中。 1.可以理解为路由表的模式 2.这种模式不需要RouteKey 3.这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个 Queue，一个Queue可以同多个Exchange进行绑定。（多对多的关系） 4.如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃。 2.4.2.交换器绑定队列1.创建交换器，类型选择为fanout 2.创建队列 3.交换器绑定队列 选择对应的交换器，点击进去 填写需要绑定的队列名称 2.4.3.代码实现-消息生产者1234@Testpublic void testSendFanout()&#123; rabbitTemplate.convertAndSend(\"chuanzhi\",\"\", \"分列模式走起\");&#125; 2.4.4.代码实现-消息消费者创建一个类去监听对应的队列 123456789@Component @RabbitListener(queues=\"需要监听的队列名称\" )public class Customer2&#123; @RabbitHandler public void showMessage(String message)&#123; System.out.println(\"itheima接收到消息：\"+message); &#125; &#125; 2.5.主题模式（Topic）2.5.1.什么是主题模式任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue 上。可以说是分裂模式一种加强。 在这个模式中出现了匹配规则 routing key：就是一个匹配队列的规则，可以给每个Exchange绑定的队列设置routing key ,当一个消息经过Exchange的时候，如果使用的是主题模式，会匹配routing key，然后分发到对象的队列中。 规则： .* 表示匹配一个点后面任意字符 .# 表示匹配一个点后面任意字符（但是这种允许后面有多个 . 例如 abc.ac.exc 能匹配 abc.# 但是不能匹配 abc.*） 这种模式与前面两种模式差不多，当经过Exchange和routing key的时候，没有可以转发的队列，那么就会丢弃这条消息。 2.5.2.创建队列与绑定1.创建队列，类型选择为topic 2.创建队列 3.绑定队列，并且设置routing key 2.5.3.代码实现-消息生产者12@Test public void testSendTopic1()&#123; rabbitTemplate.convertAndSend(\"topictest\",\"goods.aaa\",\"主题模式\"); &#125; 2.5.4.代码实现-消息消费者123456789@Component @RabbitListener(queues=\"需要监听的队列名称\" )public class Customer2&#123; @RabbitHandler public void showMessage(String message)&#123; System.out.println(\"itheima接收到消息：\"+message); &#125; &#125;","categories":[{"name":"MQ","slug":"MQ","permalink":"https://aaccompany.github.io/categories/MQ/"}],"tags":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://aaccompany.github.io/tags/消息中间件/"}]}]}