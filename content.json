{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"https://aaccompany.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-07-08T05:37:11.090Z","updated":"2019-07-08T05:37:11.090Z","comments":false,"path":"/404.html","permalink":"https://aaccompany.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2019-07-08T15:06:27.997Z","updated":"2019-07-08T15:06:27.997Z","comments":false,"path":"about/index.html","permalink":"https://aaccompany.github.io/about/index.html","excerpt":"","text":"1234567891011121314151617 ┏┓ ┏┓ ┏┛┻━━━┛┻┓ ┃ ┃ ┃ ━ ┃ ┃ ┳┛ ┗┳ ┃ ┃ ┃ ┃ ┻ ┃ ┃ ┃ ┗━┓ ┏━┛ ┃ ┃ ┃ ┃ ┃ ┗━━━┓ ┃ ┣┓ ┃ ┏┛ ┗┓┓┏━┳┓┏┛ ┃┫┫ ┃┫┫ ┗┻┛ ┗┻┛ 固步自封，停滞不前"},{"title":"Repositories","date":"2019-07-08T14:07:26.564Z","updated":"2019-07-08T14:07:26.564Z","comments":false,"path":"repository/index.html","permalink":"https://aaccompany.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-08T05:37:11.099Z","updated":"2019-07-08T05:37:11.099Z","comments":false,"path":"tags/index.html","permalink":"https://aaccompany.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-07-08T05:37:11.095Z","updated":"2019-07-08T05:37:11.095Z","comments":false,"path":"categories/index.html","permalink":"https://aaccompany.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"重走框架系列说明","slug":"重走框架系列说明","date":"2019-07-14T11:47:47.000Z","updated":"2019-07-14T12:02:48.813Z","comments":true,"path":"2019/07/14/重走框架系列说明/","link":"","permalink":"https://aaccompany.github.io/2019/07/14/重走框架系列说明/","excerpt":"","text":"重走框架系列说明自我反思由于思想觉悟出现了问题，总想着快点学习，却没有想到丢了芝麻也丢了西瓜。 自己的基础严重的不牢固，导致前进的十分缓慢。又看了许多大神的教学视频，感觉自己依旧十分的弟弟，所以觉得自己有点揠苗助长，故有了重走框架系列，希望自己能够在这次重新学习后端框架的时候能够不断发现自己的知识盲区，找到自己的不足。 在重走框架的道路上，希望能够借助自己做的项目中，仔细思考在项目中引入新的后端框架会对系统增加严重的BUG，以及对这些BUG如何去做到预防以及解决。 借用《劝学》 故不积跬步，无以至千里，不积小流，无以成江海。 望自己能够一直记住。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://aaccompany.github.io/categories/杂谈/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://aaccompany.github.io/tags/杂谈/"}]},{"title":"重走spring框架 IOC部分","slug":"重走spring框架(IOC部分)","date":"2019-07-14T11:40:50.000Z","updated":"2019-09-15T06:49:05.070Z","comments":true,"path":"2019/07/14/重走spring框架(IOC部分)/","link":"","permalink":"https://aaccompany.github.io/2019/07/14/重走spring框架(IOC部分)/","excerpt":"","text":"Spring框架学习过程中的问题： 为什么在使用JDBC使用的是Class.forName(&quot;DriverName&quot;) 而不是 DriverManager.register(new Driver)？ 工厂模式的好处是什么？ 工厂模式下创建的Bean对象应该为多例还是单例？ 什么时候用多例什么时候用单例？ Spring是如何做到立即加载的？ Spring核心容器下两个顶级接口的区别是什么？（BeanFactory/ApplicationContext） 1.Spring到底是个什么妖魔鬼怪？1.1.Spring的自我介绍？1）Spring是分层的 Java SE/EE应用 full-stack （提供了全栈式的解决方案）轻量级开源框架 2）以 IoC（Inverse Of Control： 反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核 3）提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多 著名的第三方框架和类库 4）Java后端开发的标准 1.2. Spring的发展历程1997 年 IBM提出了EJB 的思想 1998 年，SUN制定开发标准规范 EJB1.0 1999 年，EJB1.1 发布 2001 年，EJB2.0 发布 2003 年，EJB2.1 发布 2006 年，EJB3.0 发布 Rod Johnson（spring之父） Expert One-to-One J2EE Design and Development(2002) 阐述了 J2EE 使用EJB 开发设计的优点及解决方案 Expert One-to-One J2EE Development without EJB(2004) 阐述了 J2EE 开发不使用 EJB的解决方式（Spring 雏形） 2017 年 9 月份发布了 spring 的最新版本 spring 5.0 通用版（GA） 1.3.为什么要使用Spring？1）方便解耦，简化开发 通过Spring提供的IOC（控制反转）容器，让Bean对象放入到Spring容器中，这样对象之间的依赖关系就可以由Spring去处理，避免硬编码造成程序耦合。也不需要注重Bean是设计成单例还是设计成多例的代码。可以花更多时间去注重上层代码 2）AOP支持(面向切面) 通过Spring提供的AOP支持，可以做到传统的OOP很难完成事情。 3）声明式事务的支持 可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理， 提高开发效率和质量。 4）方便程序的测试 可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可 做的事情 5）方便集合各种优秀的框架 可以很快的整合Mybatis、Spring MVC 、Struts等框架。 6）降低了Java EE的API使用难度 在Spring中，对Java EE（如 JDBC、JavaMail、远程调用等）进行了一层封装，能够通过更少的代码去使用这些技术。 7）代码编写的榜样 Spring采用的代码编写的技巧，设计都十分巧妙，结构清晰，注释完整。是十分值得学习的榜样。 1.4.Spring的体系结构在Spring的体系结构中也可以看出Spring是个full-stack型框架，提供了各层的解决方案。 其中重要的是Core Container中的部分，这是使用Spring必备部分，不可缺失。 2.如何做到程序解耦？（IOC部分）2.1.程序的耦合和解耦在说明IOC先知道什么是程序的耦合和耦合 2.1.1.程序的耦合？在软件工程中，耦合指的就是就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。划分模块的一个 准则就是高内聚低耦合。 它有如下分类： 模块耦合分为数据耦合、特征耦合、控制耦合、公共环境耦合、内容耦合。耦合程度由低到高。 1）数据耦合： 两个模块彼此间通过参数交换信息，而且交换的信息仅仅是数据（指的是单一的原子的数据片段），那么这种耦合称为数据耦合。数据耦合是低耦合。系统中至少必须存在这种耦合。这是不可避免的。 2）特征耦合 当把整个数据结构作为参数、局部变量或者返回值，而被调用的模块只需要使用其中一部分数据元素时，就出现了特征耦合。（意思为传递了一个数据结构，但是调用方没有将该数据结构中全部数据使用便为特征耦合） 比如判断一个人是否成年，只需要传递该人的出生日期即可，不必要把人传进去。 因此这种耦合，通常是可以通过修改参数、局部变量或者返回值，只使用必要的数据元素来避免。 3）控制耦合 传递的信息中有控制信息(尽管有时这种控制信息以数据的形式出现)，则这种耦合称为控制耦合。控制耦合是中等程度的耦合。 比如，传递的参数中包含一个枚举类型的参数，在方法的具体逻辑中判断该参数实现不同的功能。那么，完全可以通过将一个方法修改为多个方法改进这种耦合。 4）公共环境耦合 当两个或多个模块通过一个公共数据环境相互作用时，它们之间的耦合称为公共环境耦合。公共环境可以是全程变量、共享的通信区、内存的公共覆盖区、任何存储介质上的文件、物理设备等。公共环境耦合的复杂程度随耦合的模块个数而变化，当耦合的模块个数增加时复杂程度显著增加。 只有两个模块有公共环境，耦合有下面两种可能。 一个模块往公共环境送数据，另一个模块从公共环境取数据。这是数据耦合的一种形式，是比较松散的耦合。 两个模块都既往公共环境送数据又从里面取数据，这种耦合比较紧密，介于数据耦合和控制耦合之间。 限制范围，比如如果是依赖的是汇率，提供一个统一获汇率配置的方法，限制耦合范围。 5）内容耦合 最高程度的耦合是内容耦合。如果出现下列情况之一，两个模块间就发生了内容耦合。 一个模块访问另一个模块的内部数据。 一个模块不通过正常入口而转到另一个模块的内部。 两个模块有一部分程序代码重叠(只可能出现在汇编程序中)。 一个模块有多个入口(这意味着一个模块有几种功能)。 应该坚决避免使用内容耦合，重构吧。 2.1.4.解决jdbc代码耦合思考1：为什么在使用JDBC使用的是Class.forName(&quot;DriverName&quot;) 而不是 DriverManager.register(new Driver)？ 第一：使用DriverManager.register 会出现强依赖的现象 第一步出现了依赖现象，如果在Maven中没有导入jdbc的包则会在编译期出现错误。 12345678910111213141516171819//1.注册驱动 在这一步因为需要new 一个Driver对象，出现了强依赖 DriverManager.registerDriver(new com.mysql.jdbc.Driver()); //2.创建连接 Connection con = DriverManager.getConnection(\"url\",\"username\",\"password\"); //3.使用连接，创建sql预处理对象 String sql = \"select * from department\"; PreparedStatement ps = con.prepareStatement(sql); //4.执行查询对象 ResultSet resultSet = ps.executeQuery(); //5.遍历数据 while (resultSet.next())&#123; System.out.print(resultSet.getString(\"id\")); System.out.print(resultSet.getString(\"name\")); System.out.println(); &#125; //6.释放资源 resultSet.close(); ps.close(); con.close(); 第二：如果使用的是DriverManager.register的方式去注册，那么驱动会被注册两次 第一次：从翻看源码中可以发现一旦 com.mysql.Driver 被加载，则会调用静态构造函数从而执行java.sql.DriverManager.registerDriver(new Driver());完成驱动注册 第二次：为自己在代码中手动注册了注册 123456789101112131415161718192021222324//该mysql连接包的版本为5.1.46 在6.0+的版本中，就不使用com.mysql.Driver的类了//而是使用com.mysql.cj.jdbc.Driver去完成注册操作public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; // // Register ourselves with the DriverManager // static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException(\"Can't register driver!\"); &#125; &#125; /** * Construct a new driver and register it with DriverManager * * @throws SQLException * if a database error occurs. */ public Driver() throws SQLException &#123; // Required for Class.forName().newInstance() &#125;&#125; 使用Class.forName(String driverName)的好处 使用了这种方式传递的是字符串，所以并不会在编译期出现错误。从而减少了耦合度 1234567891011121314151617181920212223//1.注册驱动 在这一步因为需要new 一个Driver对象，出现了强依赖 //DriverManager.registerDriver(new com.mysql.jdbc.Driver()); //在5.0的驱动版本中使用的是 //Class.forName(\"com.mysql.jdbc.Driver()\"); // 在6.0+的驱动版本中使用的是 Class.forName(\"com.mysql.cj.jdbc.Driver\"); //2.创建连接 Connection con = DriverManager.getConnection(\"jdbc:mysql://120.76.56.183:33306/qingzhai_base\",\"root\",\"root\"); //3.使用连接，创建sql预处理对象 String sql = \"select * from department\"; PreparedStatement ps = con.prepareStatement(sql); //4.执行查询对象 ResultSet resultSet = ps.executeQuery(); //5.遍历数据 while (resultSet.next())&#123; System.out.print(resultSet.getString(\"id\")); System.out.print(resultSet.getString(\"name\")); System.out.println(); &#125; //6.释放资源 resultSet.close(); ps.close(); con.close(); 2.1.3耦合总结总之，耦合是影响软件复杂程度的一个重要因素。应该采取下述设计原则：尽量使用数据耦合，少用控制耦合和特征耦合，限制公共环境耦合的范围，完全不用内容耦合。 ps: 编译器不依赖，运行期才依赖 2.2.如何更加通用的方式解决程序耦合问题？通过在2.1.4.中发现了可以使用字符串的方式减少了 new 关键字的出现，便减少程序的耦合度。由此可以进一步挖掘，是否在之后的new 对象的过程省略，而是使用字符串去完成对象的创建，这样便进一步的解决了系统的耦合度。 这时候就可以想到使用Java的反射，创建一个配置文件，在配置文件中，设置类的关键字映射到对应类的全路径上，通过反射完成对象的创建。 2.2.1.使用工厂模式解耦2.2.1.1.什么是工厂模式个人理解：将创建的类的过程交由工厂去解决，工厂负责封装具体创建类的过程，只对外提供对应的方法，客户端只需要调用对应的接口便可以获取到对应的类。 好处：通过工厂模式可以进一步解除系统耦合。 图解： 在未使用工厂模式下客户端直接获取资源(也就是new 对象)，这就造成了高耦合度，不易于扩展 当使用了工厂模式情况下，客户端需要通过工厂去获取对象，而具体的实现过程被工厂隐藏，工厂读取配置文件，通过反射实例化对象，系统便具有了高扩展性。 2.2.1.2.简单使用工厂模式创建类简单使用：通过BeanName创建对象，减少耦合程度 123456789101112131415161718192021222324252627282930313233343536/** * @author : Accompany * @date : 2019/09/10 * 实现类对象的创建 */public class BeanFactory &#123; private static Properties properties; //加载配置文件信息 static &#123; try &#123; //通过类加载器读取配置文件 InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(\"application.properties\"); properties = new Properties(); properties.load(in); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static Object getBean(String beanName)&#123; //获取到类路径 String beanPath = properties.getProperty(beanName); //创建类对象 try &#123; return Class.forName(beanPath).newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 2.2.1.3.完善工厂模式问题1：单例和多例的区别是什么？好处是什么？ 区别： 单例：多次通过工厂模式创建同一个对象只会在内存中存在一个实例。 使用场景：在类中有共享数据或没有成员变量（例如 dao层 service层 ） 好处：因为只创建了一个实例，节省内存和JVM垃圾回收造成的性能浪费、可以存放共享数据（但是会存在线程安全问题）、效率会比多例模式快 坏处：因为是单例的所以会出现线程安全问题 多例：每次通过工厂模式去创建同一个对象都会在内存中创建一个新的实例 使用场景：当一个类只需要临时使用、每次都需要读最新的配置文件的时候可以使用。 好处：防止并发错误，如果在多线程的情况下，使用的是单例，假如修改了状态值，那么整个请求就会发生异常。 坏处：因为是不断的创建对象，就会占用大量的内存，同时也会导致GC的活动频繁导致性能下降。 问题2：创建Bean应该为多例还是单例？ 具体问题需要具体分析 像dao层和service层，没有了成员变量，在线程安全问题上就降低很多，可以使用单例模式 像controller层，在struts2中使用的是多例，但是在spring mvc中使用的是单例。 当对象含有可改变状态时（更精确的说，在实际的应用中该状态会发生改变），使用多例，否则单例 修改代码：同时这也是spring的设计思想，当bean为单例的时候，会将对象在容器初始化的时候创建并且存进Map集合中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class BeanFactory &#123; private static Map&lt;String,Object&gt; objectMap; //加载配置文件信息 static &#123; try &#123; //通过类加载器读取配置文件 InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(\"application.properties\"); Properties properties = new Properties(); objectMap = new HashMap&lt;String, Object&gt;(); properties.load(in); //将配置文件中全部的对象映射地址创建成对象封装到map集合中 Enumeration&lt;Object&gt; keys = properties.keys(); while (keys.hasMoreElements())&#123; //读取某个对象路径地址 String objKey = (String) keys.nextElement(); String objPath = properties.getProperty(objKey); Object object = Class.forName(objPath).newInstance(); objectMap.put(objKey,object); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static Object getBean(String beanName) throws ClassNotFoundException &#123; /* 未修改前 //获取到类路径 String beanPath = properties.getProperty(beanName); //创建类对象 try &#123; return Class.forName(beanPath).newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return null; */ if (!objectMap.containsKey(beanName))&#123; throw new ClassNotFoundException(\"类不存在\"); &#125; return objectMap.get(beanName); &#125;&#125; 2.3. IOC是个啥玩意？IOC ：inversion of control （控制反转），这是一种思想理念，并不是只有Spring独有的，在Spring中使用DI去实现了这种思想。 在Spring中的解释为将Bean的创建权、管理权转交由Spring去管理，这样程序员就不必过多的关注Bean的生命周期的问题了，可以更加关注于业务处理。 2.3.1. Spring中IOC 1）在工程的POM文件中导入Spring-Context的基本坐标,便具备了Spring IOC功能 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; 当导入文件会发现会多了很多依赖，对应1.4中Spring的体系结构，可以看出点端倪 自动加入了spring-apo包，说明了Spring的基础功能需要依赖spring-aop spring中对apache.logging日志处理系统进行封装（spring-jcl包）这就需要注意，如果导入其他框架，该框架也有日志系统的话，那么就会出现冲突问题，这时候就需要解决了。 2）在resources目录下创建配置文件（*.xml）文件，该文件的作用为，阐述类的信息和类之间依赖关系 配置文件信息 根据前面的如何自定义手动解耦的思想，那么可以知道，在配置文件中最起码需要具备 一个标识符、标识符指向的类的全路径 所以在Spring的配置文件中便会出现Beans的大标签下有Bean的小标签代表着一个个的bean对象。 id便是标识符、class便是指向类的全路径 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean class=\"com.accompany.spring.demo1.service.impl.studentServiceImpl\" id=\"studentService\"&gt; &lt;/bean&gt;&lt;/beans&gt; 3）在简单使用 在ui中读取配置文件，并且将存储在spring IOC容器的对象取出 12345678public static void main(String[] args) &#123; //读取配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(\"application.xml\"); //将对象从IOC容器中取出 studentService studentService = (studentService) context.getBean(\"studentService\"); //调用方法 studentService.findAll(); &#125; 2.3.2. Spring 的 BeanFactory 是什么？BeanFactory是spring的工厂模式的顶级接口。同时可以从图中看出该接口具体很多实现类，到那时具体使用的只有三个。 AnnotationConfigApplicationContext：是有关于注解配置 ClassPathXMLApplicationContext：读取src目录下的配置文件，也就是存放在resources下的配置文件 FileSystemXmlApplicationContext：读取系统中绝对路径下XML文件文件（不推荐使用） 2.3.3. BeanFacotry与ApplicationContext的区别BeanFacotry是一个顶级接口，而ApplicationContext是继承了BeanFactory下的HierarchicalBeanFactory也就是说，间接的继承了BeanFactory。 BeanFacotry与ApplicaitonContext区别 他们在创建Bean对象的时间点不同， BeanFacotry（实现类XMLBeanFactory已经弃用的对象）采用的策略是懒加载策略： 懒加载：在Bean对象被使用的时候才被加载，容器初始化的时候不会被加载 ApplicaitonContext采用的策略是立即加载 立即加载：在容器初始化的时候就被加载放进了Map集合 思考：什么时候使用懒加载什么时候使用立即加载呢？ 单例模式使用立即加载 多例模式使用懒加载（因为多例模式最好是在需要的时候在去创建是最节省空间的） 2.3.4. IOC中Bean标签和管理对象细节2.3.4.1. Bean标签bean标签存在的位置：在spring的配置文件中出现 作用：将对象的管理权交由spring管理 属性： id：指向全路径类的标识符（通常写成类名/接口名） class：类的全路径信息 scope：指定类对象的作用范围 singleton：默认值 单例 prototyoe：多例 request：WEB项目中，将该对象创建放进request域中 session：WEB项目中，将该对象创建放进session域中 global session：WEB项目中，应用在分布式环境下，将对象创建放进全局session中，如果不是分布式环境下，那么该配置相当于session 2.3.4.2实例化Bean的三种方式 第一种：通过构造函数去实例化Bean 在无参构造函数下实例化 参数说明： bean：声明一个交由Spring IOC管理的Bean对象 id：指向全路径类的标识符（通常写成类名/接口名） class：类的全路径信息 这种方式创建的对象是针对无参构造函数的，当存在有参构造函数的时候会出现错误 12&lt;bean id=\"studentService\" class=\"com.accompany.spring.demo1.service.impl.studentServiceImpl\" &gt;&lt;/bean&gt; 在有参构造函数下实例化 参数说明 constructor-arg：阐述构造函数参数的信息 name：表示参数的名称 value：插入基本数据类型和String类型 ref：插入对象类型数据（该对象类型数据必须交由Spring管理才能注入） 1234567&lt;bean id=\"Student\" class=\"com.accompany.spring.demo1.bean.Student\"&gt; &lt;constructor-arg name=\"name\" value=\"张三\"/&gt; &lt;constructor-arg name=\"age\" value=\"15\"/&gt; &lt;constructor-arg name=\"birthday\" ref=\"date\"/&gt;&lt;/bean&gt;&lt;bean id=\"date\" class=\"java.util.Date\"&gt;&lt;/bean&gt; 第二种：通过静态工厂模式实例化 该模式是当存在一个工厂，该工厂具有一个静态方法可以获取到一个对象，那么可以通过该方法获取到返回的对象直接放入spring容器中，无须将工厂注入也可以完成。（这种适用于框架整合，同时该方法必须为静态方法） 工厂对象： 123456789public class StaticFacotry &#123; private static Student student = new Student(); public static Student createStudent()&#123; student.setName(\"梨花\"); student.setAge(11); student.setBirthday(new Date()); return student; &#125;&#125; 配置文件： 需要注意 class 写的是工厂类的全路径，factory-method 写的是从工厂获取到类的方法 不需要提供需要实例化的对象的全路径 如果方法中需要传值，那么就需要在实例化的对象中加入构造传值 1&lt;bean id=\"StaticStudent\" class=\"com.accompany.spring.demo1.Factory.StaticFacotry\" factory-method=\"createStudent\" /&gt; 第三种：通过非静态工厂实例化 该模式是当存在一个工厂，该工厂具有一个非方法可以获取到一个对象，需要将工厂注入到Spring容器，再通过具体需要实例化的类去调用注入的工厂的方法完成实例化（这种适用于框架整合，这个工厂方法为非静态方法） 工厂对象 123456789public class Factory &#123; private static Student student = new Student(); public Student createStudent()&#123; student.setName(\"张三丰\"); student.setAge(100); student.setBirthday(new Date()); return student; &#125;&#125; 配置文件 需要注意：在使用非静态工厂方法的时候 1.先将工厂对象交由spring管理 2.在需要实例化的对象中加入 factory-bean：指向spring中工厂类 3.factory-method：为工厂类中提供对象的方法 4.在需要实例化的对象中不需要添加实例化对象的全路径 5.如果方法中需要传值，那么就需要在实例化的对象中加入构造传值 1234&lt;bean id=\"factory\" class=\"com.accompany.spring.demo1.Factory.Factory\"/&gt;&lt;bean id=\"student\" factory-bean=\"factory\" factory-method=\"createStudent\"&gt; &lt;constructor-arg name=\"string\" value=\"yyx\"/&gt;&lt;/bean&gt; 2.3.4.3. Bean对象的生命周期不同的Bean对象作用范围，生命周期不同。 scope=”singleton”：单例对象 在整个应用中只会存在一个对象 生命周期 对象初始化：当Spring 容器加载的时候，对象就开始初始化（前提是该对象为立即加载） 对象存活：只要容器在，那么对象就会存活 对象死亡：当容器死亡那么对象就死亡 scope=”prototype”：多例对象 每次get都会创建新的对象 生命周期 对象初始化：当调用了getBean的方法的时候开始完成对象的初始化 对象存活：只要对象任然在使用中，那么对象就一直存活 对象死亡：当对象没有被使用，等待GC回收，然后释放所占用的内存（需要注意，由于Spring不知道对象什么时候死亡，所以destroy-method 的方法是无法执行的） 2.3.5. DI（依赖注入）是个什么玩意？2.3.5.1. DI自述DI ：Dependency injection 也称为依赖注入，它是Spring框架IOC的具体实现 DI在Spring中的作用是，当容器运行时，能够将对象依赖的数据注入到对象中，比如通过构造方法注入属性，SET方法注入属性。 2.3.5.2.为什么叫依赖注入呢？例子：就像是 service层 需要依赖dao层 ，在交给Spring容器管理的时候， 就需要在service层中说明依赖了那个dao层接口，这样service层就可以使用dao层方法了。 好处：通过将对象注入到对象，维护了类之间依赖关系。这种方式相比于传统模式下更加好，因为减少了硬编码，不需要在代码中写出具体的实现类是什么，而是通过在Bean工厂中获取到对应的实现类，这种方式减少耦合度，增加了系统的可扩展性。 传统模式下的实现方式 DI方式下的实现方式 2.3.5.3. 构造函数注入解释：在实例化Bean对象的时候，容器读取配置文件，通过构造函数去实例化对象。 好处：强制要求Bean对象在初始化一定要传递什么值。 坏处：不够灵活，如果有些值不必要传递那么就需要强硬的传值。 参数说明 constructor-arg：阐述构造函数参数的信息 name：表示参数的名称 value：插入基本数据类型和String类型 ref：插入对象类型数据（该对象类型数据必须交由Spring管理才能注入） 1234567&lt;bean id=\"Student\" class=\"com.accompany.spring.demo1.bean.Student\"&gt; &lt;constructor-arg name=\"name\" value=\"张三\"/&gt; &lt;constructor-arg name=\"age\" value=\"15\"/&gt; &lt;constructor-arg name=\"birthday\" ref=\"date\"/&gt;&lt;/bean&gt;&lt;bean id=\"date\" class=\"java.util.Date\"&gt;&lt;/bean&gt; 2.3.5.4. Set 方法注入解释：通过给属性设置set方法，容器底层调用set方法将配置文件中对应属性的值注入到对象中。（属性值必须具有Set方法才能使用） 好处：能够很灵活的给Bean对象注入属性值 坏处：有些属性必须赋值缺做不到，所以需要通过构造函数注入加上Set注入完成最佳化 参数说明 property：阐述构造函数参数的信息 name：set方法名，去掉set， 第一个字母小写 value：插入基本数据类型和String类型 ref：插入对象类型数据（该对象类型数据必须交由Spring管理才能注入） 12345&lt;bean id=\"student1\" class=\"com.accompany.spring.demo1.bean.Student\"&gt; &lt;property name=\"age\" value=\"200\" /&gt; &lt;property name=\"name\" value=\"请勿打扰\" /&gt; &lt;property name=\"birthday\" ref=\"date\"/&gt;&lt;/bean&gt; 2.3.5.5. p标签注入解释：这种方式底层还是使用set方法注入，需要在引入约束头中加入p空间约束才能使用 好处：更加简单使用set方法注入属性 坏处：需要在约束头中加入p空间约束才能使用 步骤： 1.现在约束中加入p空间约束(在第二行) 1234&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; 2.在bean标签中使用P空间 格式： 调用set方法名：set方法名，去掉set， 第一个字母小写 基础数据类型/String数据类型：p: 调用set方法名= “属性值” 对象数据类型：p: 调用set方法名-ref = “属性值” 123&lt;bean id=\"student2\" class=\"com.accompany.spring.demo1.bean.Student\" p:age=\"250\" p:name=\"我真帅\" p:birthday-ref=\"date\"&gt;&lt;/bean&gt; 2.3.5.6.注入集合属性数据Spring的DI可以给对象注入 数组，List，Set, Map, Properties的数据,同时也存在着一定的规律 规律： 数组,List,Set是同类型的数据结构，在声明数据结构的时候可以混用 Map,properties是同类型的数据结构，在声明数据结构的时候可以混用 给对象注入数组类型（array | list | set）推荐使用 &lt;list&gt; &lt;value&gt;20&lt;/value&gt; &lt;/list&gt; 1234567891011121314151617181920212223&lt;bean id=\"student3\" class=\"com.accompany.spring.demo1.bean.Student\"&gt; &lt;property name=\"arr\"&gt; &lt;array&gt; &lt;value&gt;5&lt;/value&gt; &lt;value&gt;10&lt;/value&gt; &lt;value&gt;15&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;20&lt;/value&gt; &lt;value&gt;25&lt;/value&gt; &lt;value&gt;30&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"set\"&gt; &lt;list&gt; &lt;value&gt;100&lt;/value&gt; &lt;value&gt;200&lt;/value&gt; &lt;value&gt;300&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 键值对类型 （map | properties） 推荐使用&lt;map&gt; &lt;entry key=&quot;aa&quot; value=&quot;AA&quot;/&gt; &lt;/map&gt; 123456789101112131415&lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"aa\" value=\"AA\"/&gt; &lt;entry key=\"bb\" value=\"BB\"/&gt; &lt;entry key=\"cc\"&gt; &lt;value&gt;CC&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt;&lt;/property&gt;&lt;property name=\"properties\"&gt; &lt;props&gt; &lt;prop key=\"qq\" &gt;QQ&lt;/prop&gt; &lt;prop key=\"ww\" &gt;WW&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt;","categories":[{"name":"后端框架","slug":"后端框架","permalink":"https://aaccompany.github.io/categories/后端框架/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://aaccompany.github.io/tags/spring/"},{"name":"重走系列","slug":"重走系列","permalink":"https://aaccompany.github.io/tags/重走系列/"}]},{"title":"MQ知其然而不知其所然","slug":"MQ知其然而不知其所然","date":"2019-07-02T02:13:52.000Z","updated":"2019-07-10T05:10:42.935Z","comments":true,"path":"2019/07/02/MQ知其然而不知其所然/","link":"","permalink":"https://aaccompany.github.io/2019/07/02/MQ知其然而不知其所然/","excerpt":"","text":"MQ知其然而不知其所然1.什么是MQ？MQ：通俗的理解为消息队列。在分布式系统中，一个系统可以将一份数据存放在一个中间件上，然后其他系统需要这份数据的话，就可以从中间件上将这份数据取出。 那么问题来了，为什么需要使用MQ？ 可以使用MQ做到系统的解耦、异步、削峰。 2.MQ的优点2.1.解耦业务：A系统需要发送数据到BCD系统中，在BCD系统中进行操作 2.1.1.在不使用MQ下的系统耦合 坏处： 1.从图中可以知道，当A系统需要完成一个操作，需要BCD协同完成。当整个工程新增系统或者有系统不需要A传递的数据的话，那么就需要修改两方的数据。 2.因为A系统需要完成一个操作，需要依赖于BCD系统，那么如果其中一个出现了问题，那么整个系统就会出现异常。 3.如果A系统所依赖的系统访问超时该如何处理。 所以在这种模式容易出现许多问题，如何解决这些问题呢？ 2.1.2.系统使用MQ解耦 在使用了MQ情况下，A系统可以将需要传递数据发送到MQ中，这时候，A所依赖的系统（BCD）就可以从MQ中获取数据完成操作。这样的话就不需要考虑上面所提及的坏处。 2.2.异步2.2.1.在不使用MQ下系统是保持同步状态如果系统采用是的同步设计，那么会给系统造成高延迟的现象 由图中可以得到如果需要完成一个功能总共耗时为200 ms 2.2.2.在使用MQ下系统可以修改为异步状态如果将系统修改为异步状态，那么系统就可以大大减少系统延迟现象。 在使用了MQ的情况下，完成一个功能返回给用户的时间差只存在 50 ms + 5 ms = 55 ms。这样从同步系统到异步系统的时间比值为 40：11 接近省去了4倍的时间（在假设的情况下）。 在互联网企业上一个请求的响应时间应该在200 ms之内，这样用户就很难感知。 2.3.削峰2.3.1.没有削峰的系统 2.3.2.使用了MQ对系统进行削峰 3.引入MQ出现的问题？ 虽然系统中引入了MQ组件，做到了系统的异步、削峰、解耦，但是因为系统中加入了MQ导致了系统出现了下面几种问题。 3.1.系统的可用性降低引入了MQ，系统的消息转递需要依赖于MQ，但是当MQ宕机的话那么整个系统也会随之宕机。 3.2.系统的复杂度提高引入了MQ会导致系统的架构变得复杂。同时也需要考虑会出现的问题。 1）是否会往MQ中重复发送消息？ 2）发送给MQ的消息是否会丢失？ 3）发送给MQ的消息如果具有顺序，如何保证消息的顺序？ 3.3.系统一致性问题当系统A发送消息给BCD的话，ABC都执行完并且无异常，但是D出现异常。那么A会告知用户执行完毕，这种情况该如何解决。 如果做MQ的选型？1.社区活跃度 2.单机吞吐量 3.时效性 一般在中小型公司采用RabbitMQ（消息处理能力万级，但是语言采用的是erlang专门处理分布式的语言设计所有处理速度快），中大型公司有专门技术人员可以采用RockerMQ（消息处理能力十万级）。大数据采用kafka（消息处理能力十万级）。 一般现在不采用ActiveMQ（消息处理能力万级）作为MQ，因为社区活跃度开始下降。","categories":[{"name":"MQ","slug":"MQ","permalink":"https://aaccompany.github.io/categories/MQ/"}],"tags":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://aaccompany.github.io/tags/消息中间件/"}]},{"title":"RabbitMQ消息中间件","slug":"RabbitMQ消息中间件","date":"2019-07-02T02:13:52.000Z","updated":"2019-07-10T05:13:46.284Z","comments":true,"path":"2019/07/02/RabbitMQ消息中间件/","link":"","permalink":"https://aaccompany.github.io/2019/07/02/RabbitMQ消息中间件/","excerpt":"","text":"RabbitMQ消息中间件1.RabbitMQ简介1.1.消息队列简介消息中间件是分布式系统中的重要组件，主要解决了应用耦合，异步消息，流量削锋等问题，实现系统高性能，高可用，可伸缩性喝最终一致性【架构】使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka,MetaMQ,RocketMQ 1.2.什么是RabbitMQRabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。AMQP ：Advanced Message Queue Protocol，高级消息队列协议。它是应用层协议的一个开放 标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。RabbitMQ 初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括： 1.可靠性（Reliability）RabbitMQ 使用一些机制来保证可靠性，如持久化（当服务器挂掉的时候会不会丢失信息，而是会保存信息到硬盘）、传输确认、发布确认。 2.灵活的路由（Flexible Routing）在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。 3.消息集群（Clustering）多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。 4.高可用（Highly Available Queues）队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。 5.多种协议（Multi-protocol）RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。 6.多语言客户端（Many Clients） RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。 7.管理界面（Management UI）RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方 面。 8.跟踪机制（Tracing）如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。 9.插件机制（Plugin System）RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。 1.3.架构图与主要概念1.3.1.架构图 1.2.2.主要概念RabbitMQ Server： 也叫broker server，它是一种传输服务。 他的角色就是维护一条 从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。 Producer： 消息生产者，如图A、B、C，数据的发送方。消息生产者连接RabbitMQ服 务器然后将消息投递到Exchange。 Consumer：消息消费者，如图1、2、3，数据的接收方。消息消费者订阅队列， RabbitMQ将Queue中的消息发送到消息消费者。 Exchange：生产者将消息发送到Exchange（交换器），由Exchange将消息路由到一个 或多个Queue中（或者丢弃）。 Exchange并不存储消息。RabbitMQ中的Exchange有 direct、fanout、topic、headers四种类型，每种类型对应不同的路由规则。 Queue：（队列）是RabbitMQ的内部对象，用于存储消息。消息消费者就是通过订阅队列来获取消息的，RabbitMQ中的消息都只能存储在Queue中，生产者生产消息并终投递到Queue中，消费者可以从Queue中获取消息并消费。多个消费者可以订阅同一个 Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者 都收到所有的消息并处理。 RoutingKey：生产者在将消息发送给Exchange的时候，一般会指定一个routing key， 来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联 合使用才能终生效。在Exchange Type与binding key固定的情况下（在正常使用时一 般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过 指定routing key来决定消息流向哪里。RabbitMQ为routing key设定的长度限制为255 bytes。 Connection： （连接）：Producer和Consumer都是通过TCP连接到RabbitMQ Server 的。以后我们可以看到，程序的起始处就是建立这个TCP连接。 Channels： （信道）：它建立在上述的TCP连接中。数据流动都是在Channel中进行 的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。 VirtualHost：权限控制的基本单位，一个VirtualHost里面有若干Exchange和 MessageQueue，以及指定被哪些user使用 2.走进RabbitMQ2.1.RabbitMQ安装（1）下载并安装 Eralng配套软件中已提供otp_win64_20.2.exe （以管理员身份运行安装） （2）下载并安装rabbitmq配套软件中已提供rabbitmq-server-3.7.4.exe。双击安装，注意不要安装在包含中文和 空格的目录下！安装后window服务中就存在rabbitMQ了，并且是启动状态。 （3）安装管理界面（插件）进入rabbitMQ安装目录的sbin目录，输入命令rabbitmq‐plugins enable rabbitmq_management （4）重新启动服务 （5）打开浏览器，地址栏输入http://127.0.0.1:15672 ,即可看到管理界面的登陆页 输入用户名和密码，都为guest 进入主界面： 上侧的导航以此是：概览、连接、信道、交换器、队列、用户管理 2.2.Docker环境下安装1.下载镜像 1docker pull rabbitmq:management 2.创建RabbitMQ容器 1docker run -di --name=tensqura_rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 15671:15671 -p 15672:15672 -p 25672:25672 rabbitmq:management 15672 (if management plugin is enabled) 15671 management监听端口 5672, 5671 (AMQP 0-9-1 without and with TLS) 4369 (epmd) epmd 代表 Erlang 端口映射守护进程 25672 (Erlang distribution) 3.登入RabbitMQ管理界面 访问地址：http://192.168.186.129:15672 账号密码均为guest 2.3.直接模式(Direct)2.3.1.什么是直接模式将消息发给唯一一个节点时使用这种模式，这是简单的一种形式。 任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue。1.一般情况可以使用rabbitMQ自带的Exchange：””(该Exchange的名字为空字符串，下文称其为default Exchange)。 2.这种模式下不需要将Exchange进行任何绑定(binding)操作 3.消息传递时需要一个“RouteKey”，可以简单的理解为要发送到的队列名字。 4.如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃。 2.3.2创建队列Name:队列的名称 Durability:是否持久化 Auto Delete:是否自动删除 2.3.3.代码实现- 消息生产者1.引入依赖 1234567891011121314151617181920212223&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐starter‐parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- rabbitMQ起步依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐starter‐amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐starter‐test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.配置文件信息 123spring: rabbitmq: host: 192.168.192.129 3.编写启动类 1234567@SpringBootApplication public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125; &#125; 4.编写测试类 12345678910@RunWith(SpringRunner.class) @SpringBootTest(classes=Application.class) public class MqTest &#123; @Autowired private RabbitTemplate rabbitTemplate; @Test public void testSend()&#123; rabbitTemplate.convertAndSend(\"队列名称\",\"我要红包\"); &#125; &#125; 2.3.4.代码实现-消息消费者12345678@Component @RabbitListener(queues=\"itcast\" ) public class Customer1 &#123; @RabbitHandler public void showMessage(String message)&#123; System.out.println(\"itcast接收到消息：\"+message); &#125; &#125; 2.4.分裂模式（Fanout）2.4.1.什么是分裂模式（Fanout）消息传递个多个队列的时候就可以采用这种模式 任何发送到Exchange的消息都会转发到绑定到该Exchange的队列中。 1.可以理解为路由表的模式 2.这种模式不需要RouteKey 3.这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个 Queue，一个Queue可以同多个Exchange进行绑定。（多对多的关系） 4.如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃。 2.4.2.交换器绑定队列1.创建交换器，类型选择为fanout 2.创建队列 3.交换器绑定队列 选择对应的交换器，点击进去 填写需要绑定的队列名称 2.4.3.代码实现-消息生产者1234@Testpublic void testSendFanout()&#123; rabbitTemplate.convertAndSend(\"chuanzhi\",\"\", \"分列模式走起\");&#125; 2.4.4.代码实现-消息消费者创建一个类去监听对应的队列 123456789@Component @RabbitListener(queues=\"需要监听的队列名称\" )public class Customer2&#123; @RabbitHandler public void showMessage(String message)&#123; System.out.println(\"itheima接收到消息：\"+message); &#125; &#125; 2.5.主题模式（Topic）2.5.1.什么是主题模式任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue 上。可以说是分裂模式一种加强。 在这个模式中出现了匹配规则 routing key：就是一个匹配队列的规则，可以给每个Exchange绑定的队列设置routing key ,当一个消息经过Exchange的时候，如果使用的是主题模式，会匹配routing key，然后分发到对象的队列中。 规则： .* 表示匹配一个点后面任意字符 .# 表示匹配一个点后面任意字符（但是这种允许后面有多个 . 例如 abc.ac.exc 能匹配 abc.# 但是不能匹配 abc.*） 这种模式与前面两种模式差不多，当经过Exchange和routing key的时候，没有可以转发的队列，那么就会丢弃这条消息。 2.5.2.创建队列与绑定1.创建队列，类型选择为topic 2.创建队列 3.绑定队列，并且设置routing key 2.5.3.代码实现-消息生产者12@Test public void testSendTopic1()&#123; rabbitTemplate.convertAndSend(\"topictest\",\"goods.aaa\",\"主题模式\"); &#125; 2.5.4.代码实现-消息消费者123456789@Component @RabbitListener(queues=\"需要监听的队列名称\" )public class Customer2&#123; @RabbitHandler public void showMessage(String message)&#123; System.out.println(\"itheima接收到消息：\"+message); &#125; &#125;","categories":[{"name":"MQ","slug":"MQ","permalink":"https://aaccompany.github.io/categories/MQ/"}],"tags":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://aaccompany.github.io/tags/消息中间件/"}]},{"title":"Active消息中间件","slug":"Active消息中间件","date":"2019-07-02T02:13:52.000Z","updated":"2019-07-10T05:08:29.951Z","comments":true,"path":"2019/07/02/Active消息中间件/","link":"","permalink":"https://aaccompany.github.io/2019/07/02/Active消息中间件/","excerpt":"","text":"消息中间件当没有采用消息中间件的系统模块图,当运营商后台去调用搜索服务和页面生成服务的时候，不需要知道他们返回的结果，所以在这里为了提高效率、降低系统耦合度可以采用消息中间件的解决方案。 当采用了消息中间件之后的系统模块图，中间去除了dubbo和减少了对搜索服务和页面生成服务的依赖，降低了系统耦合度 1.什么是消息中间件消息中间件利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。对于消息中间件，常见的角色大致也就有Producer（生产者）、Consumer（消费者） 1.1常见的消息中间件产品 JMS:JAVA MESSAGE SERVICE （1）ActiveMQ ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。 （2）RabbitMQ AMQP协议的领导实现，支持多种场景。淘宝的MySQL集群内部有使用它进行通讯，OpenStack开源云平台的通信组件，最先在金融行业得到运用。 （3）ZeroMQ 史上最快的消息队列系统 （4）Kafka Apache下的一个子项目 。特点：高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；完全的分布式系统。适合处理海量数据。 1.1.什么是JMSJMS（Java Messaging Service）是Java平台上有关面向消息中间件的技术规范，它便于消息系统中的Java应用程序进行消息交换,并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发。 ​ JMS本身只定义了一系列的接口规范，是一种与厂商无关的 API，用来访问消息收发系统。它类似于 JDBC(java Database Connectivity)：这里，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。许多厂商目前都支持 JMS，包括 IBM 的 MQSeries、BEA的 Weblogic JMS service和 Progress 的 SonicMQ，这只是几个例子。 JMS 使您能够通过消息收发服务（有时称为消息中介程序或路由器）从一个 JMS 客户机向另一个 JML 客户机发送消息。消息是 JMS 中的一种类型对象，由两部分组成：报头和消息主体。报头由路由信息以及有关该消息的元数据组成。消息主体则携带着应用程序的数据或有效负载。 JMS 定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一 些不同形式的数据，提供现有消息格式的一些级别的兼容性。 · TextMessage–一个字符串对象 · MapMessage–一套名称-值对 · ObjectMessage–一个序列化的 Java 对象 · BytesMessage–一个字节的数据流 · StreamMessage – Java 原始值的数据流 1.2.JMS消息传递在消息传递存在两种类型： 1.2.1.点对点一个生产者会对应一个消费者，一个生成者发布的消息会存放在队列中，然后消费者不一定需要及时将队列的数据取出，而是可以不定时的去获取数据。当数据被取出的时候队列中的消息就会减少一条。 当存在多个消费者监听的队列是同一个的时候，谁先监听消息队列谁就先获取到数据。 1.2.2.发布/订阅一个生产者会对应多个消费者，当一个生产者发布了一条信息，会将数据存放在topic中，然后即时发生给每个在线的消费者，类似与广播的特性。 当有一个消费者没有上线的时候，会接受不到广播。 2.ActiveMQ安装（Linux）（1）将apache-activemq-5.12.0-bin.tar.gz 上传至服务器 （2）解压此文件 tar zxvf apache-activemq-5.12.0-bin.tar.gz （3）为apache-activemq-5.12.0目录赋权 chmod 777 apache-activemq-5.12.0 （4）进入apache-activemq-5.12.0\\bin目录 （5）赋与执行权限 12345678910111213141516 chmod 755 activemq -------------------------- **知识点小贴士**------------------------ linux 命令chmod 755的意思 chmod是 Linux 下设置文件权限的命令，后面的数字表示不同用户或用户组的权限。 一般是三个数字： 第一个数字表示文件所有者的权限 第二个数字表示与文件所有者同属一个用户组的其他用户的权限 第三个数字表示其它用户组的权限。 权限分为三种：读（r=4），写（w=2），执行（x=1） 。 综合起来还有可读可执行（rx=5=4+1）、可读可写（rw=6=4+2）、可读可写可执行(rwx=7=4+2+1)。 所以，chmod 755 设置用户的权限为： 1.文件所有者可读可写可执行 --7 2.与文件所有者同属一个用户组的其他用户可读可执行 --5 3.其它用户组可读可执行 --5 1.3.3启动​ ./activemq start 出现下列提示表示成功！ 假设服务器地址为192.168.25.135 ，打开浏览器输入地址 http://192.168.25.135:8161/ 即可进入ActiveMQ管理页面 点击进入管理页面 输入用户名和密码 均为 admin 进入主界面 点对点消息列表： 列表各列信息含义如下： Number Of Pending Messages ：等待消费的消息 这个是当前未出队列的数量。 Number Of Consumers ：消费者 这个是消费者端的消费者数量 Messages Enqueued ：进入队列的消息 进入队列的总数量,包括出队列的。 Messages Dequeued ：出了队列的消息 可以理解为是消费这消费掉的数量。 3.JMS入门小Demo3.1点对点Demo点对点的模式主要建立在一个队列上面，当连接一个列队的时候，发送端不需要知道接收端是否正在接收，可以直接向ActiveMQ发送消息，发送的消息，将会先进入队列中，如果有接收端在监听，则会发向接收端，如果没有接收端接收，则会保存在ActiveMQ服务器，直到接收端接收消息，点对点的消息模式可以有多个发送端，多个接收端，但是一条消息，只会被一个接收端给接收到，哪个接收端先连上ActiveMQ，则会先接收到，而后来的接收端则接收不到那条消息。 3.1.1添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-client&lt;/artifactId&gt; &lt;version&gt;5.13.4&lt;/version&gt; &lt;/dependency&gt; 3.1.2生产者代码注意： 1)在地址中传输协议为tcp 2）在第四步骤中的参数说明 第一个参数：是否开启事务 第二个参数消息的确定模式 AUTO_ACKNOWLEDGE = 1 自动确认 CLIENT_ACKNOWLEDGE = 2 客户端手动确认 DUPS_OK_ACKNOWLEDGE = 3 自动批量确认 SESSION_TRANSACTED = 0 事务提交并确认 12345678910111213141516171819202122232425public static void main(String[] args) throws Exception &#123; //1.创建连接工厂 //说明：使用想对应的是厂商的连接工厂 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://120.76.56.183:61616\"); //2.创建连接 Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.获取session //参数说明：1.是否启用事务2.消息确认模式 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建消息队列 //参数说明：队列的名称 Queue queue = session.createQueue(\"test-queue\"); //6.创建生产者 参数说明：生产者使用那个消息对象 MessageProducer producer = session.createProducer(queue); //7.创建消息 TextMessage message = session.createTextMessage(\"你真是个大傻吊\"); //8.发生消息 producer.send(message); //9.关闭资源 producer.close(); session.close(); connection.close(); &#125; 3.1.3消费者代码注意：需要创建匿名内部类 Message Listener 1234567891011121314151617181920212223242526272829303132public static void main(String[] args) throws Exception &#123; //1.创建连接工厂 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://120.76.56.183:61616\"); //2.创建连接 Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.获取session Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.监听对应的消息队列 Queue queue = session.createQueue(\"test-queue\"); //6.由会话，创建消息消费者 MessageConsumer consumer = session.createConsumer(queue); //7.监听消息 consumer.setMessageListener(new MessageListener() &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage)message; try &#123; System.out.println(\"监听到的消息\"+textMessage.getText()); &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;); //8.持续监听 System.in.read(); //9.释放资源 consumer.close(); session.close(); connection.close(); &#125; 3.2发布/订阅Demo3.2.1添加依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-client&lt;/artifactId&gt; &lt;version&gt;5.13.4&lt;/version&gt; &lt;/dependency&gt; 3.2.2生产者代码12345678910111213141516171819202122public static void main(String[] args) throws Exception &#123; //1.创建连接工厂 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://120.76.56.183:61616\"); //2.获取连接 Connection connection = connectionFactory.createConnection(); //3.开启连接 connection.start(); //4.获取session Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建topic Topic topic = session.createTopic(\"test-topic\"); //6.创建消息生产者 MessageProducer producer = session.createProducer(topic); //7.创建消息 由session去创建消息 TextMessage message = session.createTextMessage(\"啊啊啊啊，你可以简单点么\"); //8.发送消息 producer.send(message); //9.释放资源 producer.close(); session.close(); connection.close(); &#125; 3.2.3消费者代码1234567891011121314151617181920212223242526272829303132public static void main(String[] args) throws Exception &#123; //1.创建工厂 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://120.76.56.183:61616\"); //2.创建连接 Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.获取session Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.获取Topic Topic topic = session.createTopic(\"test-topic\"); //6.获取topic消费者 MessageConsumer consumer = session.createConsumer(topic); //7.设置监听 consumer.setMessageListener(new MessageListener() &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; System.out.println(\"topic监听到了\"+textMessage.getText()); &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;); //8.持久监听 System.in.read(); //9.关闭资源 consumer.close(); session.close(); connection.close(); &#125; 4.Spring整合ActiveMQ4.1点对点Demo4.1.1生产者代码123456789101112131415161718//JMS模板 负责发送消息 接受消息 @Autowired private JmsTemplate jmsTemplate ; //消息的目的地 @Autowired private Destination queueTextDestination; /** * 生成者发生信息 */ public void sendTextMessage(final String text) &#123; jmsTemplate.send(queueTextDestination, new MessageCreator() &#123; public Message createMessage(Session session) throws JMSException &#123; return session.createTextMessage(text); &#125; &#125;); &#125; 4.1.2配置文件1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:amq=\"http://activemq.apache.org/schema/core\" xmlns:jms=\"http://www.springframework.org/schema/jms\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"com.yuanxiong.producer\"&gt;&lt;/context:component-scan&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id=\"targetConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"&gt; &lt;property name=\"brokerURL\" value=\"tcp://120.76.56.183:61616\"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.SingleConnectionFactory\"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name=\"targetConnectionFactory\" ref=\"targetConnectionFactory\"/&gt; &lt;/bean&gt; &lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt; &lt;bean id=\"jmsTemplate\" class=\"org.springframework.jms.core.JmsTemplate\"&gt; &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 文本信息--&gt; &lt;bean id=\"queueTextDestination\" class=\"org.apache.activemq.command.ActiveMQQueue\"&gt; &lt;!-- 消息队列的值 --&gt; &lt;constructor-arg value=\"queue_text\"/&gt; &lt;/bean&gt; &lt;!--这个是订阅模式 文本信息 &lt;bean id=\"topicTextDestination\" class=\"org.apache.activemq.command.ActiveMQTopic\"&gt; &lt;constructor-arg value=\"topic_text\"/&gt; &lt;/bean&gt; --&gt; &lt;/beans&gt; 4.1.3消费者代码1234567891011121314151617181920212223package com.yuanxiong.consumer;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;import org.springframework.stereotype.Component;@Componentpublic class myMessageListener implements MessageListener &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; System.out.println(\"queue监听到了\"+textMessage.getText()); &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 4.1.4配置文件123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:amq=\"http://activemq.apache.org/schema/core\" xmlns:jms=\"http://www.springframework.org/schema/jms\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id=\"targetConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"&gt; &lt;property name=\"brokerURL\" value=\"tcp://120.76.56.183:61616\"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.SingleConnectionFactory\"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name=\"targetConnectionFactory\" ref=\"targetConnectionFactory\"/&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 文本信息--&gt; &lt;bean id=\"queueTextDestination\" class=\"org.apache.activemq.command.ActiveMQQueue\"&gt; &lt;constructor-arg value=\"queue_text\"/&gt; &lt;/bean&gt; &lt;!-- 我的监听类 --&gt; &lt;context:component-scan base-package=\"com.yuanxiong.consumer\"&gt;&lt;/context:component-scan&gt; &lt;!-- 消息监听容器 --&gt; &lt;bean class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\" /&gt; &lt;property name=\"destination\" ref=\"queueTextDestination\" /&gt; &lt;!-- 我的监听类 --&gt; &lt;property name=\"messageListener\" ref=\"myMessageListener\" /&gt; &lt;/bean&gt; &lt;/beans&gt; 4.2发布订阅Demo4.2.1生产者代码123456789101112131415161718192021222324252627282930package com.yuanxiong.producer;import javax.jms.Destination;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.Session;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jms.core.JmsTemplate;import org.springframework.jms.core.MessageCreator;import org.springframework.stereotype.Component;@Componentpublic class TopicProducer &#123; @Autowired private JmsTemplate jmsTemplate; @Autowired private Destination topicTextDestination; public void sendTextMessage(final String string) &#123; jmsTemplate.send(topicTextDestination, new MessageCreator() &#123; public Message createMessage(Session session) throws JMSException &#123; return session.createTextMessage(string); &#125; &#125;); &#125;&#125; 4.2.2配置文件1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:amq=\"http://activemq.apache.org/schema/core\" xmlns:jms=\"http://www.springframework.org/schema/jms\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"com.yuanxiong.producer\"&gt;&lt;/context:component-scan&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id=\"targetConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"&gt; &lt;property name=\"brokerURL\" value=\"tcp://120.76.56.183:61616\"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.SingleConnectionFactory\"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name=\"targetConnectionFactory\" ref=\"targetConnectionFactory\"/&gt; &lt;/bean&gt; &lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt; &lt;bean id=\"jmsTemplate\" class=\"org.springframework.jms.core.JmsTemplate\"&gt; &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt; &lt;/bean&gt; &lt;!--这个是订阅模式 文本信息 --&gt; &lt;bean id=\"topicTextDestination\" class=\"org.apache.activemq.command.ActiveMQTopic\"&gt; &lt;constructor-arg value=\"topic_text\"/&gt; &lt;/bean&gt; &lt;/beans&gt; 4.2.3消费者代码1234567891011121314151617181920212223package com.yuanxiong.consumer;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;import org.springframework.stereotype.Component;@Componentpublic class myTopicMessageListener implements MessageListener &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage)message; try &#123; System.out.println(\"topic\"+textMessage.getText()); &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 4.2.4配置文件 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:amq=\"http://activemq.apache.org/schema/core\" xmlns:jms=\"http://www.springframework.org/schema/jms\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id=\"targetConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"&gt; &lt;property name=\"brokerURL\" value=\"tcp://120.76.56.183:61616\"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.SingleConnectionFactory\"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name=\"targetConnectionFactory\" ref=\"targetConnectionFactory\"/&gt; &lt;/bean&gt; &lt;!--这个是topic目的地，点对点的 文本信息--&gt; &lt;bean id=\"topicTextDestination\" class=\"org.apache.activemq.command.ActiveMQTopic\"&gt; &lt;constructor-arg value=\"topic_text\"/&gt; &lt;/bean&gt; &lt;!-- 消息监听容器 --&gt; &lt;bean class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\" /&gt; &lt;property name=\"destination\" ref=\"topicTextDestination\" /&gt; &lt;property name=\"messageListener\" ref=\"myTopicMessageListener\" /&gt; &lt;/bean&gt;&lt;/beans&gt;","categories":[{"name":"MQ","slug":"MQ","permalink":"https://aaccompany.github.io/categories/MQ/"}],"tags":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://aaccompany.github.io/tags/消息中间件/"}]}]}