<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000">
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top">
  
  
  <title>Java并发机制的底层实现原理（第二章） | 熊熊的家</title>
  <meta name="description" content="Java并发机制的底层实现原理1.  Java运行过程 Java中所使用的并发机制依赖于JVM的实现和CPU指令，所以需要研究的地方便为这两处 2.多线程重要概念2.1.现代CPU模型一个CPU中会存在多核心，每个核心都会有多个缓存，这么做解决了CPU和主存速度不匹配的问题 CPU在运算的时候会先从高速缓存1-&amp;gt;高速缓存2-&amp;gt;…-&amp;gt;主存获取数据，如果有一处命中则不会继续向下获取数">
<meta name="keywords" content="多线程编程">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发机制的底层实现原理（第二章）">
<meta property="og:url" content="https://aaccompany.github.io/2020/02/03/Java并发机制的底层实现原理/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Java并发机制的底层实现原理1.  Java运行过程 Java中所使用的并发机制依赖于JVM的实现和CPU指令，所以需要研究的地方便为这两处 2.多线程重要概念2.1.现代CPU模型一个CPU中会存在多核心，每个核心都会有多个缓存，这么做解决了CPU和主存速度不匹配的问题 CPU在运算的时候会先从高速缓存1-&amp;gt;高速缓存2-&amp;gt;…-&amp;gt;主存获取数据，如果有一处命中则不会继续向下获取数">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://aaccompany.github.io/2020/02/03/Java并发机制的底层实现原理/1.jpg">
<meta property="og:image" content="https://aaccompany.github.io/2020/02/03/Java并发机制的底层实现原理/2.jpg">
<meta property="og:image" content="https://aaccompany.github.io/2020/02/03/Java并发机制的底层实现原理/4.jpg">
<meta property="og:image" content="https://aaccompany.github.io/2020/02/03/Java并发机制的底层实现原理/3.jpg">
<meta property="og:image" content="https://aaccompany.github.io/2020/02/03/Java并发机制的底层实现原理/5.jpg">
<meta property="og:updated_time" content="2020-02-04T07:53:28.759Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java并发机制的底层实现原理（第二章）">
<meta name="twitter:description" content="Java并发机制的底层实现原理1.  Java运行过程 Java中所使用的并发机制依赖于JVM的实现和CPU指令，所以需要研究的地方便为这两处 2.多线程重要概念2.1.现代CPU模型一个CPU中会存在多核心，每个核心都会有多个缓存，这么做解决了CPU和主存速度不匹配的问题 CPU在运算的时候会先从高速缓存1-&amp;gt;高速缓存2-&amp;gt;…-&amp;gt;主存获取数据，如果有一处命中则不会继续向下获取数">
<meta name="twitter:image" content="https://aaccompany.github.io/2020/02/03/Java并发机制的底层实现原理/1.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://aaccompany.github.io/2020/02/03/Java并发机制的底层实现原理/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  <link rel="stylesheet" href="/css/style.css">
  
  
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitment@0.0.3/style/default.min.css">
  
  
  
</head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/Aaccompany" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Accompany</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Java Developer &amp; Accompany my lover</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/Aaccompany" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>君子生非异也，善假于物也。<br> 故不积跬步，无以至千里；不积小流，无以成江海。 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java集合类/">Java集合类</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MQ/">MQ</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端框架/">后端框架</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程编程系列/">多线程编程系列</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂谈/">杂谈</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Map集合/">Map集合</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂谈/">杂谈</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息中间件/">消息中间件</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/重走系列/">重走系列</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/Map集合/" style="font-size: 13px;">Map集合</a> <a href="/tags/spring/" style="font-size: 13.33px;">spring</a> <a href="/tags/多线程编程/" style="font-size: 14px;">多线程编程</a> <a href="/tags/杂谈/" style="font-size: 13px;">杂谈</a> <a href="/tags/消息中间件/" style="font-size: 13.67px;">消息中间件</a> <a href="/tags/重走系列/" style="font-size: 13.33px;">重走系列</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a><span class="archive-list-count">6</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/多线程编程系列/">多线程编程系列</a>
              </p>
              <p class="item-title">
                <a href="/2020/02/12/Java中的线程池/" class="title">Java中的线程池（第九章）</a>
              </p>
              <p class="item-date">
                <time datetime="2020-02-11T16:00:00.000Z" itemprop="datePublished">2020-02-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java集合类/">Java集合类</a>
              </p>
              <p class="item-title">
                <a href="/2020/02/05/HashMap解析/" class="title">HashMap 解析</a>
              </p>
              <p class="item-date">
                <time datetime="2020-02-04T16:00:00.000Z" itemprop="datePublished">2020-02-05</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/多线程编程系列/">多线程编程系列</a>
              </p>
              <p class="item-title">
                <a href="/2020/02/03/Java并发容器和框架/" class="title">Java并发容器和框架（第六章）</a>
              </p>
              <p class="item-date">
                <time datetime="2020-02-02T16:00:00.000Z" itemprop="datePublished">2020-02-03</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/多线程编程系列/">多线程编程系列</a>
              </p>
              <p class="item-title">
                <a href="/2020/02/03/Java并发机制的底层实现原理/" class="title">Java并发机制的底层实现原理（第二章）</a>
              </p>
              <p class="item-date">
                <time datetime="2020-02-02T16:00:00.000Z" itemprop="datePublished">2020-02-03</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/多线程编程系列/">多线程编程系列</a>
              </p>
              <p class="item-title">
                <a href="/2020/01/31/并发编程的挑战/" class="title">并发编程的挑战（第一章）</a>
              </p>
              <p class="item-date">
                <time datetime="2020-01-30T16:00:00.000Z" itemprop="datePublished">2020-01-31</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-Java并发机制的底层实现原理" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Java并发机制的底层实现原理（第二章）
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2020/02/03/Java并发机制的底层实现原理/" class="article-date">
	  <time datetime="2020-02-02T16:00:00.000Z" itemprop="datePublished">2020-02-03</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/多线程编程系列/">多线程编程系列</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/多线程编程/">多线程编程</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2020/02/03/Java并发机制的底层实现原理/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 6.1k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 22(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="Java并发机制的底层实现原理"><a href="#Java并发机制的底层实现原理" class="headerlink" title="Java并发机制的底层实现原理"></a>Java并发机制的底层实现原理</h1><h2 id="1-Java运行过程"><a href="#1-Java运行过程" class="headerlink" title="1.  Java运行过程"></a>1.  Java运行过程</h2><p><img src="/2020/02/03/Java并发机制的底层实现原理/1.jpg" alt></p>
<p>Java中所使用的并发机制依赖于<code>JVM</code>的实现和CPU指令，所以需要研究的地方便为这两处</p>
<h2 id="2-多线程重要概念"><a href="#2-多线程重要概念" class="headerlink" title="2.多线程重要概念"></a>2.多线程重要概念</h2><h3 id="2-1-现代CPU模型"><a href="#2-1-现代CPU模型" class="headerlink" title="2.1.现代CPU模型"></a>2.1.现代CPU模型</h3><p>一个CPU中会存在多核心，每个核心都会有多个缓存，这么做解决了CPU和主存速度不匹配的问题</p>
<p>CPU在运算的时候会先从<code>高速缓存1</code>-&gt;<code>高速缓存2</code>-&gt;…-&gt;<code>主存</code>获取数据，如果有一处命中则不会继续向下获取数据</p>
<p><img src="/2020/02/03/Java并发机制的底层实现原理/2.jpg" alt></p>
<h3 id="2-2-多线程三大特性"><a href="#2-2-多线程三大特性" class="headerlink" title="2.2.多线程三大特性"></a>2.2.多线程三大特性</h3><p>多线程编程中如果这三个性质没有得到保证就容易出现安全问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可见性：一个线程中修改了某个值，在其他线程可以察觉最新值</span><br><span class="line">原子性：一个操作或者多个操作，要么一起执行要么都不执行，原子性就像数据库事务一样像一个团队共同生死</span><br><span class="line">有序性：程序执行的顺序于代码顺序一致</span><br></pre></td></tr></table></figure>

<h3 id="2-2-CPU术语的定义"><a href="#2-2-CPU术语的定义" class="headerlink" title="2.2. CPU术语的定义"></a>2.2. CPU术语的定义</h3><table>
<thead>
<tr>
<th align="center">术语</th>
<th align="center">英文单词</th>
<th align="left">术语描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">内存屏障</td>
<td align="center">memory barriers</td>
<td align="left">一组处理器指令，用于实现对内存操作的顺序限制（顺序性）</td>
</tr>
<tr>
<td align="center">缓冲行</td>
<td align="center">cache line</td>
<td align="left">CPU高速缓存中可以分配的最小存储单位。<br>处理器在填写缓存行时，会加载整个缓存行。<br>现代CPU需要执行几百次CPU指令</td>
</tr>
<tr>
<td align="center">原子操作</td>
<td align="center">atomic operations</td>
<td align="left">不可中断的一个或一系列操作</td>
</tr>
<tr>
<td align="center">缓冲行填充</td>
<td align="center">cache line fill</td>
<td align="left">当处理器识别到从内存中去读操作数是可缓存的<br>处理器读取整个高速缓存行到适应的缓存（<code>L1、L2、L3</code>到所有）</td>
</tr>
<tr>
<td align="center">缓存命中</td>
<td align="center">cache hit</td>
<td align="left">如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时<br>处理器从缓存中获取数据而不是从主存中获取数据</td>
</tr>
<tr>
<td align="center">写命中</td>
<td align="center">write hit</td>
<td align="left">当处理器将操作数写回到一个内存缓存区域时，它首先回检查这个缓存的内存地址<br>是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存<br>而不是写回到内存，这个操作被称为写命中</td>
</tr>
<tr>
<td align="center">写缺失</td>
<td align="center">write misses the cache</td>
<td align="left">一个有效的缓存行被写入到了不存在的内存区域</td>
</tr>
<tr>
<td align="center">比较并交换</td>
<td align="center">compare and swap</td>
<td align="left">CAS操作需要输入两个数值，一个是旧值（期望操作前的值）和一个新值<br>在操作期间先比较旧值有没有发生变化，如果没有发生变化则更新成功或者失败</td>
</tr>
<tr>
<td align="center">CPU流水线</td>
<td align="center">CPU pipeline</td>
<td align="left">指令的执行，需要取址、执行、IO等，这三个操作分别在不同CPU内部结构中执行<br>但是为了提高CPU的吞吐量，会将这些操作异步执行</td>
</tr>
<tr>
<td align="center">内存顺序冲突</td>
<td align="center">Memory order violation</td>
<td align="left">内存顺序冲突一般是由假共享起因的，假共享是指多个CPU同一时刻修改同一个缓存的不同部分<br>当出现了这个冲突的时候CPU必须清空CPU流水线</td>
</tr>
</tbody></table>
<h2 id="3-Volatile"><a href="#3-Volatile" class="headerlink" title="3. Volatile"></a>3. Volatile</h2><p>多线程编程中Volatile和Synchronized都是常见修饰符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">环境：</span><br><span class="line">	存在两个线程A、B分别在不同的核心中运行</span><br><span class="line">	存在一个共享变量var</span><br><span class="line">线程A					线程B</span><br><span class="line">	- 读取var			-修改var</span><br><span class="line">	- 进行操作</span><br><span class="line">	- 读取var</span><br><span class="line">	</span><br><span class="line">问题：</span><br><span class="line">线程A再第二次读取var的变量并不是最新的值，而是脏数据</span><br><span class="line">因为线程B再修改完数据之后只是将数据写入到了CPU的高速缓存中，并没有写到主存</span><br><span class="line">线程A再读取值的时候也只会读取到高速缓存的值</span><br><span class="line">导致线程A读取到的值是脏数据</span><br></pre></td></tr></table></figure>

<p>Volatile修饰符可以保证在<code>多处理器</code>环境下变量可见性</p>
<h3 id="3-1-volatile的定义与实现原理"><a href="#3-1-volatile的定义与实现原理" class="headerlink" title="3.1. volatile的定义与实现原理"></a>3.1. volatile的定义与实现原理</h3><p><code>Java编程语言允许线程访问共享变量，为了确保共享变量能够被准确和一直地更新，线程应该采用排他锁单独获取这个变量</code></p>
<p><code>是不是能够通过这个原理联想到在分布式环境下双缓冲的问题?</code></p>
<p>Java语言提供了volatile在一些情况下会比加锁效果好，如果一个字段被修饰为volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的</p>
<p>有volatile修饰的变量在进行写操作的时候，会在汇编指令中加入<code>lock</code>的标识，当<strong>多核处理器</strong>发现<code>lock</code>标识会做两件事情</p>
<ul>
<li>将当前处理器缓存行写入到主存中</li>
<li>上面的写入操作会使在其他处理器核心中缓存该内存地址的数据无效</li>
</ul>
<p>为了解决CPU与主存的速度不匹配造成的处理速度低下的问题，处理器将不直接与主存进行通信，而是通过高速缓存。</p>
<p>这就会在多核处理器中出现脏数据，因为每个核心都会有数据备份，当有一个核心修改了数据，其他核心数据并未读取最新的数据造成。</p>
<p>为了保证各个缓存数据一致性，会实现<strong>缓存一致性协议<code>MESI</code></strong>，每个处理器通过嗅探在总线上传播的数据来检查自己缓存是否已经过期，如果发现缓存过期，那么就会标识当前处理器的缓存为无效状态，当处理再次获取该缓存的时候会跳过缓存从主存获取最新值，并且修改缓存值。</p>
<h3 id="3-2-volatile的两条实现原则"><a href="#3-2-volatile的两条实现原则" class="headerlink" title="3.2. volatile的两条实现原则"></a>3.2. volatile的两条实现原则</h3><ul>
<li>Lock前缀指令会引起处理器将数据写回主存</li>
<li>一个处理器在将缓存写回主存，会导致其他处理器对应内存地址的缓存失效</li>
</ul>
<h3 id="3-3-volatile优化"><a href="#3-3-volatile优化" class="headerlink" title="3.3. volatile优化"></a>3.3. volatile优化</h3><p>从<code>3.2</code>中可以发现volatile 在写的过程中会导致其他处理器对应内存地址的缓存失效</p>
<p>所有多线程编程大师<code>Doug Lea</code>在<code>LinkedTransferQueue</code>类中，对头节点和尾节点进行字节填充</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列头节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">final</span> PaddedAtomicReference&lt;QNode&gt; head;</span><br><span class="line"><span class="comment">//队列尾节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">final</span> PaddedAtomicReference&lt;QNode&gt; tail;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddedAtomicReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AtomicReference</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用15个四节点的对象填充</span></span><br><span class="line">    Object p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pa,pb,pc,pd,pe;</span><br><span class="line">    PaddedAtomicReference(T r)&#123;</span><br><span class="line">        <span class="keyword">super</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么在对象中追加字节能够优化性能？</p>
<p>在<code>LinkedTransferQueue</code>中，内部类<code>PaddedAtomicReference</code>扩展到了(15+1)*4字节也就是64字节</p>
<p>现代CPU中高速缓存的缓存行是64字节宽，不支持部分填充缓存行，这意味着，如果队列的头节点和尾节点都不足64字节，处理器会将他们读取到同一个缓存行中，在多个处理器核心都会缓存这个head、tail。如果其中一个处理器核心修改head的话，根据缓存一致性协议，其他处理器核心的该缓存行将失效，导致无法在高速缓存中获取尾节点数据，需要从主存中获取大大的降低了操作速度。</p>
<p>在队列中，入列和出列操作都很频繁，这就导致在多线程环境下会存在很多高速缓存失效的情况，所以<code>Doug lea</code>使用追加头节点和尾节点到64字节方式来填充高速缓存，避免头节点和尾节点填充到同一个高速缓存行，使头、尾节点在修改时不会相互锁定，这将大大提高在多线程环境下入列出列操作速度。</p>
<h4 id="3-3-1-是不是什么时候都可以采用追加字节提高volatile效率？"><a href="#3-3-1-是不是什么时候都可以采用追加字节提高volatile效率？" class="headerlink" title="3.3.1.是不是什么时候都可以采用追加字节提高volatile效率？"></a>3.3.1.是不是什么时候都可以采用追加字节提高volatile效率？</h4><p>并不是在所有的场合都适用追加字节来提高volatile的效率，在一下两个场景时不能使用</p>
<ul>
<li><strong>缓存行为32字节宽的处理器：</strong>如<code>P6系列和奔腾处理器</code>，它们的高速缓存行为32字节宽</li>
<li><strong>共享变量并不会被频繁的写：</strong>使用追加字节的方式采用空间换时间，如果不经常写的变量一般是不会被锁住的，所以也没有必要进行字节追加</li>
</ul>
<p>在<code>JDK7</code>以上追加字节的方式会无效，因为<code>JVM</code>会智能淘汰或重新排列无用字段，所以需要使用其他方式来进行字段追加</p>
<h2 id="4-Synchronized"><a href="#4-Synchronized" class="headerlink" title="4.  Synchronized"></a>4.  Synchronized</h2><h3 id="4-1-什么是Synchronized？"><a href="#4-1-什么是Synchronized？" class="headerlink" title="4.1. 什么是Synchronized？"></a>4.1. 什么是Synchronized？</h3><p>synchronized在1.6之前被称为重量级锁，性能低下。</p>
<p>1.6之后synchronized涅槃重生，进行了大量优化。提高了锁在释放和获取的效率</p>
<ul>
<li>进行锁优化，例如<strong>自旋锁、适应自旋锁、锁消除、锁粗化</strong></li>
<li>例如引入<strong>无锁、偏向锁、轻量级锁 ，重量级锁</strong>。增加锁升级的机制</li>
</ul>
<h3 id="4-2-锁优化"><a href="#4-2-锁优化" class="headerlink" title="4.2.锁优化"></a>4.2.锁优化</h3><p>观察下面的锁优化其实可以很容易发现，主要目的减少线程上下文切换次数，提高系统运行速度</p>
<h4 id="4-2-1-自旋锁"><a href="#4-2-1-自旋锁" class="headerlink" title="4.2.1.自旋锁"></a>4.2.1.自旋锁</h4><p>线程在获取锁的过程中，并不会获取不到锁就直接将当前线程加入同步队列，而是会在获取锁处循环获取。</p>
<p>因为在一般的同步代码块中，任务量少，执行时间很快，没有必要将线程加入同步队列，而是在锁处循环获取锁，其他线程能够很快的将锁释放。（默认自旋次数为10次）</p>
<p>好处：因为同步代码块任务量少，执行时间短，能够很快释放锁，其他线程也不需要加入到同步队列，减少了线程上下文切换，加快了线程运行时间</p>
<p>坏处：循环获取锁的弊端很明显，就是需要占用CPU运算资源，做无用的循环获取锁，如果获取不到则一直循环，浪费运输资源。所以同步代码块任务量大时使用自旋锁将降低系统运行效率</p>
<h4 id="4-2-2-自适应自旋锁"><a href="#4-2-2-自适应自旋锁" class="headerlink" title="4.2.2.自适应自旋锁"></a>4.2.2.自适应自旋锁</h4><p>自适应自旋锁在自旋锁的基础上做了增强。</p>
<p>在Java 6 中加入了自适应自旋锁，该锁不同于自旋锁的地方为，该锁并非采用固定的自旋次数，而是会自动感知上次自旋时间以及锁的拥有者的状态来做。如果上次再很短的时间自旋获取锁，那么可以认为这次也能够在很短时间的获取到锁，那么就会允许它增加自旋次数。相反如果上次自旋没有获取到锁或者是很长时间才获取到锁，那么再下次获取锁的时候就会放弃自旋或者降低自旋次数</p>
<p>这样做的好处是避免因为自旋而浪费CPU的运算资源</p>
<h4 id="4-2-3-锁消除"><a href="#4-2-3-锁消除" class="headerlink" title="4.2.3.锁消除"></a>4.2.3.锁消除</h4><p>多线程编程中，JVM会感知是否存在锁竞争的现象，如果不存在锁竞争的现象，那么将会撤销锁</p>
<p>锁消除的依据是逃逸分析的数据支持。如果不存在竞争，那么为什么还需要加锁，所以锁消除能够去掉没有必要请求锁和释放锁的时间。</p>
<p>但是多线程编程不是程序员编写的么？那为什么会出现不存在锁竞争但是还加锁的操作呢？是程序员有问题么？</p>
<p>系统开发的过程中，不是说我们这样写就不会出现这个现象，它可能会因为我们不小心调用了<code>JDK</code>内置类或者第三方类库的时候出现的加锁操作</p>
<p>例如String Buffer、Vector、Hash Table等等，他们在一些方法上都会存在加锁操作，但是如果在单线程，或者变量未逸出的时候，这些加锁操作是否有必要？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">vectorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">            vector.add(i + <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(vector);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>观察一下上方代码可以发现，vector变量一直在方法内，并没有逸出操作。所以它是不会出现安全问题，但是<code>vector.add()</code>会出现加锁操作，JVM检查到没有变量逸出，这时候就会锁消除</p>
<h4 id="4-2-4-锁粗化"><a href="#4-2-4-锁粗化" class="headerlink" title="4.2.4.锁粗化"></a>4.2.4.锁粗化</h4><p>多线程编程中，加锁操作一般都是在涉及到共享变量的时候才存在，而且在编程的过程中也会刻意的将同步代码块范围弄的小点，但是如果在代码中连续获取同一把锁，那么JVM会将锁的范围扩大，避免刚释放锁没有过多久又要申请锁的问题。</p>
<h3 id="4-3-Synchronized以什么做为锁？"><a href="#4-3-Synchronized以什么做为锁？" class="headerlink" title="4.3. Synchronized以什么做为锁？"></a>4.3. Synchronized以什么做为锁？</h3><p>在Java中所有对象都可以作为锁对象，具体表现为3类</p>
<ul>
<li>对于普通同步方法，锁对象为当前实例对象</li>
<li>对于静态同步方法，锁对象为当前实例的类对象</li>
<li>对于同步方法块，<code>synchronized(lockObject)</code>锁对象为配置的对象</li>
</ul>
<h3 id="4-4-Synchronized在JVM如何体现？"><a href="#4-4-Synchronized在JVM如何体现？" class="headerlink" title="4.4. Synchronized在JVM如何体现？"></a>4.4. Synchronized在JVM如何体现？</h3><p>JVM基于进入和退出 <strong>Monitor</strong>对象来实现<strong>方法同步</strong>和<strong>代码块同步</strong>，但是两者具体实现不一样。代码块的同步实现是通过<code>monitorenter</code>和<code>monitorexit</code>来实现。方法同步时使用另外一种方式实现，但是JVM规范中没有详细说明。但是同步方法也可以使用两个指令来实现同步。</p>
<p><code>monitorenter</code>：在代码编译后由JVM插入到同步方法前</p>
<p><code>monitorexit</code>：在同步方法结束处和在异常结束处添加该指令。在异常处添加指令是为了避免无法释放锁，所以查看生成字节码文件会发现存在两个<code>monitorexit</code>指令</p>
<h3 id="4-5-Synchronized同步过程"><a href="#4-5-Synchronized同步过程" class="headerlink" title="4.5. Synchronized同步过程"></a>4.5. Synchronized同步过程</h3><p>每个对象在对象头都会有<code>monitor</code>的标识，当执行到同步方法的时候，当前线程会尝试获取对应对象的<code>monitor</code>，当获取到了则执行同步代码，否则将进入同步队列</p>
<h4 id="4-5-1-对象头"><a href="#4-5-1-对象头" class="headerlink" title="4.5.1.对象头"></a>4.5.1.对象头</h4><p>synchronized使用的锁是存在Java对象头的。如果Java对象为数组则虚拟机用3个字宽（Word）存储对象头，如果Java对象为非数组则用2个字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32 bit</p>
<p>Java对象对数据结构</p>
<table>
<thead>
<tr>
<th align="center">长度</th>
<th align="center">内容</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">32/64 bit</td>
<td align="center">Mark Word</td>
<td align="center">存储对象的HashCode和锁信息等</td>
</tr>
<tr>
<td align="center">32/64 bit</td>
<td align="center">Class Metadata Address</td>
<td align="center">存储对象的类对象指针</td>
</tr>
<tr>
<td align="center">32/64 bit</td>
<td align="center">Array Length</td>
<td align="center">数组的长度（对象为数组时）</td>
</tr>
</tbody></table>
<p>Java对象头Mark Word存储结构以及变化过程</p>
<table>
<thead>
<tr>
<th align="center">锁状态</th>
<th align="center">25 bit</th>
<th align="center">4 bit</th>
<th align="center">1 bit 是否为偏向锁</th>
<th align="center">2 bit 锁标志</th>
</tr>
</thead>
<tbody><tr>
<td align="center">无锁状态</td>
<td align="center">对象的HashCode</td>
<td align="center">对象的分代年龄（最大15岁）</td>
<td align="center">0</td>
<td align="center">01</td>
</tr>
<tr>
<td align="center">偏向锁</td>
<td align="center">线程ID( 占两部分Epoch</td>
<td align="center">Epoch)对象分代年龄</td>
<td align="center">1</td>
<td align="center">01</td>
</tr>
<tr>
<td align="center">轻量级锁</td>
<td align="center">指向栈中锁记录指针</td>
<td align="center">指向栈中锁记录指针</td>
<td align="center">指向栈中锁记录指针</td>
<td align="center">00</td>
</tr>
<tr>
<td align="center">重量级锁</td>
<td align="center">执行互斥量的指针</td>
<td align="center">执行互斥量的指针</td>
<td align="center">执行互斥量的指针</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">GC标记</td>
<td align="center">空</td>
<td align="center">空</td>
<td align="center">空</td>
<td align="center">11</td>
</tr>
</tbody></table>
<p>这个时候观察表格可以发现，为什么需要1 bit来描述是否为偏向锁，因为对象头的状态有5种，但是锁标记位只有2 bit导致不够描述，所以添加多一个bit作为说明</p>
<h3 id="4-6-锁的升级与对比"><a href="#4-6-锁的升级与对比" class="headerlink" title="4.6.锁的升级与对比"></a>4.6.锁的升级与对比</h3><p>锁会锁着锁的竞争激烈程度进行升级，但是不能降级，这样做的目的是为了提高获取锁和释放锁的效率</p>
<h4 id="4-6-1-偏向锁"><a href="#4-6-1-偏向锁" class="headerlink" title="4.6.1.偏向锁"></a>4.6.1.偏向锁</h4><p>偏向锁顾名思义，偏向锁会偏向一个线程。</p>
<p>在大多数情况下，锁不仅不存在多线程竞争，而且总是同一个线程进入同步代码块，如果不断的进行获取锁释放锁效率将降低很多</p>
<p>所以偏向锁会记录第一次获取锁的线程ID，并且在这个线程再次进入的时候，直接放行，加快了进入同步代码块的速度</p>
<h5 id="4-6-1-1-偏向锁的获取"><a href="#4-6-1-1-偏向锁的获取" class="headerlink" title="4.6.1.1.偏向锁的获取"></a>4.6.1.1.偏向锁的获取</h5><p><img src="/2020/02/03/Java并发机制的底层实现原理/4.jpg" alt></p>
<h5 id="4-6-1-2-偏向锁的释放"><a href="#4-6-1-2-偏向锁的释放" class="headerlink" title="4.6.1.2.偏向锁的释放"></a>4.6.1.2.偏向锁的释放</h5><p>偏向锁采用了一种等到出现多线程竞争的情况才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</p>
<p>偏向锁的撤销，需要等待全局安全点（也就是GC点）。</p>
<p>偏向锁的过程</p>
<ul>
<li>暂停拥有偏向锁的线程</li>
<li>检查拥有偏向锁的线程是否存活，如果该线程不处于活动状态，则将该对象头设置成无锁状态</li>
<li>如果线程处于活动状态，拥有偏向锁的线程栈会被执行，遍历变相对象的锁记录，栈中的锁记录和对象头的Mark Word 要么重新偏向其他线程，要么恢复到无锁状态或标记对象不适合作为偏向锁，最后唤醒暂停的线程</li>
</ul>
<h5 id="4-6-1-3-偏向锁流程图"><a href="#4-6-1-3-偏向锁流程图" class="headerlink" title="4.6.1.3.偏向锁流程图"></a>4.6.1.3.偏向锁流程图</h5><p><img src="/2020/02/03/Java并发机制的底层实现原理/3.jpg" alt></p>
<h5 id="4-6-1-4-关闭偏向锁"><a href="#4-6-1-4-关闭偏向锁" class="headerlink" title="4.6.1.4.关闭偏向锁"></a>4.6.1.4.关闭偏向锁</h5><p>如果系统存在很明显的锁竞争关系，那么可以关闭偏向锁，提高系统的允许速度。减少锁升级的过程</p>
<p>Java 6后默认开启偏向锁，但是它是存在启动延迟，也就是说在系统启动后X秒才开启偏向锁，如果又必要的话可以调整延迟时间，<code>-XX:BiasedLockingStartupDelay=0</code>。</p>
<p>如果系统对锁都存在竞争关系，那么可以关闭偏向锁<code>-XX:-UseBiasedLocking=flase</code>，那么系统将直接进入轻量级锁状态</p>
<h4 id="4-6-2-轻量级锁"><a href="#4-6-2-轻量级锁" class="headerlink" title="4.6.2.轻量级锁"></a>4.6.2.轻量级锁</h4><p>会使用锁优化中的自适应锁自旋</p>
<h5 id="4-6-2-1-轻量级锁的获取"><a href="#4-6-2-1-轻量级锁的获取" class="headerlink" title="4.6.2.1.轻量级锁的获取"></a>4.6.2.1.轻量级锁的获取</h5><ul>
<li>线程栈中创建存储锁记录空间</li>
<li>将对象头中的Mark Word复制到锁记录空间（这个过程官方称之为Displaced Mark Word)</li>
<li>使用<code>CAS</code>替换对象头中Mark Word指向线程栈中锁记录，成功则获取锁，失败则<strong>自旋</strong></li>
</ul>
<h5 id="4-6-2-2-轻量级锁的释放"><a href="#4-6-2-2-轻量级锁的释放" class="headerlink" title="4.6.2.2.轻量级锁的释放"></a>4.6.2.2.轻量级锁的释放</h5><ul>
<li>使用<code>CAS</code>将锁记录中的Displaced Mark Word复制回对象头中Mark Word</li>
<li>如果成功则说明释放锁成功</li>
<li>失败则说明发生锁竞争，升级为重量级锁</li>
</ul>
<h5 id="4-6-2-3-轻量级锁膨胀流程图"><a href="#4-6-2-3-轻量级锁膨胀流程图" class="headerlink" title="4.6.2.3.轻量级锁膨胀流程图"></a>4.6.2.3.轻量级锁膨胀流程图</h5><p>因为自旋会消耗CPU的运算资源，为了避免无用的自旋，一旦升级为重量级锁，则不会降级了。当锁处于这个重量级锁的状态，其他线程试图获取锁时都会阻塞，当持有锁的线程释放锁之后会唤醒所有被阻塞的线程，接下来则会进行锁竞争的过程。</p>
<p><img src="/2020/02/03/Java并发机制的底层实现原理/5.jpg" alt></p>
<h4 id="4-6-3-不同锁的对比"><a href="#4-6-3-不同锁的对比" class="headerlink" title="4.6.3.不同锁的对比"></a>4.6.3.不同锁的对比</h4><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗<br>和非同步方法仅仅存在纳秒级的差距</td>
<td>如果线程间存在锁竞争<br>会带来额外的锁撤销消耗</td>
<td>适用于只有一个线程访问同步代码块<br>没有过多的锁竞争</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞<br>提高了程序响应速度</td>
<td>始终得不到锁的线程将不断地自旋浪费CPU运算</td>
<td>追求响应时间<br>同步代码块执行时间很快<br>适用于存在少量锁竞争场景</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程不会自旋，减少CPU的浪费</td>
<td>不断的进行请求锁和释放锁<br>存在大量的线程上下文切换的消耗</td>
<td>执行速度最慢，因为相比于轻量级锁<br>多了很多线程上下文切换的时间<br>适用于锁竞争激烈的场景</td>
</tr>
</tbody></table>
<h2 id="5-原子操作的实现原理"><a href="#5-原子操作的实现原理" class="headerlink" title="5.原子操作的实现原理"></a>5.原子操作的实现原理</h2><p>原子（atomic）本意是“不可进一步分割的最小粒子”，而原子操作（atomic operation)意为“不可以被中断的一个或一系列的操作”</p>
<h3 id="5-1-处理器如何实现原子操作"><a href="#5-1-处理器如何实现原子操作" class="headerlink" title="5.1.处理器如何实现原子操作"></a>5.1.处理器如何实现原子操作</h3><ul>
<li>解决方案有两种：<ul>
<li>总线加锁：对总线加锁，在写的过程中，其他CPU都无法访问主存</li>
<li>缓存加锁：对缓存行加锁，在写的过程中会锁住该缓存行，在其他CPU中该缓存行失效，重新从主存获取</li>
</ul>
</li>
<li>处理器会自动保证基本的内存操作的原子性</li>
<li><strong>两种情况下处理器不会适用缓存行锁定</strong><ul>
<li>数据跨多个缓存行，CPU会采用锁总线操作；数据不能被加载进高速缓存</li>
<li>处理器不支持锁缓存行</li>
</ul>
</li>
</ul>
<h3 id="5-2-Java如何实现原子操作"><a href="#5-2-Java如何实现原子操作" class="headerlink" title="5.2.Java如何实现原子操作"></a>5.2.Java如何实现原子操作</h3><p>Java中很多操作都非原子操作，例如最常见的<code>i++</code>就是一个非原子的操作</p>
<p>Java中可以采用<code>CAS</code>和加锁操作来完成原子操作</p>
<h4 id="5-2-1-使用循环CAS实现原子操作"><a href="#5-2-1-使用循环CAS实现原子操作" class="headerlink" title="5.2.1.使用循环CAS实现原子操作"></a>5.2.1.使用循环CAS实现原子操作</h4><p>JVM中的CAS操作是底层使用了处理器提供的CMPXCHG指令实现。</p>
<p>自旋CAS实现的基本思路循环CAS操作直到完成为止</p>
<blockquote>
<p>从JDK1.5开始，Java提供的并发包提供了一些类来支撑某些原子操作，如AtomicBoolean(用原子方式更新Boolean)，AtomicInteger（用原子操作更新int值）等等</p>
</blockquote>
<p>下面操作即为实现CAS线程安全的计数器方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicI = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Counter counter = <span class="keyword">new</span> Counter();</span><br><span class="line">        List&lt;Thread&gt; threadList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//创建100个线程 每个线程任务为计数自增1000次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; <span class="number">1000</span>; i1++) &#123;</span><br><span class="line">                        counter.safeCount();</span><br><span class="line">                        counter.count();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threadList.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开启100个线程</span></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//main线程等待100个线程执行完毕</span></span><br><span class="line">        <span class="keyword">for</span> (Thread thread : threadList) &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程安全计数器:"</span>+counter.atomicI.get());</span><br><span class="line">        System.out.println(<span class="string">"非线程安全计数器:"</span>+counter.i);</span><br><span class="line">        System.out.println(<span class="string">"执行耗时:"</span>+(System.currentTimeMillis()-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用CAS的线程安全计数器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">safeCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//自旋CAS操作，减少线程上下文切换</span></span><br><span class="line">        <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">            <span class="comment">//获取最新值</span></span><br><span class="line">            <span class="keyword">int</span> i = atomicI.get();</span><br><span class="line">            <span class="comment">//使用CAS替换值，如果生成则退出</span></span><br><span class="line">            <span class="keyword">boolean</span> suc = atomicI.compareAndSet(i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (suc)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非线程安全计数器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-2-使用CAS实现原子操作的三大问题"><a href="#5-2-2-使用CAS实现原子操作的三大问题" class="headerlink" title="5.2.2.使用CAS实现原子操作的三大问题"></a>5.2.2.使用CAS实现原子操作的三大问题</h4><ul>
<li>ABA问题<ul>
<li>在CAS的原理上，是检查旧值和内存中的值是否一样，如果一样就替换为新值。这就会出现一个BUG，如果在更新的过程中有人修改了值，最后又变成了旧值，那么它在检查的时候CAS会发现值未发现改变，然后替换。</li>
<li>这个概念可能会很抽象，并且不好理解有啥危害。个人理解，简单的说就是狸猫换太子</li>
<li>举个例子：<ul>
<li>小A有一个满的水，小A离开了房间</li>
<li>小B看到房间有杯水，喝完了然后倒回去</li>
<li>小A回来看到水还是水，然后继续喝了</li>
</ul>
</li>
<li>解决方案：<ul>
<li>每次修改都添加版本号，就像1A-&gt;2B-&gt;3A，这样就能够避免出现ABA的问题</li>
<li>在Java中提供了AtomicStampedReference类来实现</li>
</ul>
</li>
</ul>
</li>
<li>循环时间长开销大<ul>
<li>通过<code>5.2.1</code>的代码可以发现有个<code>for(;;)</code>操作，不断的循环，做无用的运算</li>
</ul>
</li>
<li>只能保证一个变量进行原子操作<ul>
<li>如果有多个变量需要进行CAS原子操作，可以将多个变量合成一个Java对象，Java提供了AtomicReference来实现对象的原子操作</li>
</ul>
</li>
</ul>
<h3 id="5-3-Java使用锁机制来完成原子操作"><a href="#5-3-Java使用锁机制来完成原子操作" class="headerlink" title="5.3.Java使用锁机制来完成原子操作"></a>5.3.Java使用锁机制来完成原子操作</h3><p>锁机制保证了只有获取锁的线程才能进入同步代码块。JVM内部实现了很多锁机制，有偏向锁、轻量级锁、重量级锁（互斥锁），JVM中锁机制都是通过CAS来完成获取锁和释放锁</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ul>
<li>方腾飞：《Java并发编程的艺术》 </li>
</ul>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://aaccompany.github.io/2020/02/03/Java并发机制的底层实现原理/" title="Java并发机制的底层实现原理（第二章）" target="_blank" rel="external">https://aaccompany.github.io/2020/02/03/Java并发机制的底层实现原理/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/Aaccompany" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/Aaccompany" target="_blank"><span class="text-dark">Accompany</span><small class="ml-1x">Java Developer &amp; Accompany my lover</small></a></h3>
        <div>这个人很赖，还没有写什么信息。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	

    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2020/02/03/Java并发容器和框架/" title="Java并发容器和框架（第六章）"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2020/01/31/并发编程的挑战/" title="并发编程的挑战（第一章）"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/Aaccompany" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
		<p>风雨里做个大人，阳光下做个孩子</p>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script src="/js/plugin.min.js"></script>
<script src="/js/application.js"></script>

    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>


    <script>
(function ($) {
    $('.search-form').on('submit', function (e) {
        var keyword = $('.search-form-input[name="wd"]').val();
        window.location = 'https://www.baidu.com/s?wd=site:aaccompany.github.io ' + keyword;
        return false;
    });
})(jQuery);
</script>




   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
<script src="//cdn.jsdelivr.net/npm/gitment@0.0.3/dist/gitment.browser.min.js"></script>
<script>
var gitment = new Gitment({
  // id默认为当前页面url，如果url后带参数或锚点，gitment要重新初始化
  // https://github.com/imsun/gitment/issues/55
  // 解决方案：id:window.location.pathname,或者将id设置为当前页面标题
  id: 'Java并发机制的底层实现原理（第二章）', 
  owner: 'Aaccompany', // 可以是你的GitHub用户名，也可以是github id
  repo: 'git@github.com:Aaccompany/Aaccompany.github.io.git',
  oauth: {
    client_id: '96da4c9e4c6434dd4399',
    client_secret: '4edee086fa4203e9f67a9d19155c9ec5d803ca88',
  }
})
gitment.render('comments')
</script>









</body>
</html>