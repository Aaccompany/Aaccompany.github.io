<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000">
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top">
  
  
  <title>重走spring框架 IOC部分 | 熊熊的家</title>
  <meta name="description" content="Spring框架学习过程中的问题：  为什么在使用JDBC使用的是Class.forName(&amp;quot;DriverName&amp;quot;) 而不是 DriverManager.register(new Driver)？ 工厂模式的好处是什么？ 工厂模式下创建的Bean对象应该为多例还是单例？ 什么时候用多例什么时候用单例？ Spring是如何做到立即加载的？ Spring核心容器下两个顶级接口的">
<meta name="keywords" content="spring,重走系列">
<meta property="og:type" content="article">
<meta property="og:title" content="重走spring框架 IOC部分">
<meta property="og:url" content="https://aaccompany.github.io/2019/07/14/重走spring框架(IOC部分)/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Spring框架学习过程中的问题：  为什么在使用JDBC使用的是Class.forName(&amp;quot;DriverName&amp;quot;) 而不是 DriverManager.register(new Driver)？ 工厂模式的好处是什么？ 工厂模式下创建的Bean对象应该为多例还是单例？ 什么时候用多例什么时候用单例？ Spring是如何做到立即加载的？ Spring核心容器下两个顶级接口的">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://aaccompany.github.io/2019/07/14/重走spring框架(IOC部分)/spring-overview.png">
<meta property="og:image" content="https://aaccompany.github.io/2019/07/14/重走spring框架(IOC部分)/%E9%87%8D%E8%B5%B0spring%E6%A1%86%E6%9E%B6%5C1.jpg">
<meta property="og:image" content="https://aaccompany.github.io/2019/07/14/重走spring框架(IOC部分)/%E9%87%8D%E8%B5%B0spring%E6%A1%86%E6%9E%B6%5C2.jpg">
<meta property="og:image" content="https://aaccompany.github.io/2019/07/14/重走spring框架(IOC部分)/%E9%87%8D%E8%B5%B0spring%E6%A1%86%E6%9E%B6%5C3.jpg">
<meta property="og:image" content="https://aaccompany.github.io/2019/07/14/重走spring框架(IOC部分)/%E9%87%8D%E8%B5%B0spring%E6%A1%86%E6%9E%B6%5C4.jpg">
<meta property="og:image" content="https://aaccompany.github.io/2019/07/14/重走spring框架(IOC部分)/5.jpg">
<meta property="og:image" content="https://aaccompany.github.io/2019/07/14/重走spring框架(IOC部分)/6.jpg">
<meta property="og:image" content="https://aaccompany.github.io/2019/07/14/重走spring框架(IOC部分)/7.jpg">
<meta property="og:updated_time" content="2019-09-20T16:15:22.598Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="重走spring框架 IOC部分">
<meta name="twitter:description" content="Spring框架学习过程中的问题：  为什么在使用JDBC使用的是Class.forName(&amp;quot;DriverName&amp;quot;) 而不是 DriverManager.register(new Driver)？ 工厂模式的好处是什么？ 工厂模式下创建的Bean对象应该为多例还是单例？ 什么时候用多例什么时候用单例？ Spring是如何做到立即加载的？ Spring核心容器下两个顶级接口的">
<meta name="twitter:image" content="https://aaccompany.github.io/2019/07/14/重走spring框架(IOC部分)/spring-overview.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://aaccompany.github.io/2019/07/14/重走spring框架(IOC部分)/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  <link rel="stylesheet" href="/css/style.css">
  
  
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitment@0.0.3/style/default.min.css">
  
  
  
</head>


<body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/Aaccompany" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Accompany</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Java Developer &amp; Accompany my lover</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/Aaccompany" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>君子生非异也，善假于物也。<br> 故不积跬步，无以至千里；不积小流，无以成江海。 </p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/MQ/">MQ</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端框架/">后端框架</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/多线程编程系列/">多线程编程系列</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂谈/">杂谈</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程编程/">多线程编程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂谈/">杂谈</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/消息中间件/">消息中间件</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/重走系列/">重走系列</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/spring/" style="font-size: 13.5px;">spring</a> <a href="/tags/多线程编程/" style="font-size: 13px;">多线程编程</a> <a href="/tags/杂谈/" style="font-size: 13px;">杂谈</a> <a href="/tags/消息中间件/" style="font-size: 14px;">消息中间件</a> <a href="/tags/重走系列/" style="font-size: 13.5px;">重走系列</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a><span class="archive-list-count">6</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/多线程编程系列/">多线程编程系列</a>
              </p>
              <p class="item-title">
                <a href="/2020/01/31/并发编程的挑战/" class="title">并发编程的挑战（第一章）</a>
              </p>
              <p class="item-date">
                <time datetime="2020-01-30T16:00:00.000Z" itemprop="datePublished">2020-01-31</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/杂谈/">杂谈</a>
              </p>
              <p class="item-title">
                <a href="/2019/07/14/重走框架系列说明/" class="title">重走框架系列说明</a>
              </p>
              <p class="item-date">
                <time datetime="2019-07-14T11:47:47.000Z" itemprop="datePublished">2019-07-14</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/后端框架/">后端框架</a>
              </p>
              <p class="item-title">
                <a href="/2019/07/14/重走Spring框架(AOP部分)/" class="title">重走spring框架 AOP部分</a>
              </p>
              <p class="item-date">
                <time datetime="2019-07-14T11:40:50.000Z" itemprop="datePublished">2019-07-14</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/后端框架/">后端框架</a>
              </p>
              <p class="item-title">
                <a href="/2019/07/14/重走spring框架(IOC部分)/" class="title">重走spring框架 IOC部分</a>
              </p>
              <p class="item-date">
                <time datetime="2019-07-14T11:40:50.000Z" itemprop="datePublished">2019-07-14</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/MQ/">MQ</a>
              </p>
              <p class="item-title">
                <a href="/2019/07/02/Active消息中间件/" class="title">Active消息中间件</a>
              </p>
              <p class="item-date">
                <time datetime="2019-07-02T02:13:52.000Z" itemprop="datePublished">2019-07-02</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-重走spring框架(IOC部分)" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      重走spring框架 IOC部分
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2019/07/14/重走spring框架(IOC部分)/" class="article-date">
	  <time datetime="2019-07-14T11:40:50.000Z" itemprop="datePublished">2019-07-14</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/后端框架/">后端框架</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/spring/">spring</a>, <a class="article-tag-link" href="/tags/重走系列/">重走系列</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2019/07/14/重走spring框架(IOC部分)/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 9.6k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 38(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h1><p>学习过程中的问题：</p>
<ul>
<li>为什么在使用JDBC使用的是<code>Class.forName(&quot;DriverName&quot;)</code> 而不是 <code>DriverManager.register(new Driver)</code>？</li>
<li>工厂模式的好处是什么？</li>
<li>工厂模式下创建的Bean对象应该为多例还是单例？</li>
<li>什么时候用多例什么时候用单例？</li>
<li>Spring是如何做到立即加载的？</li>
<li>Spring核心容器下两个顶级接口的区别是什么？（<code>BeanFactory/ApplicationContext</code>）</li>
<li>为什么使用XML配置Bean需要给属性设置set/get方法才能注入，而使用注解配置Bean不需要设置set/get方法就能注入？</li>
<li>配置注解类就取代掉配置文件，那么配置文件还有存在的意义吗？</li>
</ul>
<h2 id="1-Spring到底是个什么妖魔鬼怪？"><a href="#1-Spring到底是个什么妖魔鬼怪？" class="headerlink" title="1.Spring到底是个什么妖魔鬼怪？"></a>1.Spring到底是个什么妖魔鬼怪？</h2><h3 id="1-1-Spring的自我介绍？"><a href="#1-1-Spring的自我介绍？" class="headerlink" title="1.1.Spring的自我介绍？"></a>1.1.Spring的自我介绍？</h3><p>1）Spring是分层的 Java SE/EE应用 <strong>full-stack</strong> （提供了全栈式的解决方案）轻量级开源框架</p>
<p>2）以 <strong>IoC</strong>（Inverse Of Control： 反转控制）和 <strong>AOP</strong>（Aspect Oriented Programming：面向切面编程）为<strong>内核</strong></p>
<p>3）提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多 著名的第三方框架和类库</p>
<p>4）Java后端开发的标准 </p>
<h3 id="1-2-Spring的发展历程"><a href="#1-2-Spring的发展历程" class="headerlink" title="1.2. Spring的发展历程"></a>1.2. Spring的发展历程</h3><p>1997 年 IBM提出了EJB 的思想   </p>
<p>1998 年，SUN制定开发标准规范 EJB1.0   </p>
<p>1999 年，EJB1.1 发布   </p>
<p>2001 年，EJB2.0 发布   </p>
<p>2003 年，EJB2.1 发布   </p>
<p>2006 年，EJB3.0 发布   </p>
<p><strong>Rod Johnson（spring之父）</strong>   </p>
<p> Expert One-to-One J2EE Design and Development(2002)    阐述了 J2EE 使用EJB 开发设计的优点及解决方案   </p>
<p> Expert One-to-One J2EE Development without EJB(2004)    阐述了 J2EE 开发不使用 EJB的解决方式（Spring 雏形）      </p>
<p>2017 年 9 月份发布了 spring 的最新版本 spring 5.0 通用版（GA） </p>
<h3 id="1-3-为什么要使用Spring？"><a href="#1-3-为什么要使用Spring？" class="headerlink" title="1.3.为什么要使用Spring？"></a>1.3.为什么要使用Spring？</h3><p>1）方便解耦，简化开发</p>
<p>通过Spring提供的IOC（控制反转）容器，让Bean对象放入到Spring容器中，这样对象之间的依赖关系就可以由Spring去处理，避免硬编码造成程序耦合。也不需要注重Bean是设计成单例还是设计成多例的代码。可以花更多时间去注重上层代码</p>
<p>2）AOP支持(面向切面)</p>
<p>通过Spring提供的AOP支持，可以做到传统的OOP很难完成事情。</p>
<p>3）声明式事务的支持</p>
<p>可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理， 提高开发效率和质量。 </p>
<p>4）方便程序的测试 </p>
<p> 可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可 做的事情</p>
<p>5）方便集合各种优秀的框架</p>
<p>可以很快的整合Mybatis、Spring MVC 、Struts等框架。</p>
<p>6）降低了Java EE的API使用难度</p>
<p>在Spring中，对Java EE（如 JDBC、JavaMail、远程调用等）进行了一层封装，能够通过更少的代码去使用这些技术。</p>
<p>7）代码编写的榜样</p>
<p>Spring采用的代码编写的技巧，设计都十分巧妙，结构清晰，注释完整。是十分值得学习的榜样。</p>
<h3 id="1-4-Spring的体系结构"><a href="#1-4-Spring的体系结构" class="headerlink" title="1.4.Spring的体系结构"></a>1.4.Spring的体系结构</h3><p>在Spring的体系结构中也可以看出Spring是个<strong>full-stack</strong>型框架，提供了各层的解决方案。</p>
<p>其中重要的是Core Container中的部分，这是使用Spring必备部分，不可缺失。</p>
<p><img src="/2019/07/14/重走spring框架(IOC部分)/spring-overview.png" alt></p>
<h2 id="2-如何做到程序解耦？（IOC部分）"><a href="#2-如何做到程序解耦？（IOC部分）" class="headerlink" title="2.如何做到程序解耦？（IOC部分）"></a>2.如何做到程序解耦？（IOC部分）</h2><h3 id="2-1-程序的耦合和解耦"><a href="#2-1-程序的耦合和解耦" class="headerlink" title="2.1.程序的耦合和解耦"></a>2.1.程序的耦合和解耦</h3><p>在说明IOC先知道什么是程序的耦合和耦合</p>
<h4 id="2-1-1-程序的耦合？"><a href="#2-1-1-程序的耦合？" class="headerlink" title="2.1.1.程序的耦合？"></a>2.1.1.程序的耦合？</h4><p>在软件工程中，耦合指的就是就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。划分模块的一个 准则就是高内聚低耦合。</p>
<p> 它有如下分类： </p>
<p>模块耦合分为<strong>数据耦合、特征耦合、控制耦合、公共环境耦合、内容耦合</strong>。耦合程度由低到高。</p>
<p><strong>1）数据耦合：</strong></p>
<p>两个模块彼此间通过参数交换信息，而且交换的信息仅仅是数据（指的是单一的原子的数据片段），那么这种耦合称为数据耦合。<strong>数据耦合是低耦合。系统中至少必须存在这种耦合。这是不可避免的。</strong></p>
<p><strong>2）特征耦合</strong></p>
<p>当把整个<strong>数据结构</strong>作为参数、局部变量或者返回值，而被调用的模块只需要使用其中一部分数据元素时，就出现了特征耦合。（意思为传递了一个数据结构，但是调用方没有将该数据结构中全部数据使用便为特征耦合）</p>
<p>比如判断一个人是否成年，只需要传递该人的出生日期即可，不必要把人传进去。</p>
<p>因此这种耦合，通常是可以通过修改参数、局部变量或者返回值，只使用必要的数据元素来避免。</p>
<p><strong>3）控制耦合</strong></p>
<p>传递的信息中有控制信息(尽管有时这种控制信息以数据的形式出现)，则这种耦合称为控制耦合。控制耦合是中等程度的耦合。</p>
<p>比如，传递的参数中包含一个枚举类型的参数，在方法的具体逻辑中判断该参数实现不同的功能。<br>那么，完全可以通过将一个方法修改为多个方法改进这种耦合。</p>
<p><strong>4）公共环境耦合</strong></p>
<p>当两个或多个模块通过一个公共数据环境相互作用时，它们之间的耦合称为公共环境耦合。<br>公共环境可以是全程变量、共享的通信区、内存的公共覆盖区、任何存储介质上的文件、物理设备等。<br>公共环境耦合的复杂程度随耦合的模块个数而变化，当耦合的模块个数增加时复杂程度显著增加。</p>
<p>只有两个模块有公共环境，耦合有下面两种可能。</p>
<ol>
<li>一个模块往公共环境送数据，另一个模块从公共环境取数据。这是数据耦合的一种形式，是比较松散的耦合。</li>
<li>两个模块都既往公共环境送数据又从里面取数据，这种耦合比较紧密，介于数据耦合和控制耦合之间。</li>
</ol>
<p>限制范围，比如如果是依赖的是汇率，提供一个统一获汇率配置的方法，限制耦合范围。</p>
<p><strong>5）内容耦合</strong></p>
<p>最高程度的耦合是内容耦合。如果出现下列情况之一，两个模块间就发生了内容耦合。</p>
<ol>
<li>一个模块访问另一个模块的内部数据。</li>
<li>一个模块不通过正常入口而转到另一个模块的内部。</li>
<li>两个模块有一部分程序代码重叠(只可能出现在汇编程序中)。</li>
<li>一个模块有多个入口(这意味着一个模块有几种功能)。</li>
</ol>
<p>应该坚决避免使用内容耦合，重构吧。</p>
<h4 id="2-1-4-解决jdbc代码耦合"><a href="#2-1-4-解决jdbc代码耦合" class="headerlink" title="2.1.4.解决jdbc代码耦合"></a>2.1.4.解决jdbc代码耦合</h4><p><strong>思考1：</strong>为什么在使用JDBC使用的是<code>Class.forName(&quot;DriverName&quot;)</code> 而不是 <code>DriverManager.register(new Driver)</code>？</p>
<ul>
<li><p><strong>第一：</strong>使用<code>DriverManager.register</code> 会出现强依赖的现象</p>
<p>第一步出现了依赖现象，如果在Maven中没有导入jdbc的包则会在编译期出现错误。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.注册驱动 在这一步因为需要new 一个Driver对象，出现了强依赖</span></span><br><span class="line">      DriverManager.registerDriver(<span class="keyword">new</span> com.mysql.jdbc.Driver());</span><br><span class="line">      <span class="comment">//2.创建连接</span></span><br><span class="line">      Connection con = DriverManager.getConnection(<span class="string">"url"</span>,<span class="string">"username"</span>,<span class="string">"password"</span>);</span><br><span class="line">      <span class="comment">//3.使用连接，创建sql预处理对象</span></span><br><span class="line">      String sql = <span class="string">"select * from department"</span>;</span><br><span class="line">      PreparedStatement ps = con.prepareStatement(sql);</span><br><span class="line">      <span class="comment">//4.执行查询对象</span></span><br><span class="line">      ResultSet resultSet = ps.executeQuery();</span><br><span class="line">      <span class="comment">//5.遍历数据</span></span><br><span class="line">      <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">          System.out.print(resultSet.getString(<span class="string">"id"</span>));</span><br><span class="line">          System.out.print(resultSet.getString(<span class="string">"name"</span>));</span><br><span class="line">          System.out.println();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//6.释放资源</span></span><br><span class="line">      resultSet.close();</span><br><span class="line">      ps.close();</span><br><span class="line">      con.close();</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>第二：</strong>如果使用的是<code>DriverManager.register</code>的方式去注册，那么驱动会被注册两次</p>
<p>第一次：从翻看源码中可以发现一旦  <code>com.mysql.Driver</code>  被加载，则会调用静态构造函数从而执行<code>java.sql.DriverManager.registerDriver(new Driver());</code>完成驱动注册</p>
<p>第二次：为自己在代码中手动注册了注册</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该mysql连接包的版本为5.1.46  在6.0+的版本中，就不使用com.mysql.Driver的类了</span></span><br><span class="line"><span class="comment">//而是使用com.mysql.cj.jdbc.Driver去完成注册操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Register ourselves with the DriverManager</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct a new driver and register it with DriverManager</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     *             if a database error occurs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>Class.forName(String driverName)</code>的好处</p>
<p>使用了这种方式传递的是字符串，所以并不会在编译期出现错误。从而减少了耦合度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.注册驱动 在这一步因为需要new 一个Driver对象，出现了强依赖</span></span><br><span class="line">      <span class="comment">//DriverManager.registerDriver(new com.mysql.jdbc.Driver());</span></span><br><span class="line">      <span class="comment">//在5.0的驱动版本中使用的是</span></span><br><span class="line">      <span class="comment">//Class.forName("com.mysql.jdbc.Driver()");</span></span><br><span class="line">      <span class="comment">// 在6.0+的驱动版本中使用的是</span></span><br><span class="line">      Class.forName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">      <span class="comment">//2.创建连接</span></span><br><span class="line">      Connection con = DriverManager.getConnection(<span class="string">"jdbc:mysql://120.76.56.183:33306/qingzhai_base"</span>,<span class="string">"root"</span>,<span class="string">"root"</span>);</span><br><span class="line">      <span class="comment">//3.使用连接，创建sql预处理对象</span></span><br><span class="line">      String sql = <span class="string">"select * from department"</span>;</span><br><span class="line">      PreparedStatement ps = con.prepareStatement(sql);</span><br><span class="line">      <span class="comment">//4.执行查询对象</span></span><br><span class="line">      ResultSet resultSet = ps.executeQuery();</span><br><span class="line">      <span class="comment">//5.遍历数据</span></span><br><span class="line">      <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">          System.out.print(resultSet.getString(<span class="string">"id"</span>));</span><br><span class="line">          System.out.print(resultSet.getString(<span class="string">"name"</span>));</span><br><span class="line">          System.out.println();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//6.释放资源</span></span><br><span class="line">      resultSet.close();</span><br><span class="line">      ps.close();</span><br><span class="line">      con.close();</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="2-1-3耦合总结"><a href="#2-1-3耦合总结" class="headerlink" title="2.1.3耦合总结"></a>2.1.3耦合总结</h4><p>总之，耦合是影响软件复杂程度的一个重要因素。<br>应该采取下述设计原则：<br><strong>尽量使用数据耦合，少用控制耦合和特征耦合，限制公共环境耦合的范围，完全不用内容耦合。</strong></p>
<p>ps: 编译器不依赖，运行期才依赖</p>
<h3 id="2-2-如何更加通用的方式解决程序耦合问题？"><a href="#2-2-如何更加通用的方式解决程序耦合问题？" class="headerlink" title="2.2.如何更加通用的方式解决程序耦合问题？"></a>2.2.如何更加通用的方式解决程序耦合问题？</h3><p>通过在2.1.4.中发现了可以使用字符串的方式减少了 new 关键字的出现，便减少程序的耦合度。由此可以进一步挖掘，是否在之后的new  对象的过程省略，而是使用字符串去完成对象的创建，这样便进一步的解决了系统的耦合度。</p>
<p>这时候就可以想到使用Java的反射，创建一个配置文件，在配置文件中，设置类的关键字映射到对应类的全路径上，通过反射完成对象的创建。</p>
<h4 id="2-2-1-使用工厂模式解耦"><a href="#2-2-1-使用工厂模式解耦" class="headerlink" title="2.2.1.使用工厂模式解耦"></a>2.2.1.使用工厂模式解耦</h4><h5 id="2-2-1-1-什么是工厂模式"><a href="#2-2-1-1-什么是工厂模式" class="headerlink" title="2.2.1.1.什么是工厂模式"></a>2.2.1.1.什么是工厂模式</h5><p><strong>个人理解：</strong>将创建的类的过程交由工厂去解决，工厂负责封装具体创建类的过程，只对外提供对应的方法，客户端只需要调用对应的接口便可以获取到对应的类。</p>
<p><strong>好处：</strong>通过工厂模式可以进一步解除系统耦合。</p>
<p><strong>图解：</strong></p>
<p>在未使用工厂模式下客户端直接获取资源(也就是new 对象)，这就造成了高耦合度，不易于扩展</p>
<p><img src="/2019/07/14/重走spring框架(IOC部分)/%E9%87%8D%E8%B5%B0spring%E6%A1%86%E6%9E%B6%5C1.jpg" alt></p>
<p>当使用了工厂模式情况下，客户端需要通过工厂去获取对象，而具体的实现过程被工厂隐藏，工厂读取配置文件，通过反射实例化对象，系统便具有了高扩展性。</p>
<p><img src="/2019/07/14/重走spring框架(IOC部分)/%E9%87%8D%E8%B5%B0spring%E6%A1%86%E6%9E%B6%5C2.jpg" alt></p>
<h5 id="2-2-1-2-简单使用工厂模式创建类"><a href="#2-2-1-2-简单使用工厂模式创建类" class="headerlink" title="2.2.1.2.简单使用工厂模式创建类"></a>2.2.1.2.简单使用工厂模式创建类</h5><p>简单使用：通过<code>BeanName</code>创建对象，减少耦合程度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : Accompany</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> :  2019/09/10</span></span><br><span class="line"><span class="comment"> * 实现类对象的创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties properties;</span><br><span class="line">    <span class="comment">//加载配置文件信息</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过类加载器读取配置文件</span></span><br><span class="line">            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(<span class="string">"application.properties"</span>);</span><br><span class="line">            properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            properties.load(in);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Object <span class="title">getBean</span><span class="params">(String beanName)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取到类路径</span></span><br><span class="line">        String beanPath = properties.getProperty(beanName);</span><br><span class="line">        <span class="comment">//创建类对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Class.forName(beanPath).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-2-1-3-完善工厂模式"><a href="#2-2-1-3-完善工厂模式" class="headerlink" title="2.2.1.3.完善工厂模式"></a>2.2.1.3.完善工厂模式</h5><p><strong>问题1：</strong>单例和多例的区别是什么？好处是什么？</p>
<p><strong>区别：</strong></p>
<ul>
<li>单例：多次通过工厂模式创建同一个对象只会在内存中存在一个实例。<ul>
<li>使用场景：在类中有共享数据或没有成员变量（例如 dao层 service层 ）</li>
<li>好处：因为只创建了一个实例，节省内存和JVM垃圾回收造成的性能浪费、可以存放共享数据（但是会存在线程安全问题）、效率会比多例模式快</li>
<li>坏处：因为是单例的所以会出现线程安全问题</li>
</ul>
</li>
<li>多例：每次通过工厂模式去创建同一个对象都会在内存中创建一个新的实例<ul>
<li>使用场景：当一个类只需要临时使用、每次都需要读最新的配置文件的时候可以使用。</li>
<li>好处：防止并发错误，如果在多线程的情况下，使用的是单例，假如修改了状态值，那么整个请求就会发生异常。</li>
<li>坏处：因为是不断的创建对象，就会占用大量的内存，同时也会导致<code>GC</code>的活动频繁导致性能下降。</li>
</ul>
</li>
</ul>
<p><strong>问题2：</strong>创建Bean应该为多例还是单例？</p>
<ul>
<li>具体问题需要具体分析<ul>
<li>像dao层和service层，没有了成员变量，在线程安全问题上就降低很多，可以使用单例模式</li>
<li>像controller层，在struts2中使用的是多例，但是在spring mvc中使用的是单例。</li>
</ul>
</li>
<li>当对象含有可改变状态时（更精确的说，在实际的应用中该状态会发生改变），使用多例，否则单例</li>
</ul>
<p><strong>修改代码：</strong>同时这也是spring的设计思想，当bean为单例的时候，会将对象在容器初始化的时候创建并且存进Map集合中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; objectMap;</span><br><span class="line">    <span class="comment">//加载配置文件信息</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过类加载器读取配置文件</span></span><br><span class="line">            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream(<span class="string">"application.properties"</span>);</span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            objectMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">            properties.load(in);</span><br><span class="line">            <span class="comment">//将配置文件中全部的对象映射地址创建成对象封装到map集合中</span></span><br><span class="line">            Enumeration&lt;Object&gt; keys = properties.keys();</span><br><span class="line">            <span class="keyword">while</span> (keys.hasMoreElements())&#123;</span><br><span class="line">                <span class="comment">//读取某个对象路径地址</span></span><br><span class="line">                String objKey = (String) keys.nextElement();</span><br><span class="line">                String objPath = properties.getProperty(objKey);</span><br><span class="line">                Object object = Class.forName(objPath).newInstance();</span><br><span class="line">                objectMap.put(objKey,object);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Object <span class="title">getBean</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        未修改前</span></span><br><span class="line"><span class="comment">        //获取到类路径</span></span><br><span class="line"><span class="comment">        String beanPath = properties.getProperty(beanName);</span></span><br><span class="line"><span class="comment">        //创建类对象</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            return Class.forName(beanPath).newInstance();</span></span><br><span class="line"><span class="comment">        &#125; catch (InstantiationException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125; catch (IllegalAccessException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125; catch (ClassNotFoundException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return null;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (!objectMap.containsKey(beanName))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">"类不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objectMap.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-IOC是个啥玩意？"><a href="#2-3-IOC是个啥玩意？" class="headerlink" title="2.3. IOC是个啥玩意？"></a>2.3. IOC是个啥玩意？</h3><p>IOC ：inversion of control （控制反转），这是一种思想理念，并不是只有Spring独有的，在Spring中使用DI去实现了这种思想。</p>
<p>在Spring中的解释为将Bean的创建权、管理权转交由Spring去管理，这样程序员就不必过多的关注Bean的生命周期的问题了，可以更加关注于业务处理。</p>
<h4 id="2-3-1-Spring中IOC"><a href="#2-3-1-Spring中IOC" class="headerlink" title="2.3.1. Spring中IOC"></a>2.3.1. Spring中IOC</h4><ul>
<li><p>1）在工程的POM文件中导入Spring-Context的基本坐标,便具备了Spring IOC功能</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当导入文件会发现会多了很多依赖，对应1.4中Spring的体系结构，可以看出点端倪</p>
<ul>
<li><p>自动加入了<code>spring-apo</code>包，说明了Spring的基础功能需要依赖<code>spring-aop</code></p>
</li>
<li><p>spring中对apache.logging日志处理系统进行封装（<code>spring-jcl</code>包）这就需要注意，如果导入其他框架，该框架也有日志系统的话，那么就会出现冲突问题，这时候就需要解决了。</p>
</li>
</ul>
</li>
</ul>
<p><img src="/2019/07/14/重走spring框架(IOC部分)/%E9%87%8D%E8%B5%B0spring%E6%A1%86%E6%9E%B6%5C3.jpg" alt></p>
<ul>
<li><p>2）在resources目录下创建配置文件（<code>*.xml</code>）文件，该文件的作用为，阐述类的信息和类之间依赖关系</p>
<ul>
<li><p>配置文件信息</p>
<p>根据前面的如何自定义手动解耦的思想，那么可以知道，在配置文件中最起码需要具备 </p>
<p>一个标识符、标识符指向的类的全路径</p>
<p>所以在Spring的配置文件中便会出现Beans的大标签下有Bean的小标签代表着一个个的bean对象。</p>
<p>id便是标识符、class便是指向类的全路径</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.service.impl.studentServiceImpl"</span> <span class="attr">id</span>=<span class="string">"studentService"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>3）在简单使用</p>
<ul>
<li><p>在ui中读取配置文件，并且将存储在spring IOC容器的对象取出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//读取配置文件</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"application.xml"</span>);</span><br><span class="line">        <span class="comment">//将对象从IOC容器中取出</span></span><br><span class="line">        studentService studentService = (studentService) context.getBean(<span class="string">"studentService"</span>);</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        studentService.findAll();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h4 id="2-3-2-Spring-的-BeanFactory-是什么？"><a href="#2-3-2-Spring-的-BeanFactory-是什么？" class="headerlink" title="2.3.2. Spring 的 BeanFactory 是什么？"></a>2.3.2. Spring 的 BeanFactory 是什么？</h4><p>BeanFactory是spring的工厂模式的顶级接口。同时可以从图中看出该接口具体很多实现类，到那时具体使用的只有三个。</p>
<ul>
<li><code>AnnotationConfigApplicationContext</code>：是有关于注解配置</li>
<li><code>ClassPathXMLApplicationContext</code>：读取src目录下的配置文件，也就是存放在resources下的配置文件</li>
<li><code>FileSystemXmlApplicationContext</code>：读取系统中绝对路径下XML文件文件（不推荐使用）</li>
</ul>
<p><img src="/2019/07/14/重走spring框架(IOC部分)/%E9%87%8D%E8%B5%B0spring%E6%A1%86%E6%9E%B6%5C4.jpg" alt></p>
<h4 id="2-3-3-BeanFacotry与ApplicationContext的区别"><a href="#2-3-3-BeanFacotry与ApplicationContext的区别" class="headerlink" title="2.3.3. BeanFacotry与ApplicationContext的区别"></a>2.3.3. BeanFacotry与ApplicationContext的区别</h4><p>BeanFacotry是一个顶级接口，而ApplicationContext是继承了BeanFactory下的HierarchicalBeanFactory也就是说，间接的继承了BeanFactory。</p>
<p><code>BeanFacotry</code>与<code>ApplicaitonContext</code>区别</p>
<ul>
<li><p>他们在创建Bean对象的时间点不同，</p>
<p><code>BeanFacotry</code>（实现类<code>XMLBeanFactory</code>已经弃用的对象）采用的策略是懒加载策略：</p>
<ul>
<li>懒加载：在Bean对象被使用的时候才被加载，容器初始化的时候不会被加载</li>
</ul>
<p><code>ApplicaitonContext</code>采用的策略是立即加载</p>
<ul>
<li>立即加载：在容器初始化的时候就被加载放进了Map集合</li>
</ul>
</li>
</ul>
<p>思考：什么时候使用懒加载什么时候使用立即加载呢？</p>
<p>单例模式使用立即加载</p>
<p>多例模式使用懒加载（因为多例模式最好是在需要的时候在去创建是最节省空间的）</p>
<h4 id="2-3-4-IOC中Bean标签和管理对象细节"><a href="#2-3-4-IOC中Bean标签和管理对象细节" class="headerlink" title="2.3.4. IOC中Bean标签和管理对象细节"></a>2.3.4. IOC中Bean标签和管理对象细节</h4><h5 id="2-3-4-1-Bean标签"><a href="#2-3-4-1-Bean标签" class="headerlink" title="2.3.4.1. Bean标签"></a>2.3.4.1. Bean标签</h5><p>bean标签存在的位置：在spring的配置文件中出现</p>
<p>作用：将对象的管理权交由spring管理</p>
<p>属性：</p>
<ul>
<li>id：指向全路径类的标识符（通常写成类名/接口名）</li>
<li>class：类的全路径信息</li>
<li>scope：指定类对象的作用范围<ul>
<li>singleton：默认值 单例</li>
<li><code>prototyoe</code>：多例</li>
<li><code>request</code>：WEB项目中，将该对象创建放进request域中</li>
<li><code>session</code>：WEB项目中，将该对象创建放进session域中</li>
<li><code>global session</code>：WEB项目中，应用在分布式环境下，将对象创建放进全局session中，如果不是分布式环境下，那么该配置相当于session</li>
</ul>
</li>
</ul>
<h5 id="2-3-4-2实例化Bean的三种方式"><a href="#2-3-4-2实例化Bean的三种方式" class="headerlink" title="2.3.4.2实例化Bean的三种方式"></a>2.3.4.2实例化Bean的三种方式</h5><ul>
<li><p><strong>第一种：通过构造函数去实例化Bean</strong></p>
<ul>
<li>在无参构造函数下实例化</li>
<li>参数说明：<ul>
<li><code>bean</code>：声明一个交由Spring IOC管理的Bean对象</li>
<li><code>id</code>：指向全路径类的标识符（通常写成类名/接口名）</li>
<li><code>class</code>：类的全路径信息</li>
</ul>
</li>
</ul>
<p>这种方式创建的对象是针对无参构造函数的，当存在有参构造函数的时候会出现错误</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentService"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.service.impl.studentServiceImpl"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在有参构造函数下实例化</li>
<li>参数说明<ul>
<li><code>constructor-arg</code>：阐述构造函数参数的信息<ul>
<li><code>name</code>：表示参数的名称</li>
<li><code>value</code>：插入基本数据类型和String类型</li>
<li><code>ref</code>：插入对象类型数据（该对象类型数据必须交由Spring管理才能注入）</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"Student"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.bean.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"15"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"date"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"date"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>第二种：通过静态工厂模式实例化</strong></p>
<ul>
<li><p>该模式是当存在一个工厂，该工厂具有一个静态方法可以获取到一个对象，那么可以通过该方法获取到返回的对象直接放入spring容器中，无须将工厂注入也可以完成。<strong>（这种适用于框架整合，同时该方法必须为静态方法）</strong></p>
<p>工厂对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFacotry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">createStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        student.setName(<span class="string">"梨花"</span>);</span><br><span class="line">        student.setAge(<span class="number">11</span>);</span><br><span class="line">        student.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件：</p>
<ul>
<li>需要注意 class 写的是工厂类的全路径，factory-method 写的是从工厂获取到类的方法</li>
<li>不需要提供需要实例化的对象的全路径</li>
<li>如果方法中需要传值，那么就需要在实例化的对象中加入构造传值</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"StaticStudent"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.Factory.StaticFacotry"</span> <span class="attr">factory-method</span>=<span class="string">"createStudent"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>第三种：通过非静态工厂实例化</strong></p>
<ul>
<li><p>该模式是当存在一个工厂，该工厂具有一个非方法可以获取到一个对象，需要将工厂注入到Spring容器，再通过具体需要实例化的类去调用注入的工厂的方法完成实例化<strong>（这种适用于框架整合，这个工厂方法为非静态方法）</strong></p>
<p>工厂对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">createStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        student.setName(<span class="string">"张三丰"</span>);</span><br><span class="line">        student.setAge(<span class="number">100</span>);</span><br><span class="line">        student.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<ul>
<li>需要注意：在使用非静态工厂方法的时候<ul>
<li>1.先将工厂对象交由spring管理</li>
<li>2.在需要实例化的对象中加入 <code>factory-bean</code>：指向spring中工厂类</li>
<li>3.<code>factory-method</code>：为工厂类中提供对象的方法</li>
<li>4.在需要实例化的对象中不需要添加实例化对象的全路径</li>
<li>5.如果方法中需要传值，那么就需要在实例化的对象中加入构造传值</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"factory"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.Factory.Factory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">factory-bean</span>=<span class="string">"factory"</span> <span class="attr">factory-method</span>=<span class="string">"createStudent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"string"</span> <span class="attr">value</span>=<span class="string">"yyx"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h5 id="2-3-4-3-Bean对象的生命周期"><a href="#2-3-4-3-Bean对象的生命周期" class="headerlink" title="2.3.4.3. Bean对象的生命周期"></a>2.3.4.3. Bean对象的生命周期</h5><p>不同的Bean对象作用范围，生命周期不同。</p>
<p>生命周期方法：在bean标签中</p>
<p><code>init-method</code>：Bean被初始化时调用</p>
<p><code>destory-method</code>：Bean被销毁时调用</p>
<ul>
<li><strong>scope=”singleton”：单例对象</strong> <ul>
<li>在整个应用中只会存在一个对象</li>
<li>生命周期<ul>
<li>对象初始化：当Spring 容器加载的时候，对象就开始初始化（前提是该对象为立即加载）</li>
<li>对象存活：只要容器在，那么对象就会存活</li>
<li>对象死亡：当容器死亡那么对象就死亡</li>
</ul>
</li>
</ul>
</li>
<li><strong>scope=”prototype”：多例对象</strong><ul>
<li>每次get都会创建新的对象</li>
<li>生命周期<ul>
<li>对象初始化：当调用了<code>getBean</code>的方法的时候开始完成对象的初始化</li>
<li>对象存活：只要对象任然在使用中，那么对象就一直存活</li>
<li>对象死亡：当对象没有被使用，等待<code>GC</code>回收，然后释放所占用的内存（需要注意，由于Spring不知道对象什么时候死亡，所以destroy-method 的方法是无法执行的）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-3-5-DI（依赖注入）是个什么玩意？"><a href="#2-3-5-DI（依赖注入）是个什么玩意？" class="headerlink" title="2.3.5. DI（依赖注入）是个什么玩意？"></a>2.3.5. DI（依赖注入）是个什么玩意？</h4><h5 id="2-3-5-1-DI自述"><a href="#2-3-5-1-DI自述" class="headerlink" title="2.3.5.1. DI自述"></a>2.3.5.1. DI自述</h5><p>DI ：Dependency injection  也称为依赖注入，它是Spring框架IOC的具体实现</p>
<p>DI在Spring中的作用是，当容器运行时，能够将对象依赖的数据注入到对象中，比如通过构造方法注入属性，SET方法注入属性。</p>
<h5 id="2-3-5-2-为什么叫依赖注入呢？"><a href="#2-3-5-2-为什么叫依赖注入呢？" class="headerlink" title="2.3.5.2.为什么叫依赖注入呢？"></a>2.3.5.2.为什么叫依赖注入呢？</h5><p>例子：就像是 service层 需要依赖dao层  ，在交给Spring容器管理的时候， 就需要在service层中说明依赖了那个dao层接口，这样service层就可以使用dao层方法了。</p>
<p><strong>好处：</strong>通过将对象注入到对象，维护了类之间依赖关系。这种方式相比于传统模式下更加好，因为减少了硬编码，不需要在代码中写出具体的实现类是什么，而是通过在Bean工厂中获取到对应的实现类，这种方式减少耦合度，增加了系统的可扩展性。</p>
<p><strong>传统模式下的实现方式</strong></p>
<p><img src="/2019/07/14/重走spring框架(IOC部分)/5.jpg" alt></p>
<p><strong>DI方式下的实现方式</strong></p>
<p><img src="/2019/07/14/重走spring框架(IOC部分)/6.jpg" alt></p>
<h5 id="2-3-5-3-构造函数注入"><a href="#2-3-5-3-构造函数注入" class="headerlink" title="2.3.5.3. 构造函数注入"></a>2.3.5.3. 构造函数注入</h5><p>解释：在实例化Bean对象的时候，容器读取配置文件，通过构造函数去实例化对象。</p>
<p>好处：强制要求Bean对象在初始化一定要传递什么值。</p>
<p>坏处：不够灵活，如果有些值不必要传递那么就需要强硬的传值。</p>
<ul>
<li>参数说明<ul>
<li><code>constructor-arg</code>：阐述构造函数参数的信息<ul>
<li><code>name</code>：表示参数的名称</li>
<li><code>value</code>：插入基本数据类型和String类型</li>
<li><code>ref</code>：插入对象类型数据（该对象类型数据必须交由Spring管理才能注入）</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"Student"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.bean.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"15"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"date"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"date"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2-3-5-4-Set-方法注入"><a href="#2-3-5-4-Set-方法注入" class="headerlink" title="2.3.5.4. Set 方法注入"></a>2.3.5.4. Set 方法注入</h5><p>解释：通过给属性设置set方法，容器底层调用set方法将配置文件中对应属性的值注入到对象中。<strong>（属性值必须具有Set方法才能使用）</strong></p>
<p>好处：能够很灵活的给Bean对象注入属性值</p>
<p>坏处：有些属性必须赋值缺做不到，所以需要通过构造函数注入加上Set注入完成最佳化</p>
<p>参数说明</p>
<ul>
<li><code>property</code>：阐述构造函数参数的信息<ul>
<li><code>name</code>：set方法名，去掉set， 第一个字母小写</li>
<li><code>value</code>：插入基本数据类型和String类型</li>
<li><code>ref</code>：插入对象类型数据（该对象类型数据必须交由Spring管理才能注入）</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student1"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.bean.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"200"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"请勿打扰"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"date"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2-3-5-5-p标签注入"><a href="#2-3-5-5-p标签注入" class="headerlink" title="2.3.5.5. p标签注入"></a>2.3.5.5. p标签注入</h5><p>解释：这种方式底层还是使用set方法注入，<strong>需要在引入约束头中加入p空间约束才能使用</strong></p>
<p>好处：更加简单使用set方法注入属性</p>
<p>坏处：需要在约束头中加入p空间约束才能使用</p>
<p>步骤：</p>
<ul>
<li>1.现在约束中加入p空间约束<strong>(在第二行)</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span>      </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>   </span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>2.在bean标签中使用P空间<ul>
<li>格式： <ul>
<li>调用set方法名：<code>set方法名，去掉set， 第一个字母小写</code> </li>
<li>基础数据类型/String数据类型：p: <code>调用set方法名</code>= “属性值”</li>
<li>对象数据类型：p: <code>调用set方法名</code>-ref = “属性值”</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student2"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.bean.Student"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:age</span>=<span class="string">"250"</span> <span class="attr">p:name</span>=<span class="string">"我真帅"</span> <span class="attr">p:birthday-ref</span>=<span class="string">"date"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2-3-5-6-注入集合属性数据"><a href="#2-3-5-6-注入集合属性数据" class="headerlink" title="2.3.5.6.注入集合属性数据"></a>2.3.5.6.注入集合属性数据</h5><p>Spring的DI可以给对象注入 数组，List，Set, Map, Properties的数据,同时也存在着一定的规律</p>
<ul>
<li><p>规律：</p>
<ul>
<li>数组,List,Set是同类型的数据结构，在声明数据结构的时候可以混用</li>
<li>Map,properties是同类型的数据结构，在声明数据结构的时候可以混用</li>
</ul>
</li>
<li><p>给对象注入数组类型（array | list | set）推荐使用 <code>&lt;list&gt; &lt;value&gt;20&lt;/value&gt; &lt;/list&gt;</code></p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student3"</span> <span class="attr">class</span>=<span class="string">"com.accompany.spring.demo1.bean.Student"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"arr"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>5<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>10<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>15<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>20<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>25<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>30<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"set"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>300<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>键值对类型 （map | properties） 推荐使用<code>&lt;map&gt; &lt;entry key=&quot;aa&quot; value=&quot;AA&quot;/&gt; &lt;/map&gt;</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"aa"</span> <span class="attr">value</span>=<span class="string">"AA"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"bb"</span> <span class="attr">value</span>=<span class="string">"BB"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"cc"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"qq"</span> &gt;</span>QQ<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"ww"</span> &gt;</span>WW<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-IOC注解部分"><a href="#2-4-IOC注解部分" class="headerlink" title="2.4. IOC注解部分"></a>2.4. IOC注解部分</h3><h4 id="2-4-1-在Spring如何开启注解？"><a href="#2-4-1-在Spring如何开启注解？" class="headerlink" title="2.4.1. 在Spring如何开启注解？"></a>2.4.1. 在Spring如何开启注解？</h4><p>i.在Spring中，由于注解都是在类上的，又没有告知spring，所以可以知道，要开启注解需要告知spring 在哪里扫描类上的注解。</p>
<p>ii.在告知spring的时候 需要在命名空间加上有关于context 的约束</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启注解扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.accompany.spring.demo1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-IOC注解在Spring中的分类"><a href="#2-4-2-IOC注解在Spring中的分类" class="headerlink" title="2.4.2. IOC注解在Spring中的分类"></a>2.4.2. IOC注解在Spring中的分类</h4><h5 id="2-4-2-1-用于创建对象"><a href="#2-4-2-1-用于创建对象" class="headerlink" title="2.4.2.1.用于创建对象"></a>2.4.2.1.用于创建对象</h5><ul>
<li><p>这类型标签相当于在XML文件中加入了<code>&lt;bean&gt;</code>标签</p>
</li>
<li><p>注解：作用在具体的的实现类上</p>
<ul>
<li>@Component：声明将该类交由spring管理</li>
<li>@Service：声明该类为服务层对象，同时交由spring管理</li>
<li>@Repository：声明该类为数据持久层对象，同时交由spring管理</li>
<li>@Controller：声明该类为控制层对象，同时交由spring管理</li>
</ul>
</li>
<li><p>从源码的角度上分析，对于上面四种注解，@Service、@Repository、@Controller 都是由@Component衍生出来的。无论是@Service、@Repository、@Controller，在注解类上都会存在@Component注解，同时在属性上，也指向了Component的value</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Repository &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">	 * to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@AliasFor</span>(annotation = Component.class)</span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="2-4-2-2-用于数据注入"><a href="#2-4-2-2-用于数据注入" class="headerlink" title="2.4.2.2.用于数据注入"></a>2.4.2.2.用于数据注入</h5><ul>
<li><p>相当于在XML配置文件的<code>&lt;bean&gt;</code>标签中的<code>&lt;property&gt;</code>标签一致。</p>
</li>
<li><p><strong>缺点：</strong>无法给对象注入数组/集合类型数据</p>
</li>
<li><p>问题？：为什么使用XML配置Bean需要给属性设置set/get方法才能注入，而使用注解配置Bean不需要设置set/get方法就能注入？</p>
<ul>
<li><p>分析原因：是否走了set方法？</p>
<ul>
<li>给属性加入set方法进行标记，然后通过注解注入，最后发现并没有走自定义的set方法，说明了并不是使用set方法对属性值进行注入</li>
</ul>
</li>
<li><p>网上查询：读取类文件，通过反射暴力访问私有属性并且对其赋值，大致方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取class对象 （有三种方法）</span></span><br><span class="line">      <span class="comment">//i.通过类名称获取  类名.class;</span></span><br><span class="line">      <span class="comment">//ii.通过对象获取    对象名.getClass()</span></span><br><span class="line">      <span class="comment">//iii.通过类的全路径获取    Class.forName("classPath")</span></span><br><span class="line">      Class&lt;StudentServiceImpl2&gt; c = StudentServiceImpl2.class;</span><br><span class="line">      <span class="comment">//2.通过反射实例化对象</span></span><br><span class="line">      StudentServiceImpl2 rs = c.newInstance();</span><br><span class="line">      <span class="comment">//3.类的属性字段</span></span><br><span class="line">      Field field = c.getDeclaredField(<span class="string">"s1"</span>);</span><br><span class="line">      <span class="comment">//4.设置属性字段允许暴力访问</span></span><br><span class="line">      field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">//5.设置字段值</span></span><br><span class="line">      field.set(rs,<span class="string">"yyx你真帅"</span>);</span><br><span class="line">      rs.print();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>注解：作用在属性上</p>
<ul>
<li><p>注入对象数据类型</p>
<ul>
<li><p><code>@Autowired</code>：从IOC容器中找到类型<strong>唯一且一致</strong>的对象注入。需要注意，当IOC存在多个类型一致的对象，那么在注入的时候，会先找到一批类型一致的对象，在找到属性名称与存储在IOC容器属性名称一致的对象注入。</p>
<ul>
<li>图解</li>
</ul>
<p><img src="/2019/07/14/重走spring框架(IOC部分)/7.jpg" alt></p>
<ul>
<li>@Qualifier：与<code>@Autowired</code>配合使用，通过@Qualifier(value=”bean Name”)指定在IOC容器中对应Bean的KEY值，解决了找不到唯一对象注入的问题</li>
</ul>
</li>
<li><p>@Resource(name=”bean Name”)：在IOC容器中找到同数据类型相同且名称等于bean Name的对象注入</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>注入基础数据类型/String数据类型</p>
<ul>
<li>@Value(value=”xx “)：将xx的值直接注入到属性上</li>
</ul>
</li>
</ul>
<h5 id="2-4-2-3-用于改变作用范围"><a href="#2-4-2-3-用于改变作用范围" class="headerlink" title="2.4.2.3.用于改变作用范围"></a>2.4.2.3.用于改变作用范围</h5><ul>
<li>相当于在XML配置文件的<code>&lt;bean&gt;</code>标签中加入了<code>Scope=&quot;singleton/prototype...&quot;</code></li>
<li>注解：作用在类上<ul>
<li>@Scope(“singleton/prototype…”)</li>
</ul>
</li>
</ul>
<h5 id="2-4-2-4-和生命周期相关"><a href="#2-4-2-4-和生命周期相关" class="headerlink" title="2.4.2.4.和生命周期相关"></a>2.4.2.4.和生命周期相关</h5><ul>
<li>相当于在XML配置文件的<code>&lt;bean&gt;</code>标签中加入了<code>init-method=&quot;&quot; destroy-method=&quot;&quot;</code></li>
<li>注解：作用在方法上<ul>
<li><code>@PostConstruct</code>：类加载时运行（单例模式执行一次，多例模式获取一次执行一次）</li>
<li><code>@PreDestroy</code>：类销毁时运行（单例：容器关闭执行，多例不执行）</li>
</ul>
</li>
</ul>
<h4 id="2-4-3-配置信息类注解"><a href="#2-4-3-配置信息类注解" class="headerlink" title="2.4.3. 配置信息类注解"></a>2.4.3. 配置信息类注解</h4><h5 id="2-4-3-1-配置信息类有什么用？"><a href="#2-4-3-1-配置信息类有什么用？" class="headerlink" title="2.4.3.1.配置信息类有什么用？"></a>2.4.3.1.配置信息类有什么用？</h5><h5 id="2-4-3-2-用于声明该类为配置类"><a href="#2-4-3-2-用于声明该类为配置类" class="headerlink" title="2.4.3.2.用于声明该类为配置类"></a>2.4.3.2.用于声明该类为配置类</h5><ul>
<li>相当于XML配置文件本身</li>
<li>使用说明：跟XML配置差不多，在启动的时候使用<code>ApplicationContext context = new AnnotationConfigApplicationContext(xxx.class...)</code>需要告知主配置类的位置。当使用new 然后传递配置类的时候，可以不用在类上标记注解。同时也可以认为这个类是主配置类。</li>
<li>注解：作用在类上<ul>
<li><code>@Configuration</code>：在某些情况下可以不加此注解<ul>
<li><code>@Import(xxx.class...)</code>在配置类上导入其他配置类，一般放在主配置类上，导入其他配置类（被导入的配置类可以不用加入<code>@Configuration</code>注解）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-4-3-3-包扫描"><a href="#2-4-3-3-包扫描" class="headerlink" title="2.4.3.3.包扫描"></a>2.4.3.3.包扫描</h5><ul>
<li><p>相当于在XML配置文件中加入了<code>&lt;context:component-scan base-package=&quot;xx&quot; /&gt;</code></p>
</li>
<li><p>注解：</p>
<ul>
<li><code>@ComponentScan(&quot;pakeage Path&quot;)</code>：配置单个扫描包</li>
<li><code>@ComponentScan({&quot;xx&quot;,&quot;yy&quot;})</code>：配置多个扫描包</li>
</ul>
</li>
<li><p>注解源码：可以看出 value 和 basePackages 相互指向，所以在传参时，用那个都行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Alias for &#123;<span class="doctag">@link</span> #basePackages&#125;.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Allows for more concise annotation declarations if no other attributes</span></span><br><span class="line"><span class="comment">	 * are needed &amp;mdash; for example, &#123;<span class="doctag">@code</span> <span class="doctag">@ComponentScan</span>("org.my.pkg")&#125;</span></span><br><span class="line"><span class="comment">	 * instead of &#123;<span class="doctag">@code</span> <span class="doctag">@ComponentScan</span>(basePackages = "org.my.pkg")&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@AliasFor</span>(<span class="string">"basePackages"</span>)</span><br><span class="line">	String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Base packages to scan for annotated components.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;&#123;<span class="doctag">@link</span> #value&#125; is an alias for (and mutually exclusive with) this</span></span><br><span class="line"><span class="comment">	 * attribute.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Use &#123;<span class="doctag">@link</span> #basePackageClasses&#125; for a type-safe alternative to</span></span><br><span class="line"><span class="comment">	 * String-based package names.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">	String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="2-4-3-4-用于将方法返回的对象放进容器"><a href="#2-4-3-4-用于将方法返回的对象放进容器" class="headerlink" title="2.4.3.4.用于将方法返回的对象放进容器"></a>2.4.3.4.用于将方法返回的对象放进容器</h5><ul>
<li>相当于在XML加入了<code>&lt;bean&gt;</code>标签，不过和<code>@Component</code>不同的是，<code>@Bean</code>作用在方法上而<code>@Component</code>作用在类上</li>
<li>问题：<ul>
<li>1.如果返回值不是对象，而是基本数据类型，那么是会报错还是会发生什么？<ul>
<li>根据测试得知，是不会报错，而是会将基本数据类型存进容器，id为方法名（觉得自己很蠢，万物皆对象啊！！！！）</li>
</ul>
</li>
<li>2.如果方法中有参数，如何给参数传递值？<ul>
<li>当Spring读取到被<code>@Bean</code>控制方法时，参数注入形式是与<code>@Autowired</code>一致，所以根据这个可知，可以与<code>@Qualifier</code>一同使用达到根据id获取到具体Bean对象。</li>
</ul>
</li>
</ul>
</li>
<li>注解：可以与<code>@Scope</code>注解配合使用，控制作用范围<ul>
<li><code>@Bean(name=&quot;id&quot;)</code>：name=”id” 属性值 可加可不加，当不加入的时候，id为方法名。</li>
</ul>
</li>
</ul>
<h5 id="2-4-3-5-用于读取配置文件"><a href="#2-4-3-5-用于读取配置文件" class="headerlink" title="2.4.3.5.用于读取配置文件"></a>2.4.3.5.用于读取配置文件</h5><ul>
<li>相当于再XML加入了<code>&lt;context:property-placeholder location=``&quot;classpath:conf/*.properties&quot;</code> `file-encoding=<code>&quot;UTF-8&quot;</code>/&gt;</li>
<li>注意：无法读取<code>yml</code>文件</li>
<li>注解：<code>classpath</code>是定义在注解里面特殊字符，表示在类路径找文件，默认采用的是<code>UTF-8</code>解码<ul>
<li><code>@PropertyScource(&quot;classpath:xxx&quot;)</code></li>
</ul>
</li>
</ul>
<h4 id="3-4-4-问题"><a href="#3-4-4-问题" class="headerlink" title="3.4.4.问题"></a>3.4.4.问题</h4><ul>
<li>配置注解类就取代掉配置文件，那么配置文件还有存在的意义吗？<ul>
<li>全注解开发：<ul>
<li>好处：不用写XML配置文件，更简单的配置Bean对象，完成注入等一系列问题。</li>
<li>坏处：由于注解都是写在类上，当类的数量多了起来，那么在后期维护的时候找起来也是一个问题。</li>
</ul>
</li>
<li>纯XML配置开发：<ul>
<li>好处：在XML配置文件中配置可以很广泛的知道在系统中配置了多个Bean，以及注入信息是什么，作用范围是什么。</li>
<li>坏处：XML配置是繁琐的，厚重的。</li>
</ul>
</li>
<li>半注解半配置开发：<ul>
<li>好处：在一定程度上结合了全注解开发以及纯XML配置开发的好处。</li>
<li>什么时候用？：当开发自定义类的时候可以使用注解开发，当配置其他框架的类的时候可以使用XML配置模式开发。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-有关于整合-Junit"><a href="#3-有关于整合-Junit" class="headerlink" title="3.有关于整合 Junit"></a>3.有关于整合 Junit</h2><h3 id="3-1-分析问题"><a href="#3-1-分析问题" class="headerlink" title="3.1.分析问题"></a>3.1.分析问题</h3><p>在测试类中，如果是spring项目测试，就永远离不开IOC容器，但是Junit是不知道是否使用spring，以及配置文件在何处（或主配置类）在何处。</p>
<p>所以也就离不开两句话，同时也不支持注入到测试类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取XML配置或去读配置类</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(ApplicationConfig.class);</span><br><span class="line"><span class="comment">//获取对应的对象</span></span><br><span class="line">Object a = context.getBean(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-2-解决问题思路"><a href="#3-2-解决问题思路" class="headerlink" title="3.2.解决问题思路"></a>3.2.解决问题思路</h3><p>需要让Junit在启动的时候就运行Spring，这样就可以完成在测试中加入注入属性，而不是通过context去获取，但是如何去做？就需要做到替换Junit的启动器<code>Runner</code>成spring自定义的启动器。</p>
<h3 id="3-3-代码实现"><a href="#3-3-代码实现" class="headerlink" title="3.3.代码实现"></a>3.3.代码实现</h3><ul>
<li><p>1.导入有关于测试对应的坐标</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring与junit整合包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--junit --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2.在测试类上加入注解</p>
<ul>
<li><code>@Runwith(SpringJUnit4ClassRunner.class)</code>：表示使用<code>Spring-Test</code>提供的<code>Runner</code>启动器</li>
<li><code>@ContextConfiguration()</code>：表示配置文件位置或者配置类的位置<ul>
<li>属性值：<ul>
<li><code>value=&quot;classpath: &quot;</code>：表示使用XML配置文件，同时在类路径下查找文件</li>
<li><code>classes=&quot;xxx.class...&quot;</code>：表示使用注解类</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = ApplicationConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a:"</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://aaccompany.github.io/2019/07/14/重走spring框架(IOC部分)/" title="重走spring框架 IOC部分" target="_blank" rel="external">https://aaccompany.github.io/2019/07/14/重走spring框架(IOC部分)/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/Aaccompany" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/Aaccompany" target="_blank"><span class="text-dark">Accompany</span><small class="ml-1x">Java Developer &amp; Accompany my lover</small></a></h3>
        <div>这个人很赖，还没有写什么信息。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	

    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2019/07/14/重走Spring框架(AOP部分)/" title="重走spring框架 AOP部分"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2019/07/02/Active消息中间件/" title="Active消息中间件"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/Aaccompany" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
		<p>风雨里做个大人，阳光下做个孩子</p>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script src="/js/plugin.min.js"></script>
<script src="/js/application.js"></script>

    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>


    <script>
(function ($) {
    $('.search-form').on('submit', function (e) {
        var keyword = $('.search-form-input[name="wd"]').val();
        window.location = 'https://www.baidu.com/s?wd=site:aaccompany.github.io ' + keyword;
        return false;
    });
})(jQuery);
</script>




   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
<script src="//cdn.jsdelivr.net/npm/gitment@0.0.3/dist/gitment.browser.min.js"></script>
<script>
var gitment = new Gitment({
  // id默认为当前页面url，如果url后带参数或锚点，gitment要重新初始化
  // https://github.com/imsun/gitment/issues/55
  // 解决方案：id:window.location.pathname,或者将id设置为当前页面标题
  id: '重走spring框架 IOC部分', 
  owner: 'Aaccompany', // 可以是你的GitHub用户名，也可以是github id
  repo: 'git@github.com:Aaccompany/Aaccompany.github.io.git',
  oauth: {
    client_id: '96da4c9e4c6434dd4399',
    client_secret: '4edee086fa4203e9f67a9d19155c9ec5d803ca88',
  }
})
gitment.render('comments')
</script>









</body>
</html>